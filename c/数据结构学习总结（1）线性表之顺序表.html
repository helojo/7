<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修数据结构学习总结（1）线性表之顺序表' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>数据结构学习总结（1）线性表之顺序表</center></div><div class='banquan'>原文出处:本文由博客园博主不能没有你提供。<br/>
原文连接:https://www.cnblogs.com/2019wxw/p/10802048.html</div><br>
    <p>　　　　通过前面的学习知道，具有&ldquo;一对一&rdquo;逻辑关系的数据，最佳的存储方式是使用线性表。那么，什么是线性表呢？</p>
<div id="arc-body"><span style="color: #008000;">线性表，</span>全名为<span style="color: #008000;">线性存储结构</span>。使用线性表存储数据的方式可以这样理解，即&ldquo;把所有数据用一根线儿<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/175.html" target="_blank">串</a></span>起来，再存储到物理空间中&rdquo;。
<div>采用线性表将其储存到物理空间中。
<div>　　　　首先，用&ldquo;一根线儿&rdquo;把它们按照顺序&ldquo;串&rdquo;起来，如图 2 所示：　　
<div>　　　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表0.png" alt="" width="180" height="222" /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 图 2 数据的"线性"结构
<div>图 2 中，左侧是&ldquo;串&rdquo;起来的数据，右侧是空闲的物理空间。把这&ldquo;一串儿&rdquo;数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示
<div>&nbsp;
<div>　　　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表1.png" alt="两种线性存储结构" width="286" height="263" /><br />　　　　　　　　　　　　　　　　　　图 3 两种线性存储结构
<div>　　图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变。因此可以认定，这两种存储方式都是正确的。<br />　　将具有&ldquo;一对一&rdquo;关系的数据&ldquo;线性&rdquo;地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。<br />　　使用线性表存储的数据，如同向<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/181.html" target="_blank">数组</a></span>中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。
<div>　　
<h2>顺序存储结构和链式存储结构</h2>






图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：<ol>
<li>如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/158.html" target="_blank">顺序表</a></span>）；</li>
<li>如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/160.html" target="_blank">链表</a></span>）；</li>






</ol>也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。
<div>
<h2>前驱和后继</h2>






数据结构中，一组数据中的每个个体被称为&ldquo;数据元素&rdquo;（简称&ldquo;元素&rdquo;）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。<br /><br />另外，对于具有&ldquo;一对一&rdquo;逻辑关系的数据，我们一直在用&ldquo;某一元素的左侧（前边）或右侧（后边）&rdquo;这样不专业的词，其实线性表中有更准确的术语：
<ul>
<li>某一元素的左侧相邻元素称为&ldquo;直接前驱&rdquo;，位于此元素左侧的所有元素都统称为&ldquo;前驱元素&rdquo;；</li>
<li>某一元素的右侧相邻元素称为&ldquo;直接后继&rdquo;，位于此元素右侧的所有元素都统称为&ldquo;后继元素&rdquo;；</li>






</ul>






以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：<br />
<div><br />　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表2.png" alt="前驱和后继" /><br />　　　　　　　　　　　　　　　　　　　　图 4 前驱和后继
<div>　　顺序表，全名顺序存储结构，是<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/157.html" target="_blank">线性表</a></span>的一种，线性表用于存储逻辑关系为&ldquo;一对一&rdquo;的数据，顺序表自然也不例外。<br /><br />不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。<br /><br />例如，使用顺序表存储集合&nbsp;<code>{1,2,3,4,5}</code>，数据最终的存储状态如<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/200.html" target="_blank">图</a></span>&nbsp;1 所示：
<div><br />　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表3.png" alt="" /><br />　　　　　　　　　　　　　　　　　　图 1 顺序存储结构示意图







<br />由此我们可以得出，将&ldquo;具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上&rdquo;的存储结构就是顺序存储结构。<br />通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/181.html" target="_blank">数组</a></span>非常接近。其实，顺序表存储数据使用的就是数组。
<div>
<h2>顺序表的初始化</h2>






使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：<ol>
<li>顺序表申请的存储容量；</li>
<li>顺序表的长度，也就是表中存储数据元素的个数；</li>






</ol>







<div><span style="color: #ff0000;">提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。</span>
<div>因此，我们需要自定义顺序表，C 语言实现代码如下
<div>
<div class="cnblogs_code">
<pre><code>typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> Table{
    </span><span style="color: #0000ff;">int</span> * head;<span style="color: #008000;">//</span><span style="color: #008000;">声明了一个名为head的长度不确定的数组，也叫&ldquo;动态数组&rdquo;</span>
    <span style="color: #0000ff;">int</span> length;<span style="color: #008000;">//</span><span style="color: #008000;">记录当前顺序表的长度</span>
    <span style="color: #0000ff;">int</span> size;<span style="color: #008000;">//</span><span style="color: #008000;">记录顺序表分配的存储容量</span>
}table;</code></pre>

<p>注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。</p>
<p>接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：</p>
<ul>
<li>给 head 动态数据申请足够大小的物理空间；</li>
<li>给 size 和 length 赋初值；</li>
</ul>
<p>因此，C 语言实现代码如下：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">#define</span> Size 5 <span style="color: #008000;">//</span><span style="color: #008000;">对Size进行宏定义，表示顺序表申请空间的大小</span><span style="color: #000000;">
table initTable(){
    table t;
    t.head</span>=(<span style="color: #0000ff;">int</span>*)<span style="color: #0000ff;">malloc</span>(Size*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>));<span style="color: #008000;">//</span><span style="color: #008000;">构造一个空的顺序表，动态申请存储空间</span>
    <span style="color: #0000ff;">if</span> (!t.head) <span style="color: #008000;">//</span><span style="color: #008000;">如果申请失败，作出提示并直接退出程序</span>
<span style="color: #000000;">    {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">初始化失败</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    t.length</span>=<span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">空表的长度初始化为0</span>
    t.size=Size;<span style="color: #008000;">//</span><span style="color: #008000;">空表的初始存储空间为Size</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}</span></code></pre>

<p>我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了&ldquo;输出提示信息和强制退出&rdquo;的操作，可以根据你自己的需要对代码中的 if 语句进行改进。<br /><br />通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：</p>







<div>
<div class="cnblogs_code">
<pre><code>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;
<span style="color: #0000ff;">#define</span> Size 5
<span style="color: #008000;">//</span><span style="color: #008000;">定义一个顺序表</span>
typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> table{
    </span><span style="color: #0000ff;">int</span> *head;<span style="color: #008000;">//</span><span style="color: #008000;">用于定义数组头地址</span>
    <span style="color: #0000ff;">int</span> length;<span style="color: #008000;">//</span><span style="color: #008000;">记录当前顺序表的长度</span>
    <span style="color: #0000ff;">int</span> size;<span style="color: #008000;">//</span><span style="color: #008000;">记录顺序表的存储容量</span>
<span style="color: #000000;">}table;
 </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化顺序表</span>
<span style="color: #000000;">table initTable() {
    table t;
    t.head </span>= (<span style="color: #0000ff;">int</span>*)<span style="color: #0000ff;">malloc</span>(Size * <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>));<span style="color: #008000;">//</span><span style="color: #008000;">动态申请存储空间</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.head) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">顺序表初始化是被失败</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    t.length </span>= <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">空表长度初始化为0</span>
    t.size = Size;<span style="color: #008000;">//</span><span style="color: #008000;">空表可以存储元素个数</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">输出顺序表中元素函数</span>
<span style="color: #0000ff;">void</span><span style="color: #000000;"> display(table t) {
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.length;i++<span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,t.head[i]);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() { 
     table t </span>=<span style="color: #000000;"> initTable();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">向顺序表中添加元素</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= Size;i++<span style="color: #000000;">) {
        t.head[i </span>- <span style="color: #800080;">1</span>] =<span style="color: #000000;"> i;
        t.length</span>++<span style="color: #000000;">;
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">顺序表中存储元素分别是：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    display(t);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></code></pre>

<p>程序运行结果如下：</p>

<blockquote>
<div>顺序表中存储的元素分别是：<br />1 2 3 4 5






</blockquote>
<div>可以看到，顺序表初始化成功。
<div>
<h2>顺序表插入元素</h2>







<div>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：<ol>
<li>插入到顺序表的表头；</li>
<li>在表的中间位置插入元素；</li>
<li>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</li>






</ol>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：
<ul>
<li>将要插入位置元素以及后续的元素整体向后移动一个位置；</li>
<li>将元素放到腾出来的位置上；</li>






</ul>






例如，在&nbsp;<code>{1,2,3,4,5}</code>&nbsp;的第 3 个位置上插入元素 6，实现过程如下：
<ul>
<li>遍历至顺序表存储第 3 个数据元素的位置，如<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/200.html" target="_blank">图</a></span>&nbsp;1 所示：</li>






</ul>







<div>　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表4.png" alt="找到目标元素位置" width="347" height="84" /><br />　　　　　　　　　　　　　　　　　　图 1 找到目标元素位置
<div>
<ul>
<li>将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：</li>






</ul>
<div><br />　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表5.png" alt="将插入位置腾出" width="340" height="118" /><br />　　　　　　　　　　　　　　　　　　　　图 2 将插入位置腾出
<ul>
<li>将新元素 6 放入腾出的位置，如图 3 所示：</li>







</ul>
<div><br />　　　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表6.png" alt="插入目标元素" width="305" height="74" /><br />　　　　　　　　　　　　　　　　　　　　图 3 插入目标元素






因此，顺序表插入数据元素的 C 语言实现代码如下：　　　　
<div>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span>
table addTable(table t,<span style="color: #0000ff;">int</span> elem,<span style="color: #0000ff;">int</span><span style="color: #000000;"> add)
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span>
    <span style="color: #0000ff;">if</span> (add&gt;t.length+<span style="color: #800080;">1</span>||add&lt;<span style="color: #800080;">1</span><span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">插入位置有问题</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span>
    <span style="color: #0000ff;">if</span> (t.length==<span style="color: #000000;">t.size) {
        t.head</span>=(<span style="color: #0000ff;">int</span> *)<span style="color: #0000ff;">realloc</span>(t.head, (t.size+<span style="color: #800080;">1</span>)*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.head) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">存储分配失败</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
        }
        t.size</span>+=<span style="color: #800080;">1</span><span style="color: #000000;">;
    } 
    </span><span style="color: #008000;">//</span><span style="color: #008000;">插入操作，需要将从插入位置开始的后续元素，逐个后移</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=t.length-<span style="color: #800080;">1</span>; i&gt;=add-<span style="color: #800080;">1</span>; i--<span style="color: #000000;">) {
        t.head[i</span>+<span style="color: #800080;">1</span>]=<span style="color: #000000;">t.head[i];
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span>
    t.head[add-<span style="color: #800080;">1</span>]=<span style="color: #000000;">elem;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">由于添加了元素，所以长度+1</span>
    t.length++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}</span></code></pre>

<p>注意，动态<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/181.html" target="_blank">数组</a></span>额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</p>
<h2>顺序表删除元素</h2>
从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。　　　　　　　
<blockquote>
<div>&nbsp;后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。
</blockquote>
<div>&nbsp;例如，从&nbsp;<code>{1,2,3,4,5}</code>&nbsp;中删除元素 3 的过程如图 4 所示：
<div><br />　　　　　　　　<img src="./images/数据结构学习总结（1）线性表之顺序表7.png" alt="" /><br />　　　　　　　　　　　　　　图 4 顺序表删除元素的过程示意图






<br />因此，顺序表删除元素的 C 语言实现代码为：
<div>
<div class="cnblogs_code" style="text-align: left;">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">删除指定元素</span>
table deltable(table t,<span style="color: #0000ff;">int</span><span style="color: #000000;"> del) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">add表示顺序表中删除元素的位置</span>
    <span style="color: #0000ff;">if</span> (del&gt;t.length|| del&lt;<span style="color: #800080;">1</span><span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">被删除的元素有误</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">删除操作</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = del; i &lt; t.length;i++<span style="color: #000000;">) {
        t.head[i </span>- <span style="color: #800080;">1</span>] =<span style="color: #000000;"> t.head[i];
    }
    t.length</span>--<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}</span></code></pre>

<h2 style="text-align: left;">顺序表查找元素</h2>
<p style="text-align: left;">顺序表中查找目标元素，可以使用多种查找算法实现，比如说<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/55.html" target="_blank">二分查找</a></span>算法、插值查找算法等。<br />这里，我们选择<span style="text-decoration: underline;"><a href="http://data.biancheng.net/view/54.html" target="_blank">顺序查找</a></span>算法，具体实现代码为：</p>
<div class="cnblogs_code" style="text-align: left;">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">查找函数，其中，elem表示要查找的数据元素的值</span>
<span style="color: #0000ff;">int</span> selectTable(table t,<span style="color: #0000ff;">int</span><span style="color: #000000;"> elem){
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>; i&lt;t.length; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span> (t.head[i]==<span style="color: #000000;">elem) {
            </span><span style="color: #0000ff;">return</span> i+<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果查找失败，返回-1</span>
}</code></pre>

<h2 style="text-align: left;">顺序表更改元素</h2>
<p style="text-align: left;">顺序表更改元素的实现过程是：</p>
<ol style="text-align: left;">
<li>找到目标元素；</li>
<li>直接修改该元素的值；</li>
</ol>
<p style="text-align: left;">顺序表更改元素的 C 语言实现代码为</p>
<div class="cnblogs_code" style="text-align: left;">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span>
table amendTable(table t,<span style="color: #0000ff;">int</span> elem,<span style="color: #0000ff;">int</span><span style="color: #000000;"> newElem){
    </span><span style="color: #0000ff;">int</span> add=<span style="color: #000000;">selectTable(t, elem);
    t.head[add</span>-<span style="color: #800080;">1</span>]=newElem;<span style="color: #008000;">//</span><span style="color: #008000;">由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}</span></code></pre>

<p style="text-align: left;">以上是顺序表使用过程中最常用的基本操作，这里给出本节完整的实现代码：</p>
<div class="cnblogs_code" style="text-align: left;" onclick="cnblogs_code_show('429b1ed9-88ff-4598-9c57-09624ce50737')"><img id="code_img_closed_429b1ed9-88ff-4598-9c57-09624ce50737" class="code_img_closed" src="./images/数据结构学习总结（1）线性表之顺序表8.png" alt="" /><img id="code_img_opened_429b1ed9-88ff-4598-9c57-09624ce50737" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('429b1ed9-88ff-4598-9c57-09624ce50737',event)" src="./images/数据结构学习总结（1）线性表之顺序表9.png" alt="" />
<div id="cnblogs_code_open_429b1ed9-88ff-4598-9c57-09624ce50737" class="cnblogs_code_hide">
<pre><code>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;
<span style="color: #0000ff;">#define</span> Size 5
<span style="color: #008000;">//</span><span style="color: #008000;">定义一个顺序表</span>
typedef <span style="color: #0000ff;">struct</span><span style="color: #000000;"> table{
    </span><span style="color: #0000ff;">int</span> *head;<span style="color: #008000;">//</span><span style="color: #008000;">用于定义数组头地址</span>
    <span style="color: #0000ff;">int</span> length;<span style="color: #008000;">//</span><span style="color: #008000;">记录当前顺序表的长度</span>
    <span style="color: #0000ff;">int</span> size;<span style="color: #008000;">//</span><span style="color: #008000;">记录顺序表的存储容量</span>
<span style="color: #000000;">}table;
 </span><span style="color: #008000;">//</span><span style="color: #008000;">初始化顺序表</span>
<span style="color: #000000;">table initTable() {
    table t;
    t.head </span>= (<span style="color: #0000ff;">int</span>*)<span style="color: #0000ff;">malloc</span>(Size * <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span>));<span style="color: #008000;">//</span><span style="color: #008000;">动态申请存储空间</span>
    <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.head) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">顺序表初始化是被失败</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    t.length </span>= <span style="color: #800080;">0</span>;<span style="color: #008000;">//</span><span style="color: #008000;">空表长度初始化为0</span>
    t.size = Size;<span style="color: #008000;">//</span><span style="color: #008000;">空表可以存储元素个数</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">插入函数，elem:插入的元素   add:插入到顺序表的位置</span>
table addTable(table t, <span style="color: #0000ff;">int</span> elem,<span style="color: #0000ff;">int</span><span style="color: #000000;"> add) {
     </span><span style="color: #008000;">/*</span><span style="color: #008000;">1,判断插入本身是否存在问题
       如果插入元素位置比整张表的长度+1还大，(如果相等，就是尾随的情况)
       或者插入位置本身不存在程序作为提示，自动退出</span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span> (add &gt; t.length + <span style="color: #800080;">1</span> || add &lt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">插入位置有问题</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">做插入时，首先要看顺序表是否有多余的存储空间提供给插入的元素，
    如果没有需要申请
    </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">if</span> (t.length==<span style="color: #000000;">t.size) {
        t.head </span>= (<span style="color: #0000ff;">int</span>*)<span style="color: #0000ff;">realloc</span>(t.head,(t.size+<span style="color: #800080;">1</span>)*<span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.head) {
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">存储分配失败</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        }
        t.size </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">插入操作，需要从插入位置开始的后续元素，逐个后移</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = t.length - <span style="color: #800080;">1</span>; i &gt;= add - <span style="color: #800080;">1</span>;i--<span style="color: #000000;">) {
        t.head[i </span>+ <span style="color: #800080;">1</span>] =<span style="color: #000000;"> t.head[i];
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">后移完成后直接将所需元素，添加到顺序表相应的位置</span>
    t.head[add - <span style="color: #800080;">1</span>] =<span style="color: #000000;"> elem;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">由于添加了元素，所以长度+1</span>
    t.length++<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;     
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">删除指定元素</span>
table deltable(table t,<span style="color: #0000ff;">int</span><span style="color: #000000;"> del) {
    </span><span style="color: #008000;">//</span><span style="color: #008000;">add表示顺序表中删除元素的位置</span>
    <span style="color: #0000ff;">if</span> (del&gt;t.length|| del&lt;<span style="color: #800080;">1</span><span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">被删除的元素有误</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        exit(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">删除操作</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = del; i &lt; t.length;i++<span style="color: #000000;">) {
        t.head[i </span>- <span style="color: #800080;">1</span>] =<span style="color: #000000;"> t.head[i];
    }
    t.length</span>--<span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">查找元素，elem表示要找的数据元素的值</span>
<span style="color: #0000ff;">int</span> findByElem(table t,<span style="color: #0000ff;">int</span><span style="color: #000000;"> elem) {
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i &lt; t.length;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span> (t.head[i]==<span style="color: #000000;">elem) {
            </span><span style="color: #0000ff;">return</span> i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果查找失败返回-1</span>
<span style="color: #000000;">}
</span><span style="color: #008000;">//</span><span style="color: #008000;">更改顺序表中某个元素</span>
table updateTable(table t,<span style="color: #0000ff;">int</span> oldElem,<span style="color: #0000ff;">int</span><span style="color: #000000;"> newElem) {
    </span><span style="color: #0000ff;">int</span> n = findByElem(t,oldElem);<span style="color: #008000;">//</span><span style="color: #008000;">找出old元素所在位置</span>
    t.head[n - <span style="color: #800080;">1</span>] = newElem;<span style="color: #008000;">//</span><span style="color: #008000;">由于返回的是元素在顺序表中的位置，所以-1就是元素在数组的下标</span>
    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">输出顺序表中元素函数</span>
<span style="color: #0000ff;">void</span><span style="color: #000000;"> display(table t) {
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.length;i++<span style="color: #000000;">) {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d </span><span style="color: #800000;">"</span><span style="color: #000000;">,t.head[i]);
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main() { 
     table t </span>=<span style="color: #000000;"> initTable();
    </span><span style="color: #008000;">//</span><span style="color: #008000;">向顺序表中添加元素</span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= Size;i++<span style="color: #000000;">) {
        t.head[i </span>- <span style="color: #800080;">1</span>] =<span style="color: #000000;"> i;
        t.length</span>++<span style="color: #000000;">;
    } 
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">原顺序表中存储元素顺序是：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    display(t); 

    table t1</span>=addTable(t,<span style="color: #800080;">8</span>,<span style="color: #800080;">2</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">添加元素后是：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    display(t1);
    t1</span>=deltable(t1,<span style="color: #800080;">2</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">删除add位上的元素后：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    display(t1);

    </span><span style="color: #0000ff;">int</span> n=findByElem(t1,<span style="color: #800080;">4</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">查找元素4的位置：%d \n</span><span style="color: #800000;">"</span><span style="color: #000000;">,n);

    t1 </span>= updateTable(t1,<span style="color: #800080;">1</span>,<span style="color: #800080;">9</span><span style="color: #000000;">);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">元素1修改为9后遍历：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    display(t1);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p style="text-align: left;"><em id="__mceDel" style="font-family: 'PingFang SC', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px;">程序运行结果为：</em></p>
<p style="text-align: left;"><img src="./images/数据结构学习总结（1）线性表之顺序表10.png" alt="" /></p>
<p style="text-align: left;">&nbsp;总结：</p>
<h2 style="text-align: left;">顺序表的短板</h2>
<p style="text-align: left;"><strong>插入元素，时间复杂度 O(n)</strong></p>
<div style="text-align: left;">插入为 第 i &nbsp;个 元素，则需要移动 &nbsp;n - i +1 &nbsp;个数据元素. 需要移动 第 n &nbsp;到第 i 个 元素。
<div style="text-align: left;">均值的计算: &nbsp;一共为 &nbsp; (n+1)(n+0) &nbsp;/ 2 ，因为一共计算插了 n+1 个位置。则均值为 : &nbsp;n / 2
　　<img src="./images/数据结构学习总结（1）线性表之顺序表11.png" alt="" />
<div><strong>删除元素,时间复杂度 O(n)</strong>
<div>&nbsp;
<div>删除 第 i &nbsp;个 元素，则需要移动 n - i &nbsp;个数据元素 。 需要移动 第 &nbsp; i+ 1 &nbsp;到 第 &nbsp;n 个 元素。
<div>均值的计算:一共为 &nbsp; (n)(n-1+0) &nbsp;/ 2 ，因为一共计算删除&nbsp;n &nbsp;个位置。则均值为 : &nbsp;(n-1) / 2
<div>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/数据结构学习总结（1）线性表之顺序表12.png" alt="" />
<h2>小提示</h2>
<div>1、一般在实际开发时，为了尽量避免移动元素的开销，都会使用贴近硬件的API去完成内存数据的移动，而不是使用循环。例如使用memmove函数。
<div>2、当内部数组的容量不够时，需要重新调整数组的大小，上面的例子我们使用了realloc函数去实现，且每次增加20。然而我们必须认识到，调整大小是很销耗资源的一个操作，因此在实际开发时，我们必须做出明智的容量增长策略。例如：Java中的ArrayList每次将容量扩展为原来的1.5倍。
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/数据结构学习总结（1）线性表之顺序表13.png" alt="" /></p>
<p>&nbsp;</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>