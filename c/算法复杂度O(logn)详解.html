<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修算法复杂度O(logn)详解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>算法复杂度O(logn)详解</center></div><div class='banquan'>原文出处:本文由博客园博主yooooooo提供。<br/>
原文连接:https://www.cnblogs.com/linhaostudy/p/11659846.html</div><br>
    <h2 id="一.ologn代码小证明">一.O(logn)代码小证明</h2>
<p>我们先来看下面一段代码:</p>
<pre><code><code>int cnt = 1;

while (cnt &lt; n)
{
    cnt *= 2;
    //时间复杂度为O(1)的程序步骤序列
}</code></code></pre>
<p>由于cnt每次在乘以2之后都会更加逼近n，也就是说，在有x次后，cnt将会大于n从而跳出循环，所以<span class="math inline">\(2 ^ x = n\)</span>, 也就是<span class="math inline">\(x = log_2n\)</span>，所以这个循环的复杂度为O(logn)</p>
<h2 id="二.典型时间复杂度">二.典型时间复杂度</h2>
<pre><code><code>$c$ 常数
$logN$ 对数级
$log ^ 2N$ 对数平方根
$N$ 线性级
$NlogN$
$N ^ 2$ 平方级
$N ^ 3$ 立方级
$2 ^ N$ 指数级</code></code></pre>
<p>由此我们可以得知，<span class="math inline">\(logN\)</span>的算法效率是最高的</p>
<h2 id="三.常见的logn算法">三.常见的<span class="math inline">\(logN\)</span>算法</h2>
<h3 id="对分查找">1.对分查找</h3>
<pre><code><code>- (int)BinarySearch:(NSArray *)originArray element:(int)element
{
    int low, mid, high;
    low = 0; high = (int)originArray.count - 1;
    while (low &lt;= high) {
        mid = (low + high) / 2;
        if ([originArray[mid] intValue] &lt; element) {
            low = mid + 1;
        } else if ([originArray[mid] intValue] &gt; element) {
            high = mid -1;
        } else {
            return mid;
        }
    }
    
    return -1;
}</code></code></pre>
<h3 id="欧几里得算法">2. 欧几里得算法</h3>
<pre><code><code>- (unsigned int)Gcd:(unsigned int)m n:(unsigned int)n
{
    unsigned int Rem;
    while (n &gt; 0) {
        Rem = m % n;
        m = n;
        n = Rem;
    }
    return m;
}</code></code></pre>
<h3 id="幂运算">3.幂运算</h3>
<pre><code><code>- (long)Pow:(long)x n:(unsigned int)n
{
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return x;
    }
    
    if ([self isEven:n]) {
        return [self Pow:x * x n:n / 2];
    } else {
        return [self Pow:x * x n:n / 2] * x;
    }
}

- (BOOL)isEven:(unsigned int)n
{
    if (n % 2 == 0) {
        return YES;
    } else {
        return NO;
    }
}</code></code></pre>
<h2 id="四.库里的log函数">四.$$库里的log函数</h2>
<p>在$$库里有log()函数和log2()函数</p>
<p>log()函数的底数默认为自然对数的底数e</p>
<p>log2()函数的底数很显然就是2咯qwq</p>
<pre><code><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;
//#define DEBUG(x) cerr &lt;&lt; #x &lt;&lt; &quot;=&quot; &lt;&lt; x &lt;&lt; endl

int main()
{
    cout &lt;&lt; log(M_E) &lt;&lt; endl;
    cout &lt;&lt; log2(2) &lt;&lt; endl;
    return 0;
}</code></code></pre>
<p>然后我们就会得到</p>
<pre><code><code>1
1</code></code></pre>
<p>的结果</p>
<p>$$库里有两个常量M_E和M_PI<br />
M_E代表的是自然对数的底数e<br />
M_PI代表的是圆周率π</p>
<h2 id="最后也是最基本的最重要的">最后，也是最基本的最重要的</h2>
<p>当题目的数据范围达到了<span class="math inline">\(10^{18}\)</span>的时候，很显然就要用O(logn)的算法或数据结构了</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>