<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修数据结构入门-栈' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>数据结构入门-栈</center></div><div class='banquan'>原文出处:本文由博客园博主山丘i提供。<br/>
原文连接:https://www.cnblogs.com/mengd/p/12041368.html</div><br>
    <p>定义：一种可以实现“<strong>先进后出</strong>”的存储结构</p>
<p>分类：</p>
<ol>
<li>静态栈</li>
<li>动态栈</li>
</ol>
<p>算法：</p>
<ol>
<li>出栈</li>
<li>压栈</li>
</ol>
<p>代码实现：</p>
<p><strong>多敲，多敲</strong>，后期改进</p>
<pre><code><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;


typedef struct Node
{
    int data;
    struct Node * pNext;
}NODE , * PNODE;


typedef struct Stack
{
    PNODE pTop;
    PNODE pBottom;
}STACK , * PSTACK;


void init(PSTACK);
void push(PSTACK , int);
void traverse(PSTACK);
bool pop(PSTACK , int *);
void clear(PSTACK pS);


int main(void)
{
    STACK S; // STACK等价于 struct Stack
    int val;

    init(&amp;S); // 目的是造出一个空栈

    push(&amp;S , 1); // 压栈
    push(&amp;S , 8);
    push(&amp;S , 23);
    push(&amp;S , 26);
    push(&amp;S , 34);
    push(&amp;S , 45);
    push(&amp;S , 76);
    push(&amp;S , 88);
    traverse(&amp;S); // 遍历输出

    if(pop(&amp;S , &amp;val))
    {
        printf(&quot;你删除的是%d\n&quot;, val );
        traverse(&amp;S);
        printf(&quot;清空数据\n&quot;);
        clear(&amp;S);
        traverse(&amp;S);
    }
    else
    {
        printf(&quot;删除失败\n&quot;);
    }
}




void init(PSTACK pS)
{
    pS-&gt;pTop = (PNODE)malloc(sizeof(NODE));
    if (NULL == pS-&gt;pTop)
    {
        printf(&quot;动态内存分配失败\n&quot;);
        exit(-1);
    }
    else
    {
        pS-&gt;pBottom = pS-&gt;pTop;
        pS-&gt;pTop-&gt;pNext = NULL; // pS-&gt;pBottom-&gt;pNext = NULL
    }
}


void push(PSTACK pS, int val)
{
    PNODE pNew = (PNODE)malloc(sizeof(NODE));

    pNew-&gt;data = val; 

    pNew-&gt;pNext = pS-&gt;pTop; // 这里需要注意
    pS-&gt;pTop = pNew;

    return;
}


void traverse(PSTACK pS)
{
    PNODE p = pS-&gt;pTop;

    while(p != pS-&gt;pBottom)
    {
        printf(&quot;%d &quot;, p-&gt;data);
        p = p-&gt;pNext;
    }

    printf(&quot;\n&quot;);
    return;
}


bool empty(PSTACK pS )
{
    if (pS-&gt;pTop == pS-&gt;pBottom)
        return true;
    else
        return false;

}


// 把pS所指向的栈出栈一次，并把出栈元素存下
bool pop(PSTACK pS , int *val)
{

    if (empty(pS))
    {
        return false;
    }
    else
    {
        PNODE p = pS-&gt;pTop;
        *val = p-&gt;data;

        pS-&gt;pTop = p-&gt;pNext;
        free(p);
        p = NULL;
        return true;

    }
    
}


// 清空
void clear(PSTACK pS)
{
    if (empty(pS))
    {
        return;
    }
    else
    {
        PNODE p = pS-&gt;pTop;
        PNODE q = NULL;

        while(p != pS-&gt;pBottom)
        {
            q = p-&gt;pNext;
            free(p);
            p = q;
        }

        pS-&gt;pTop = pS-&gt;pBottom;
    }
}</code></code></pre>
<p>应用：</p>
<ol>
<li>函数调用</li>
<li>中断</li>
<li>表达式求值</li>
<li>内存分配</li>
<li>缓冲处理</li>
<li>迷宫</li>
</ol>


</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>