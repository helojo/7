<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修图的深度遍历和广度遍历' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>图的深度遍历和广度遍历</center></div><div class='banquan'>原文出处:本文由博客园博主yooooooo提供。<br/>
原文连接:https://www.cnblogs.com/linhaostudy/p/11830057.html</div><br>
    <h2 id="理论部分">理论部分</h2>
<p>图的深度遍历和广度遍历都不算很难像极了二叉树的前序遍历和层序遍历,如下面的图,可以用右边的邻接矩阵进行表示,假设以顶点0开始对整幅图进行遍历的话,两种遍历方式的思想如下:</p>
<h3 id="深度优先遍历depthfirstsearchdfs">1. 深度优先遍历(depthFirstSearch—DFS)</h3>
<p>由初始顶点开始,沿着一条道一直走,当走到走不动的时候,再回来走一条可以走的通的道,然后再继续往下走,直到走不动,再回来…对应于本图来说就是从0开始往前走,到1-----&gt;然后从1再往前走,到5-----&gt;从5再往前走,到4-------&gt;到了这里发现没路可走了------&gt;就往回走,回到5,看5还有没有路,发现没路-----&gt;则回到1,看1有没有路,也没有-----&gt;再回到0,看0有没有路,发现有------&gt;则由0走到3-----&gt;走到这里发现又没有路了-----&gt;再往回走,走到0,看0还有没有路,发现有-----&gt;则由0走到4,但是4已经被遍历过了,所以再回到0,结束这次遍历过程</p>
<p>但是这时候还有一个2没有遍历啊,该怎么办呢?之前我们是直接就默认从0开始进行往下遍历了,但是从0开始遍历没有一条路可以走到2,为了避免这种情况,我们必须得从每一个顶点开始遍历,这样才能避免漏掉这种只出不进的顶点</p>
<p>于是深度优先遍历得到的遍历结果应为:0 1 5 4 3 2</p>
<h3 id="广度优先遍历broadfirstsearchbfs">2.广度优先遍历(broadFirstSearch—BFS)</h3>
<p>广度遍历我觉得理解起来更简单,就是一层一层的进行遍历,比如说以0顶点开始,0往下指向1,3,4,遍历的时候就先遍历0,然后再遍历它下一层的1,3,4------&gt;然后分别遍历1,3,4的下一层----&gt;而1,3,4只有1有下一层,则遍历1的下一层5,同理最后遍历2</p>
<p>即广度优先遍历得到的遍历结果应为:0 1 3 4 5 2</p>
<p>和二叉树的层序遍历一样,图的广度遍历也用到了队列,对于下图而言,先将0放入队首-----&gt;然后遍历0并将0从队列中取出,同时将0的邻接点1,3,4入队,这样队首就是1-----&gt;然后将1出队,并将1的邻接点入队(这里只有5), 这样队首就是3-----&gt;然后将3弹出并将3的邻接点入队(这里没有),这样队首就是4-----&gt;然后将4弹出并将4的邻接点入队(这里没有),队首就是从1入队的1的第一个邻接点(这里是5)----&gt;然后将5弹出-----&gt;直到队列为空这样就完成了由定点0开始的广度优先遍历</p>
<p><img src="./images/图的深度遍历和广度遍历0.png" /></p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>