<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修第9章 用户自己建立数据类型' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>第9章 用户自己建立数据类型</center></div><div class='banquan'>原文出处:本文由博客园博主Pluto_H提供。<br/>
原文连接:https://www.cnblogs.com/CSAH/p/11091047.html</div><br>
    <h2><img src="./images/第9章 用户自己建立数据类型0.png" alt="" /></h2>
<h2>9.1 定义和使用结构体变量</h2>
<h3>9.1.1 自己建立结构体类型</h3>
<p>C语言允许用户自己建立由不同类型数据组成的组合型的数据结构，它称为<strong>结构体</strong>（structre）。</p>
<p>下面为一个结构体类型：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct Student</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //学号为整型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[20];&nbsp; //姓名为字符串</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char sex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //性别为字符型</p>
<p>int age;&nbsp;&nbsp;&nbsp; //年龄为整型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float score;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //成绩为实型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char addr[30];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //地址为字符串</p>
<p>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //注意最后有一个分号</p>
</td>
</tr>
</tbody>
</table>
<p>声明一个结构体类型的一般形式为：</p>
<p><strong>struct 结构体名</strong></p>
<p><strong>{成员表列};</strong></p>
<p>成员类型声明形式为：</p>
<p><strong>类型名 成员名;</strong></p>
<p><strong>注意：</strong></p>
<p>①结构体类型的名字是由一个<strong>关键字struct</strong>和<strong>结构体名</strong>组合而成的。</p>
<p>②花括号内是该结构体所包括的子项，称为<strong>结构体的成员(member)</strong>。</p>
<p>③结构体名是由用户指定的，又称为&ldquo;结构体标记(structure tag)&rdquo;，如，上面的结构体声明中Student就是结构体名(结构体标记)。</p>
<p>④花括号内是该结构体所包括的子项，称为结构体的成员(member)。如，上面的num,name,sex等都是成员。</p>
<p>⑤结构体里面还可以包含结构体。如下所示</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct Student&nbsp;&nbsp; //声明一个结构体类型 struct Student</p>
<p>{ int num;</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>int age;</p>
<p>struct Date birthday;&nbsp; //成员birthday属于struct Date类型</p>
<p>char addr[30];</p>
<p>};</p>
</td>
</tr>
<tr>
<td width="775">
<p>struct Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明一个结构体类型 struct Date</p>
<p>{ int month;&nbsp;&nbsp; //月</p>
<p>int day;&nbsp;&nbsp;&nbsp; //日</p>
<p>int year;&nbsp;&nbsp;&nbsp; //年</p>
<p>};</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型1.png" alt="" /></p>
<h3>9.1.2 定义结构体类型变量</h3>
<h4>1. 先声明结构体类型，再定义该类型的变量</h4>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>strict Student</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //学号为整型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char name[20];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //姓名为字符串</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char sex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //性别为字符型</p>
<p>int age;&nbsp;&nbsp;&nbsp; //年龄为整型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float score;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //成绩为实型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char addr[30];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //地址为字符串</p>
<p>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //注意最后有一个分号</p>
</td>
</tr>
<tr>
<td width="775">
<p>struct Student&nbsp; student1, student2;</p>
<p>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</p>
<p>结构体类型名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结构体变量名</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型2.png" alt="" /></p>
<h4>2. 在声明类型的同时定义变量</h4>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct Student</p>
<p>{ int num;</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>int age;</p>
<p>float score;</p>
<p>char addr[30];</p>
<p>}student1, student2;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型3.png" alt="" /></p>
<h4>3. 不指定类型名而直接定义结构体类型变量</h4>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct</p>
<p>{ 成员表列</p>
<p>}变量名表列;</p>
</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<p>① 结构体类型与结构体变量是不同的概念，不要混淆。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。</p>
<p>② 结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。</p>
<p>③对结构体变量中的成员（即&ldquo;域&rdquo;），可以单独使用，它的作用与地位相当于普通变量。</p>
<h3>9.1.3 结构体变量的初始化和引用</h3>
<p>[例] 把学生的信息(学号、姓名、性别、住址)放在一个结构体变量中，然后输出这个学生的信息。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{ struct Student&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ long int num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //以下4行为结构体的成员</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>char addr[20];</p>
<p>}student1={10101,"Li Lin",'M',"123 Beijing Road"}; //定义结构体变量a并初始化</p>
<p>printf("NO.:%ld\nname:%s\nsex:%c\naddress:%s\n",student1.num,student1.name,student1.sex,student1.addr);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型4.png" alt="" /></p>
<p>① 在定义结构体变量时可以对它的成员初始化。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>student1={10101,"Li Lin",'M',"123 Beijing Road"}; //定义结构体变量a并初始化</p>
<p>注：对结构体变量初始化，不是对结构体类型初始化</p>
</td>
</tr>
</tbody>
</table>
<p>②可以引用结构体变量中成员的值，引用方式为 <strong>结构体变量名.成员名</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>a.num = 100;</p>
<p>/*已定义了student1为Student类型的结构体变量，则student1.num表示student1变量中的num成员，即student1的num(学号)成员*/</p>
</td>
</tr>
</tbody>
</table>
<p>③如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级的成员</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>student1.num=10010; //结构体变量student1中的成员num</p>
<p>student1.birthday.month=6; //结构体变量student1中的成员birthday中的成员month</p>
</td>
</tr>
</tbody>
</table>
<p>④结构体变量的成员可以像普通变量一样进行各种运算</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>student2.score＝student1.score; //赋值运算</p>
<p>sum=student1.score+student2.score; //加法运算</p>
<p>student1.age++;&nbsp;&nbsp; //自加运算</p>
</td>
</tr>
</tbody>
</table>
<p>⑤同类的结构体变量可以互相赋值</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>student1=student2;&nbsp; //假设student1和student2已定义为同类型的结构体变量</p>
</td>
</tr>
</tbody>
</table>
<p>⑥可以引用结构体变量成员的地址、引用结构体变量的地址(结构体变量的地址主要用作函数参数，传递结构体变量的地址)。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>scanf(&Prime;%d&Prime;,&amp;student1.num); //输入student1.num的值</p>
<p>printf(&Prime;%d&Prime;,&amp;student1); //输出结构体变量student1的起始地址</p>
</td>
</tr>
</tbody>
</table>
<p>[例] 输入两个学生的学号、姓名和成绩，输出成绩较高的学生的学号、姓名和成绩。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ int num;</p>
<p>char name[20];</p>
<p>float score;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }student1,student2; //定义两个结构体变量student1,student2</p>
<p>scanf("%d%s%f",&amp;student1.num,student1.name,&amp;student1.score); //输入学生1的数据</p>
<p>scanf("%d%s%f",&amp;student2.num,student2.name,&amp;student2.score); //输入学生1的数据</p>
<p>printf("The higher score is:\n");</p>
<p>if(student1.score&gt;student2.score)</p>
<p>printf("%d&nbsp; %s&nbsp; %6.2f\n",student1.num,student1.name,student1.score);</p>
<p>else if(student1.score&lt;student2.score)</p>
<p>printf("%d&nbsp; %s&nbsp; %6.2f\n",student2.num,student2.name,student2.score);</p>
<p>else</p>
<p>{ printf("%d&nbsp; %s&nbsp; %6.2f\n",student1.num,student1.name,student1.score);</p>
<p>printf("%d&nbsp; %s&nbsp; %6.2f\n",student2.num,student2.name,student2.score);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p><img src="./images/第9章 用户自己建立数据类型5.png" alt="" /></p>
<h2>9.2 使用结构体数组</h2>
<h3>9.2.1 定义结构体数组</h3>
<p>[例] 有3个候选人，每个选民只能投票选一人，要求编一个统计选票的程序，先后输入被选人的名字，最后输出各人得票结果。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;string.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>struct Person&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Person</p>
<p>{ char name[20];&nbsp;&nbsp;&nbsp; //候选人姓名</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //候选人得票数</p>
<p>}leader[3]={"Li",0,"Zhang",0,"Sun",0}; //定义结构体数组并初始化</p>
<p>&nbsp;</p>
<p>int main()</p>
<p>{ int i,j;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char leader_name[20];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义字符数组</p>
<p>for(i=1;i&lt;=10;i++)</p>
<p>{ scanf("%s",leader_name); //输入所选的候选人姓名</p>
<p>for(j=0;j&lt;3;j++)</p>
<p>if(strcmp(leader_name,leader[j].name)==0) leader[j].count++;</p>
<p>}</p>
<p>printf("\nResult:\n");</p>
<p>for(i=0;i&lt;3;i++)</p>
<p>printf("%5s:%d\n",leader[i].name,leader[i].count);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型6.png" alt="" /></p>
<p>(1)定义结构体数组一般形式是</p>
<p>①声明结构体类型</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct 结构体名</p>
<p>{成员表列} 数组名[数组长度];</p>
</td>
</tr>
</tbody>
</table>
<p>② 先声明一个结构体类型，然后再用此类型定义结构体数组</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>结构体类型数组名[数组长度];</p>
</td>
</tr>
</tbody>
</table>
<p>(2) 对结构体数组初始化的形式是在定义数组的后面加上：＝{初值表列};</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct Person leader[3]= {"Li",0,"Zhang",0,"Sun",0};</p>
</td>
</tr>
</tbody>
</table>
<h3>9.2.2 结构体数组的应用举例</h3>
<p>[例] 有n个学生的信息(包括学号、姓名、成绩)，要求按照成绩的高低顺序输出各学生的信息。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>struct Student&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ int num;</p>
<p>char name[20];</p>
<p>float score;</p>
<p>};</p>
<p>int main()</p>
<p>{ struct Student stu[5]={{10101,"Zhang",78},{10103,"Wang",98.5},{10106,"Li",86},</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {10108,"Ling",73.5},{10110,"Sun",100}};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义结构体数组并初始化</p>
<p>struct Student temp;&nbsp; //定义结构体变量temp，用作交换时的临时变量</p>
<p>const int n=5;&nbsp;&nbsp;&nbsp; //定义常变量n</p>
<p>int i,j,k;</p>
<p>printf("The order is:\n");</p>
<p>for(i=0;i&lt;n-1;i++)</p>
<p>{ k=i;</p>
<p>for(j=i+1;j&lt;n;j++)</p>
<p>if(stu[j].score&gt;stu[k].score)&nbsp;&nbsp; //进行成绩的比较</p>
<p>k=j;</p>
<p>temp=stu[k]; stu[k]=stu[i]; stu[i]=temp; //stu[k]和stu[i]元素互换</p>
<p>}</p>
<p>for(i=0;i&lt;n;i++)</p>
<p>printf("%6d %8s %6.2f\n",stu[i].num,stu[i].name,stu[i].score);</p>
<p>printf("\n");</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p><img src="./images/第9章 用户自己建立数据类型7.png" alt="" /></p>
<h2>9.3 结构体指针</h2>
<p><strong>结构体指针</strong>就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。</p>
<p>把一个结构体变量的起始地址存放在一个指针变量中，这个指针变量就指向该结构体变量。</p>
<p>[例] 通过指向结构体变量的指针变量输出结构体变量中成员的信息。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{ struct Student&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ long num;</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>float score;</p>
<p>};</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student stu_1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义struct Student类型的变量stu_1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义指向struct Student 类型数据的指针变量p</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p=&amp;stu_1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //p指向stu_1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stu_1.num=10101;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //对结构体变量的成员赋值</p>
<p>strcpy(stu_1.name,"Li Lin"); //用字符串复制函数给stu_1.name赋值</p>
<p>stu_1.sex='M';</p>
<p>stu_1.score=89.5;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("No.:%ld\nname:%s\nsex:%c\nscore:%5.1f\n",stu_1.num,stu_1.name,stu_1.sex,stu_1.score);&nbsp;&nbsp; //输出结果</p>
<p>printf("\nNo.:%ld\nname:%s\nsex:%c\nscore:%5.1f\n",(*p).num,(*p).name,(*p).sex, (*p).score);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型8.png" alt="" /></p>
<p><strong>注：(*p).num也可表示为p-&gt;num</strong></p>
<p>如下代码效果和上面的代码效果一致</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;p-&gt;</p>
<p>#include &lt;string.h&gt;</p>
<p>int main()</p>
<p>{ struct Student&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ long num;</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>float score;</p>
<p>};</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student stu_1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义struct Student类型的变量stu_1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义指向struct Student 类型数据的指针变量p</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p=&amp;stu_1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //p指向stu_1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stu_1.num=10101;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //对结构体变量的成员赋值</p>
<p>strcpy(stu_1.name,"Li Lin"); //用字符串复制函数给stu_1.name赋值</p>
<p>stu_1.sex='M';</p>
<p>stu_1.score=89.5;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("No.:%ld\nname:%s\nsex:%c\nscore:%5.1f\n",stu_1.num,stu_1.name,stu_1.sex,stu_1.score);&nbsp;&nbsp; //输出结果</p>
<p>printf("\nNo.:%ld\nname:%s\nsex:%c\nscore:%5.1f\n",p-&gt;num,p-&gt;name,p-&gt;sex, p-&gt;score);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>如果p指向一个结构体变量stu，以下3种用法等价：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="238">
<p>① stu.成员名</p>
<p>stu.num</p>
</td>
<td width="267">
<p>② (*p).成员名</p>
<p>(*p).num</p>
</td>
<td width="270">
<p>③ p-&gt;成员名</p>
<p>p-&gt;num</p>
</td>
</tr>
</tbody>
</table>
<p>[例] 有3个学生的信息，放在结构体数组中，要求输出全部学生的信息。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>struct Student&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ int num;</p>
<p>char name[20];</p>
<p>char sex;</p>
<p>int age;</p>
<p>};</p>
<p>struct Student stu[3]={{10101,"Li Lin",'M',18},{10102,"Zhang Fang",'M',19},{10104,"Wang Min",'F',20}};</p>
<p>//定义结构体数组并初始化</p>
<p>int main()</p>
<p>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Student *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义指向struct Student结构体变量的指针变量</p>
<p>printf(" No. Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sex age\n");</p>
<p>for (p=stu;p&lt;stu+3;p++)</p>
<p>printf("%5d %-20s %2c %4d\n",p-&gt;num, p-&gt;name, p-&gt;sex, p-&gt;age); //输出结果</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型9.png" alt="" /></p>
<p>等价效果图：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型10.png" alt="" /></p>
<h3>9.3.3 用结构体变量和结构体变量的指针作函数参数</h3>
<p>将一个结构体变量的值传递给另一个函数，有如下方法</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p><strong>(1) 用结构体变量的成员作参数</strong></p>
<p>例如，用stu[1].num或stu[2].name作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于&ldquo;<strong>值传递</strong>&rdquo;方式。应当<strong>注意实参与形参的类型保持一致。</strong></p>
</td>
</tr>
<tr>
<td width="775">
<p><strong>(2) 用结构体变量作实参</strong></p>
<p>用结构体变量作实参时，采取的也是&ldquo;值传递&rdquo;的方式，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的。此外，由于采用值传递方式，如果在执行被调用函数期间改变了形参（也是结构体变量）的值，该值不能返回主调函数，这往往造成使用上的不便。因此<strong>一般较少用这种方法，故作了解即可。</strong></p>
</td>
</tr>
<tr>
<td width="775">
<p><strong>(3) 用指向结构体变量（或数组元素）的指针作实参，将结构体变量（或数组元素）的地址传给形参</strong></p>
</td>
</tr>
</tbody>
</table>
<p>[例] 有n个结构体变量，内含学生学号、姓名和3门课程的成绩。要求输出平均成绩最高的学生的信息(包括学号、姓名、3门课程成绩和平均成绩)</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>#define N 3&nbsp;&nbsp; //学生数为3</p>
<p>struct Student&nbsp;&nbsp; //建立结构体类型struct Student</p>
<p>{ int num;&nbsp;&nbsp; //学号</p>
<p>char name[20]; //姓名</p>
<p>float score[3];&nbsp; //3门课成绩</p>
<p>float aver;&nbsp; //平均成绩</p>
<p>};</p>
<p>int main()</p>
<p>{ void input(struct Student stu[]); //函数声明</p>
<p>struct Student max(struct Student stu[]); //函数声明</p>
<p>void print(struct Student stu); //函数声明</p>
<p>struct Student stu[N],*p=stu; //定义结构体数组和指针</p>
<p>input(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //调用input函数</p>
<p>print(max(p)); //调用print函数,以max函数的返回值作为实参</p>
<p>return 0;</p>
<p>}</p>
<p>void input(struct Student stu[])&nbsp; //定义input函数</p>
<p>{ int i;</p>
<p>printf("请输入各学生的信息： 学号、姓名、三门课成绩:\n");</p>
<p>for(i=0;i&lt;N;i++)</p>
<p>{ scanf("%d %s %f %f %f",&amp;stu[i].num,stu[i].name,</p>
<p>&amp;stu[i].score[0],&amp;stu[i].score[1],&amp;stu[i].score[2]);&nbsp; //输入数据</p>
<p>stu[i].aver=(stu[i].score[0]+stu[i].score[1]+stu[i].score[2])/3.0;&nbsp;&nbsp; //求平均成绩</p>
<p>}</p>
<p>}</p>
<p>struct Student max(struct Student stu[]) //定义max函数</p>
<p>{ int i,m=0;&nbsp;&nbsp; //用m存放成绩最高的学生在数组中的序号</p>
<p>for(i=0;i&lt;N;i++)</p>
<p>if(stu[i].aver&gt;stu[m].aver) m=i;</p>
<p>//找出平均成绩最高的学生在数组中的序号</p>
<p>return stu[m];&nbsp; //返回包含该生信息的结构体元素</p>
<p>}</p>
<p>&nbsp;</p>
<p>void print(struct Student stud)&nbsp;&nbsp; //定义print函数</p>
<p>{ printf("\n成绩最高的学生是:\n");</p>
<p>printf("学号:%d\n姓名:%s\n三门课成绩:%5.1f,%5.1f,%5.1f\n平均成绩: %6.2f\n",stud.num,stud.name,stud.score[0],stud.score[1],stud.score[2],stud.aver);</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p><img src="./images/第9章 用户自己建立数据类型11.png" alt="" /></p>
<h2>9.4 用指针处理链表</h2>
<h3>9.4.1 什么是链表</h3>
<p>链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型12.png" alt="" /></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>&nbsp;&nbsp; 链表有一个&ldquo;<strong>头指针</strong>&rdquo;变量，图中以head表示，它存放一个地址，该地址指向一个元素。</p>
<p>&nbsp;&nbsp; 链表中每一个元素称为&ldquo;<strong>结点</strong>&rdquo;，每个结点都应包括两个部分：</p>
<p>&nbsp;(1) 用户需要用的实际数据；</p>
<p>&nbsp;(2) 下一个结点的地址。</p>
<p>head指向第1个元素，第1个元素又指向第2个元素&hellip;&hellip;直到最后一个元素，该元素不再指向其他元素，它称为&ldquo;表尾&rdquo;，它的地址部分放一个&ldquo;NULL&rdquo;（表示&ldquo;空地址&rdquo;），链表到此结束。</p>
</td>
</tr>
</tbody>
</table>
<h3>9.4.2 建立简单的静态链表</h3>
<p>用结构体变量建立链表。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>struct Student</p>
<p>{ int num;</p>
<p>float score;</p>
<p>struct Student *next;&nbsp; //next是指针变量，指向结构体变量</p>
<p>};</p>
</td>
</tr>
<tr>
<td width="775">
<p>成员num和score用来存放结点中的有用数据（用户需要用到的数据）。</p>
<p>next是指针类型的成员，它指向struct Student类型数据（就是next所在的结构体类型）</p>
</td>
</tr>
</tbody>
</table>
<p><strong>注：上面只是定义了一个struct Student类型，并未实际分配存储空间，只有定义了变量才分配存储单元。</strong></p>
<p>[例] 建立一个简单链表，它由3个学生数据的结点组成，要求输出各结点中的数据。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>struct Student&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ int num;</p>
<p>float score;</p>
<p>struct Student*next;</p>
<p>};</p>
<p>int main()</p>
<p>{ struct Student a,b,c,*head,*p; //定义3个结构体变量a,b,c作为链表的结点</p>
<p>a.num=10101; a.score=89.5;&nbsp; //对结点a的num和score成员赋值</p>
<p>b.num=10103; b.score=90;&nbsp; //对结点b的num和score成员赋值</p>
<p>c.num=10107; c.score=85;&nbsp; //对结点c的num和score成员赋值</p>
<p>head=&amp;a;&nbsp;&nbsp;&nbsp;&nbsp; //将结点a的起始地址赋给头指针head</p>
<p>a.next=&amp;b;&nbsp;&nbsp;&nbsp;&nbsp; //将结点b的起始地址赋给a结点的next成员</p>
<p>b.next=&amp;c;&nbsp;&nbsp;&nbsp;&nbsp; //将结点c的起始地址赋给a结点的next成员</p>
<p>c.next=NULL;&nbsp;&nbsp;&nbsp;&nbsp; //c结点的next成员不存放其他结点地址</p>
<p>p=head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //使p指向a结点</p>
<p>do</p>
<p>{ printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); //输出p指向的结点的数据</p>
<p>p=p-&gt;next;&nbsp;&nbsp;&nbsp; //使p指向下一结点</p>
<p>}while(p!=NULL);&nbsp;&nbsp;&nbsp; //输出完c结点后p的值为NULL，循环终止</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型13.png" alt="" /></p>
<h3>9.4.3 建立动态链表</h3>
<p>[例] 建立一个有3名学生数据的单向动态链表。</p>
<p>说明：所谓建立动态链表是指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。</p>
<p>流程图所示：</p>
<p><img src="./images/第9章 用户自己建立数据类型14.png" alt="" /></p>
<p>建立链表的过程示意图：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型15.png" alt="" /></p>
<p><img src="./images/第9章 用户自己建立数据类型16.png" alt="" /></p>
<p>程序代码：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#define LEN sizeof(struct Student)</p>
<p>struct Student</p>
<p>{ long num;</p>
<p>float score;</p>
<p>struct Student*next;</p>
<p>};</p>
<p>int n;&nbsp; //n为全局变量，本文件模块中各函数均可使用它</p>
<p>struct Student *creat(void)</p>
<p>//定义函数。此函数返回一个指向链表头的指针</p>
<p>{ struct Student *head;</p>
<p>struct Student *p1,*p2;</p>
<p>n=0;</p>
<p>p1=p2=(struct Student*) malloc(LEN);&nbsp; //开辟一个新单元</p>
<p>scanf("%ld,%f",&amp;p1-&gt;num,&amp;p1-&gt;score);</p>
<p>//输入第1个学生的学号和成绩</p>
<p>head=NULL;</p>
<p>while(p1-&gt;num!=0)</p>
<p>{ n=n+1;</p>
<p>if(n==1) head=p1;</p>
<p>else p2-&gt;next=p1;</p>
<p>p2=p1;</p>
<p>p1=(struct Student*)malloc(LEN);</p>
<p>//开辟动态存储区，把起始地址赋给p1</p>
<p>scanf("%ld,%f",&amp;p1-&gt;num,&amp;p1-&gt;score);</p>
<p>//输入其他学生的学号和成绩</p>
<p>}</p>
<p>p2-&gt;next=NULL;</p>
<p>return(head);</p>
<p>}</p>
<p>int main()</p>
<p>{ struct Student *pt;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pt=creat(); //函数返回链表第一个结点的地址</p>
<p>printf("\nnum:%ld\nscore:%5.1f\n",pt-&gt;num,pt-&gt;score);</p>
<p>//输出第1个结点的成员值</p>
<p>return 0;</p>
<p>};</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型17.png" alt="" /></p>
<h3>9.4.4 输出链表</h3>
<p>[例] 编写一个输出链表的函数print。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#define LEN sizeof(struct Student)</p>
<p>struct Student&nbsp;&nbsp;&nbsp;&nbsp; //声明结构体类型struct Student</p>
<p>{ long num;</p>
<p>float score;</p>
<p>struct Student *next;</p>
<p>};</p>
<p>int n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //全局变量n</p>
<p>void print(struct Student*head)&nbsp; //定义print函数</p>
<p>{ struct Student*p;&nbsp;&nbsp; //在函数中定义struct Student类型的变量p</p>
<p>printf("\nNow,These %d records are:\n",n);</p>
<p>p=head;&nbsp;&nbsp;&nbsp;&nbsp; //使p指向第1个结点</p>
<p>if(head!=NULL)&nbsp;&nbsp; //若不是空表</p>
<p>do</p>
<p>{ printf("%ld %5.1f\n",p-&gt;num,p-&gt;score); //输出一个结点中的学号与成绩</p>
<p>p=p-&gt;next;&nbsp; //p指向下一个结点</p>
<p>}while(p!=NULL);&nbsp; //当p不是"空地址"</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>流程图：</p>
<p><img src="./images/第9章 用户自己建立数据类型18.png" alt="" /></p>
<h2>9.5 共用体类型</h2>
<h3>9.5.1 什么是共用体类型</h3>
<p>使几个不同类型的变量<strong>共享同一段内存的结构</strong>，称为 &ldquo;<strong>共用体</strong>&rdquo;类型的结构。</p>
<p>定义共用体类型变量的一般形式为：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>union共用体名</p>
<p>{ 成员表列</p>
<p>}变量表列;</p>
</td>
</tr>
</tbody>
</table>
<p>定义共用体的形式：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p><strong>(1) 在声明类型同时定义变量</strong></p>
<p>union Data</p>
<p>{ int i;</p>
<p>//表示不同类型的变量i,ch,f可以存放到同一段存储单元中</p>
<p>char ch;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f;</p>
<p>}a,b,c;&nbsp;&nbsp;&nbsp; //在声明类型同时定义变量</p>
</td>
</tr>
<tr>
<td width="775">
<p><strong>(2) 先声明类型，后定义变量</strong></p>
<p>union Data&nbsp;&nbsp; //声明共用体类型</p>
<p>{ int i;</p>
<p>char ch;</p>
<p>float f;</p>
<p>};</p>
<p>union Data a,b,c; //用共用体类型定义变量</p>
</td>
</tr>
<tr>
<td width="775">
<p><strong>(3) 定义共用体，但是没有定义共用体类型名</strong></p>
<p>union&nbsp; //没有定义共用体类型名</p>
<p>{ int i;</p>
<p>char ch;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float f;</p>
<p>}a,b,c;</p>
</td>
</tr>
</tbody>
</table>
<p><strong>共用体与结构体的区别？</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。</p>
<p>而共用体变量所占的内存长度等于最长的成员的长度，几个成员共用一个内存区。</p>
</td>
</tr>
</tbody>
</table>
<h3>9.5.2 引用共用体变量的方式</h3>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>a.i&nbsp;&nbsp; //引用共用体变量中的整型变量i</p>
<p>a.ch&nbsp; //引用共用体变量中的字符变量ch</p>
<p>a.f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //引用共用体变量中的实型变量f</p>
</td>
</tr>
</tbody>
</table>
<p><strong>注意，不能引用共用体变量，而只能引用共用体变量中的成员。</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>printf(&Prime;%d&Prime;,a);&nbsp;&nbsp;&nbsp; //这是错误的</p>
<p>printf(&Prime;%d&Prime;,a.i);&nbsp; //这是正确的</p>
</td>
</tr>
</tbody>
</table>
<h3>9.5.3 共用体类型数据的特点</h3>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>(1) 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个</p>
</td>
</tr>
<tr>
<td width="775">
<p>(2) 可以对共用体变量初始化，但初始化表中只能有一个常量</p>
</td>
</tr>
<tr>
<td width="775">
<p>(3) 共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就被取代</p>
</td>
</tr>
<tr>
<td width="775">
<p>(4) 共用体变量的地址和它的各成员的地址都是同一地址</p>
</td>
</tr>
<tr>
<td width="775">
<p>(5) 不能对共用体变量名赋值，也不能企图引用变量名来得到</p>
<p>一个值。C 99允许同类型的共用体变量互相赋值</p>
</td>
</tr>
<tr>
<td width="775">
<p>(6) C 99允许用共用体变量作为函数参数</p>
</td>
</tr>
<tr>
<td width="775">
<p>(7) 共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员</p>
</td>
</tr>
</tbody>
</table>
<p>[例] 有若干个人员的数据，其中有学生和教师。学生的数据中包括： 姓名、号码、性别、职业、班级。教师的数据包括： 姓名、号码、性别、职业、职务。要求用同一个表格来处理。</p>
<p>&nbsp;<img src="./images/第9章 用户自己建立数据类型19.png" alt="" /></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>//定义结构体与共用体</p>
<p>#include &lt;stdio.h&gt;</p>
<p>struct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //声明无名结构体类型</p>
<p>{ int num;&nbsp;&nbsp;&nbsp;&nbsp; //成员num(编号)</p>
<p>char name[10];&nbsp;&nbsp; //成员name(姓名)</p>
<p>char sex;&nbsp;&nbsp;&nbsp;&nbsp; //成员sex(性别)</p>
<p>char job;&nbsp;&nbsp;&nbsp;&nbsp; //成员job(职业)</p>
<p>union&nbsp;&nbsp;&nbsp;&nbsp; //声明无名共用体类型</p>
<p>{ int clas;&nbsp;&nbsp;&nbsp; //成员clas(班级)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char position[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //成员position(职务)</p>
<p>}category;&nbsp;&nbsp;&nbsp; //成员category是共用体变量</p>
<p>}person[2];&nbsp;&nbsp;&nbsp;&nbsp; //定义结构体数组person，有两个元素</p>
</td>
</tr>
<tr>
<td width="775">
<p>//执行函数</p>
<p>int main()</p>
<p>{ int i;</p>
<p>for(i=0;i&lt;2;i++)</p>
<p>{ printf("please enter the data of person:\n");</p>
<p>scanf("%d %s %c %c",&amp;person[i].num,person[i].name,&amp;person[i].sex,&amp;person[i].job);&nbsp; //输入前4项</p>
<p>if(person[i].job=='s')</p>
<p>scanf("%d",&amp;person[i].category.clas);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如是学生，输入班级</p>
<p>else if(person[i].job=='t')</p>
<p>scanf("%s",person[i].category.position);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如是教师，输入职务</p>
<p>else</p>
<p>printf("Input error!");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如job不是's'和't'，显示&ldquo;输入错误&rdquo;</p>
<p>}</p>
<p>printf("\n");</p>
<p>printf("No.namesex job class/position\n");</p>
<p>for(i=0;i&lt;2;i++)</p>
<p>{ if (person[i].job=='s')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //若是学生</p>
<p>printf("%-6d%-10s%-4c%-4c%-10d\n",person[i].num,person[i].name,person[i].sex,person[i].job,person[i].category.clas);</p>
<p>else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //若是教师</p>
<p>printf("%-6d%-10s%-4c%-4c%-10s\n",person[i].num, person[i].name,person[i].sex,person[i].job,person[i].category.position);</p>
<p>}</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>运行结果：</p>
<p><img src="./images/第9章 用户自己建立数据类型20.png" alt="" /></p>
<h2>9.6 使用枚举类型</h2>
<p>声明枚举类型的一般形式：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>enum [枚举名]{枚举元素列表}</p>
<p>例：enum Weekday{sun，mon，tue，wed，thu，fri，sat};</p>
</td>
</tr>
</tbody>
</table>
<p>如果一个变量只有几种可能的值，则可以定义为枚举(enumeration)类型，所谓&ldquo;枚举&rdquo;就是指把可能的值一一列举出来，变量的值只限于列举出来的值的范围内。</p>
<p>声明枚举类型用enum开头。花括号中的sun,mon,&hellip;,sat称为枚举元素或 枚举常量。</p>
<p>也可以不声明有名字的枚举类型，而直接定义枚举变量：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>enum {sun，mon，tue，wed，thu，fri，sat}workday,weekend;</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>(1) C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符(有名字)而把它们看作变量，不能对它们赋值</p>
</td>
</tr>
<tr>
<td width="775">
<p>(2) 每一个枚举元素都代表一个整数，C语言编译按定义时的顺序默认它们的值为0,1,2,3,4,5&hellip;。也可以在定义枚举类型时显式地指定枚举元素的数值</p>
</td>
</tr>
<tr>
<td width="775">
<p>(3) 枚举元素可以用来作判断比较。枚举元素的比较规则是按其在初始化时指定的整数来进行比较的</p>
</td>
</tr>
</tbody>
</table>
<p>[例] 口袋中有红、黄、蓝、白、黑5种颜色的球若干个。每次从口袋中先后取出3个球，问得到3种不同颜色的球的可能取法，输出每种排列的情况。</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>#include &lt;stdio.h&gt;</p>
<p>int main()</p>
<p>{ enum Color {red,yellow,blue,white,black};&nbsp;&nbsp;&nbsp;&nbsp; //声明枚举类型enum Color</p>
<p>enum Color i,j,k,pri;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义枚举变量i,j,k,pri</p>
<p>int n,loop;</p>
<p>n=0;</p>
<p>for(i=red;i&lt;=black;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //外循环使i的值从red变到black</p>
<p>for(j=red;j&lt;=black;j++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //中循环使j的值从red变到black</p>
<p>if(i!=j) //如果二球不同色</p>
<p>{ for (k=red;k&lt;=black;k++)&nbsp;&nbsp;&nbsp; //內循环使k的值从red变到black</p>
<p>if ((k!=i) &amp;&amp; (k!=j))&nbsp;&nbsp;&nbsp; //如果3球不同色</p>
<p>{ n=n+1;&nbsp;&nbsp;&nbsp;&nbsp; //符合条件的次数加1</p>
<p>printf("%-4d",n);&nbsp;&nbsp;&nbsp; //输出当前是第几个符合条件的组合</p>
<p>for(loop=1;loop&lt;=3;loop++)&nbsp; //先后对3个球分别处理</p>
<p>{ switch (loop)&nbsp;&nbsp; //loop的值从1变到3</p>
<p>{ case 1: pri=i;break; //loop的值为1时，把第1球的颜色赋给pri</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2: pri=j;break;&nbsp;&nbsp; //loop的值为2时，把第2球的颜色赋给pri</p>
<p>case 3: pri=k;break; //loop的值为3时，把第3球的颜色赋给pri</p>
<p>default:break;</p>
<p>}</p>
<p>switch (pri)//根据球的颜色输出相应的文字</p>
<p>{ case red:printf("%-10s","red");break;&nbsp; //pri的值等于枚举常量red时输出"red"</p>
<p>case yellow: printf("%-10s","yellow");break; //pri的值等于枚举常量yellow时输出"yellow"</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case blue: printf("%-10s","blue");break;&nbsp;&nbsp; //pri的值等于枚举常量blue时输出"blue"</p>
<p>case white: printf("%-10s","white");break; //pri的值等于枚举常量white时输出"white"</p>
<p>case black: printf("%-10s","black"); break; //pri的值等于枚举常量black时输出"black"</p>
<p>default:break;</p>
<p>}</p>
<p>}</p>
<p>printf("\n");</p>
<p>}</p>
<p>}</p>
<p>printf("\ntotal:%5d\n",n);</p>
<p>return 0;</p>
<p>}</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>9.7 用typedef声明新类型名</h2>
<p>1. 简单地用一个新的类型名代替原有的类型名</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>typedef int Integer; //指定用Integer为类型名，作用与int相同</p>
<p>typedef float Real; //指定用Real为类型名，作用与float相同</p>
</td>
</tr>
</tbody>
</table>
<p>2. 命名一个简单的类型名代替复杂的类型表示方法</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>① 命名一个新的类型名代表结构体类型</p>
<p>② 命名一个新的类型名代表数组类型</p>
<p>③ 命名一个新的类型名代表指针类型</p>
<p>④命名一个新的类型名代表指向函数的指针类型</p>
</td>
</tr>
<tr>
<td width="775">
<p>typedef struct</p>
<p>{ int month;</p>
<p>int day;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int year;</p>
<p>}Date;&nbsp;&nbsp;&nbsp; //声明了一个新类型名Date，代表结构体类型</p>
<p>Date birthday;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //定义结构体类型变量birthday，不要写成struct Date birthday;</p>
<p>Date*p;&nbsp;&nbsp;&nbsp; //定义结构体指针变量p，指向此结构体类型数据</p>
<p>&nbsp;</p>
<p>typedef int Num[100]; //声明Num为整型数组类型名</p>
<p>Num a;&nbsp;&nbsp;&nbsp; //定义a为整型数组名，它有100个元素</p>
<p>&nbsp;</p>
<p>typedef char*String； //声明String为字符指针类型</p>
<p>String p,s[10];&nbsp;&nbsp; //定义p为字符指针变量，s为字符指针数组</p>
<p>&nbsp;</p>
<p>ypedef int (*Pointer)(); //声明Pointer为指向函数的指针类型，该函数返回整型值</p>
<p>Pointer p1,p2;&nbsp;&nbsp; //p1,p2为Pointer类型的指针变量</p>
</td>
</tr>
</tbody>
</table>
<p>声明一个新的类型名的方法是：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>① 先按定义变量的方法写出定义体（如： int i;）</p>
<p>② 将变量名换成新类型名（例如： 将i换成Count）</p>
<p>③ 在最前面加typedef（例如： typedef int Count）</p>
<p>④ 然后可以用新类型名去定义变量</p>
<p>简单地说，就是按定义变量的方式把变量名换上新类型名，并在最前面加typedef，就声明了新类型名代表原来的类型。</p>
</td>
</tr>
<tr>
<td width="775">
<p><strong>以定义上述的数组类型为例来说明： </strong></p>
<p>① 先按定义数组变量形式书写： int a[100]</p>
<p>② 将变量名a换成自己命名的类型名： int Num[100]</p>
<p>③ 在前面加上typedef，得到typedef int Num[100]</p>
<p>④ 用来定义变量： Num a; 相当于定义了： int a[100];</p>
<p>同样，对字符指针类型，也是：</p>
<p>① char *p;&nbsp; //定义变量p的方式</p>
<p>② char *String; //用新类型名String取代变量名p</p>
<p>③ typedef char *String; //加typedef</p>
<p>④ String p; //用新类型名String定义变量，相当char *p;</p>
<p>习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别。</p>
</td>
</tr>
</tbody>
</table>
<p>对"typedef声明新类型名"说明</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="775">
<p>(1) typedef的方法实际上是为特定的类型指定了一个同义字(synonyms)</p>
</td>
</tr>
<tr>
<td width="775">
<p>(2) 用typedef只是对已经存在的类型指定一个新的类型名，而没有创造新的类型</p>
</td>
</tr>
<tr>
<td width="775">
<p>(3) 用tyoedef声明数组类型、指针类型，结构体类型、共用体类型、枚举类型等，使得编程更加方便</p>
</td>
</tr>
<tr>
<td width="775">
<p>(4) typedef与#define表面实质不同的。#define是在预编译时处理的，它只能作简单的字符串替换，而typedef是在编译阶段处理的，且并非简单的字符串替换</p>
</td>
</tr>
<tr>
<td width="775">
<p>(5) 当不同源文件中用到同一类型数据(尤其是像数组、指针、结构体、共用体等类型数据)时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到它们的文件中用#include指令把它们包含到文件中。这样编程者就不需要在各文件中自己定义typedef名称了</p>
</td>
</tr>
<tr>
<td width="775">
<p>(6) 使用typedef名称有利于程序的通用与移植;有时程序会依赖于硬件特性,用typedef类型就便于移植</p>
</td>
</tr>
</tbody>
</table>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>