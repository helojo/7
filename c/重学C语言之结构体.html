<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修重学C语言之结构体' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>重学C语言之结构体</center></div><div class='banquan'>原文出处:本文由博客园博主adfcae提供。<br/>
原文连接:https://www.cnblogs.com/wuyusl/p/11441300.html</div><br>
    <h2 id="概念">概念</h2>
<p>结构体是一种构造类型，由若干个成员组成，成员可以是基本数据类型，或是另一个结构体</p>
<p>声明结构体</p>
<pre><code><code>struct 结构体名
{
    成员列表
};</code></code></pre>
<p>结构体名表示结构的类型名。</p>
<p>声明一个结构体表示创建一种新的类型名（自定义数据类型），然后用类型名定义变量。</p>
<pre><code><code>struct Product
{
    char name[10];
    char shape[10];
    char color[10];
    float price;
}</code></code></pre>
<p>使用结构体定义变量有三种方式</p>
<p><strong>第一种：声明结构体类型，再定义变量</strong></p>
<pre><code><code>struct Product p1;
struct Product p2;</code></code></pre>
<p>p1和p2是结构体变量名，这两个变量具有相同的结构</p>
<p>类比：</p>
<pre><code><code>   类型名             变量名
    int                 a;
     |                  |    
struct Product          p;</code></code></pre>
<p>struct Product整体表示一种数据类型</p>
<p>定义结构体变量后，系统会为其分配内存单元</p>
<p><strong>第二种：声明结构体类型时，同时定义变量(可以定义多个变量)</strong></p>
<pre><code><code>struct 结构体名
{
    成员列表
} 变量名列表;</code></code></pre>
<p>example:</p>
<pre><code><code>struct Product
{
    char name[10];
    char shape[10];
    char color[10];
    float price;
} p1, p2;</code></code></pre>
<p><strong>第三种：直接定义结构体类型变量（匿名结构体，没有结构体名称）</strong></p>
<pre><code><code>struct
{
    成员列表
} 成员变量;</code></code></pre>
<p>example：</p>
<pre><code><code>struct
{
    char name[10];
    char shape[10];
    char color[10];
    float price;
} p1, p2;</code></code></pre>
<hr />
<p>类型和变量时不同的：</p>
<ul>
<li>只能对变量进行赋值操作，而不能对一个类型操作</li>
<li>类型不分配空间，只对变量分配空间</li>
</ul>
<p>结构体成员也可以时结构体类型变量：</p>
<pre><code><code>struct date
{
    int year;
    int month;
    int day;
};

struct student
{
    char name[20];
    char gender;
    int age;
    // 结构体类型变量
    struct date birthday;
};</code></code></pre>
<hr />
<p>结构体变量的引用</p>
<pre><code><code>结构体变量名.成员名</code></code></pre>
<p>example:</p>
<pre><code><code>p1.name = &quot;IceBox&quot;;
p2.price = 2000;</code></code></pre>
<p>如果成员本身又属于另一个结构体类型，需要使用多个成员运算符</p>
<pre><code><code>struct student s;
s.birthday.year = 1986;
s.birthday.month = 11;
s.birthday.day = 6;</code></code></pre>
<p>不仅可以对结构体变量成员的地址进行引用，还可以对结构体变量的地址进行引用</p>
<pre><code><code>scanf(&quot;%d&quot;, &amp;p1.price);
printf(&quot;%O&quot;, &amp;p1); // 输出p1的首地址</code></code></pre>
<hr />
<p>结构体类型的初始化</p>
<pre><code><code>struct Student
{
    char name[10];
    char gender;
    int grade;
} student = { &quot;Felix&quot;, &quot;m&quot;, 4 };</code></code></pre>
<p>注意：每一个数据要与结构体的成员列表的顺序一样。</p>
<hr />
<p>定义结构体数组</p>
<pre><code><code>struct 结构体名
{
    成员列表
}数组名;</code></code></pre>
<p>example:</p>
<pre><code><code>struct Student
{
    char name[20];
    int code;
    char gender;
    int grade;
} student[5];</code></code></pre>
<p>这种方式是声明结构体类型的同时定义结构体数组。也可以先声明结构体类型，再定义变量</p>
<pre><code><code>struct Student student[5];</code></code></pre>
<p>或直接定义结构体数组：</p>
<pre><code><code>struct
{
    char name[20];
    int code;
    char gender;
    int grade;
} student[5];</code></code></pre>
<p>以上定义了一个数组，其中元素为<code>struct Student</code>类型的数据，每个数据中又有4个成员变量。看图：</p>
<p><img src="./images/重学C语言之结构体0.png" alt="结构体数组" /></p>
<hr />
<p>结构体数组的初始化</p>
<pre><code><code>struct 结构体名
{
    成员列表
} 数组名 = {初始值列表};</code></code></pre>
<p>example:</p>
<pre><code><code>struct Student
{
    char name[20];
    int code;
    char gender;
    int grade;
} student[5] = {
    {&quot;关羽&quot;, 192829, &#39;M&#39;, 3},
    {&quot;张飞&quot;, 82873, &#39;M&#39;, 2},
    {&quot;赵云&quot;, 827348, &#39;M&#39;, 4},
    {&quot;黄忠&quot;, 9238347, &#39;M&#39;, 4},
    {&quot;刘备&quot;, 983784, &#39;M&#39;, 5}
};</code></code></pre>
<p>为数组进行初始化时，最外层的大括号列出数组的元素，因为每个元素都是结构体类型，所以每个元素也使用大括号，其中包含每一个结构体成员数据。</p>
<p>定义结构体数组时，也可以先声明结构体类型，再定义结构体数组。</p>
<pre><code><code>struct Student student[5] = {
    {&quot;关羽&quot;, 192829, &#39;M&#39;, 3},
    {&quot;张飞&quot;, 82873, &#39;M&#39;, 2},
    {&quot;赵云&quot;, 827348, &#39;M&#39;, 4},
    {&quot;黄忠&quot;, 9238347, &#39;M&#39;, 4},
    {&quot;刘备&quot;, 983784, &#39;M&#39;, 5}
};</code></code></pre>
<h2 id="结构体指针">结构体指针</h2>
<p>一个指向变量的指针，表示变量所占用内存中的起始地址。如果一个指针指向结构体变量，则该指针指向的时结构体变量的起始地址。</p>
<p>定义结构体指针：</p>
<pre><code><code>结构体类型 *指针名;</code></code></pre>
<p>example:</p>
<pre><code><code>// 指向struct Student结构类型的pStudent指针变量
struct Student *pStudent;</code></code></pre>
<p>使用指向结构体变量的指针访问成员有两种方法：</p>
<p><strong>第一种：使用点运算符引用结构体成员</strong></p>
<pre><code><code>// 一定要使用括号，因为点运算符的优先级最高
(*pStudent).成员名
// example
(*pStudent).code = 9837849;</code></code></pre>
<p><strong>第二种：使用指向运算符引用结构体成员</strong></p>
<pre><code><code>pStudent-&gt;成员名;
// example
pStudent-&gt;code = 393848;</code></code></pre>
<p>如果<code>student</code>是结构体变量，<code>pStudent</code>是指向结构体变量的指针，以下三种效果是等价的：</p>
<pre><code><code>student.成员名;
(*pStudent).成员名;
pStudent-&gt;成员名;</code></code></pre>
<hr />
<p>指向结构体数组的指针</p>
<p>结构体指针变量不但可以指向一个结构体变量，还可以指向结构体数组，此时指针变量的值就是结构体数组的首地址。</p>
<p>结构体指针变量可以直接指向结构体数组中的元素，这时指针变量的值就是该结构体数组元素的首地址。</p>
<pre><code><code>// 假设：struct Student student[5];
struct Student *pStudent;
// 指向数组的首地址
pStudent = student;</code></code></pre>
<p>数组不使用下标时，表示数组的第一个元素的地址，所以指针指向数组的首地址。 如果想利用指针指向第3个元素，则在数组名后附加下标，然后在数组名前使用取地址符号&amp;</p>
<pre><code><code>pStudent = &amp;student[2];</code></code></pre>
<hr />
<p>结构体作为函数参数</p>
<p>使用结构体作为函数参数有3种形式：</p>
<ul>
<li>使用结构体变量作为函数的参数</li>
<li>使用结构体变量的成员作为函数参数</li>
<li>使用指向结构体变量的指针作为函数的参数</li>
</ul>
<p><strong>第一种：使用结构体变量作为函数的参数</strong><br />
使用结构体变量的作为函数的实参时，采取的是&quot;值传递&quot;，会将结构体变量所占内存单元的内容全部顺序传递给形参，形参也必须是同类型的结构体变量</p>
<pre><code><code>void display(struct Student stu);</code></code></pre>
<p>在形参位置使用结构体变量，但是函数调用期间，形参也要占用内存单元，这种传递方式在空间和时间上开销都比较大。</p>
<p>根据函数参数传值方式，如果在函数内部修改了变量中成员的值，则改变的值不会返回到主调函数中。</p>
<p><strong>第二种：使用结构体变量的指针作为参数</strong><br />
在使用结构体变量作为函数的参数时，传值过程中空间和时间开销大，可以使用结构体变量的指针作为函数的参数进行传递。</p>
<p>在使用结构体变量的指针时，只是将结构体变量的首地址进行传递，并没有将变量的副本进行传递。</p>
<pre><code><code>void display(struct Student *stu);</code></code></pre>
<p>因为这里传递的变量时地址，如果在函数中改变成员中的数据，那么返回主调函数时变量会发生改变。</p>
<pre><code><code>#include &lt;stdio.h&gt;

struct Student {
    char name[20];
    float score[30];
} student = { &quot;刘备&quot;, 98.39f, 89.0, 93.5f };

void display(struct Student *s) {
    printf(&quot;-------------以下是学生信息-------------\n&quot;);
    printf(&quot;姓名： %s\n&quot;, s-&gt;name);
    printf(&quot;数学成绩： %.2f\n&quot;, s-&gt;score[2]);
    // 修改了数组元素的值
    s-&gt;score[2] = 90.2f;
}

int main(int argc, char const *argv[]) {
    struct Student *pStudent;
    pStudent = &amp;student;
    display(pStudent);
    // 也可以直接传递结构体变量的地址作为参数
    // display(&amp;student);
    
    // 主调函数中，结构体成员的值发生了改变
    printf(&quot;修改后的数学成绩： %.2f\n&quot;, pStudent-&gt;score[2]);
    return 0;
}</code></code></pre>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>