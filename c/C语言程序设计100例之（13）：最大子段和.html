<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C语言程序设计100例之（13）：最大子段和' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C语言程序设计100例之（13）：最大子段和</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11902351.html</div><br>
    <h4><span style="font-size: 18px;">例13 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最大子段和</span></h4>
<p><strong>题目描述</strong></p>
<p>给出一段序列，选出其中连续且非空的一段使得这段和最大。例如在序列2,-4,3,-1,2,-4,3中，最大的子段和为4，该子段为3,-1,2。</p>
<p><strong>输入格式</strong></p>
<p>第一行是一个正整数N，表示了序列的长度。</p>
<p>第二行包含N个绝对值不大于10000的整数Ai ，描述了这段序列。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，为最大的子段和是多少。子段的最小长度为1。</p>
<p><strong>输入样例</strong></p>
<p>7</p>
<p>2 -4 3 -1 2 -4 3</p>
<p><strong>输出样例</strong></p>
<p>4</p>
<h5><span style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; （1）编程思路。</span></h5>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 可以从长度为n的数列的最左端（设为数组元素a[1]）开始扫描，一直到最右端（设为数组元素a[n-1]）为止，记下所遇到的最大总和的子序列。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 程序中定义变量maxsum保存最大连续子段和，cursum保存当前连续子段和。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 初始时，cursum=a[0]、maxsum=a[0]。用循环for (i=1;i&lt;n;i++)对序列中的每一个元素a[i]进行扫描处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 在这一扫描过程中，从左到右记录当前子序列的和（即cursum= cursum+a[i]），若这个和不断增加（即当前a[i]为正，从而使cursum+a[i]&gt;maxsum成为可能），那么最大子序列的和maxsum也增加，从而更新maxsum。如果往右扫描中遇到负数，那么当前子序列的和cursum会减小，此时cursum将会小于maxsum，maxsum也就不更新；如果扫描到a[i]时，cursum降到0时，说明前面已经扫描的那一段就可以抛弃了，这时需要将cursum置为0。这样，cursum将从i之后的子段进行分析，若有比当前maxsum大的子段，需要更新maxsum。这样一趟扫描结束后，就可以得到正确结果。</p>
<h5><span style="font-size: 16px;">&nbsp; &nbsp; &nbsp; &nbsp; （2）源程序。</span></h5>
<p style="margin-left: 60px;">#include &lt;stdio.h&gt;</p>
<p style="margin-left: 60px;">int main()</p>
<p style="margin-left: 60px;">{</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; int a[200001];</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; int n,i,maxsum,cursum;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; scanf("%d",&amp;n);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; for (i=0;i&lt;n;i++)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;a[i]);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; cursum=a[0];</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; maxsum=a[0];</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; for (i=1;i&lt;n;i++)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp;{</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cursum+a[i]&gt;maxsum)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;maxsum=cursum+a[i];</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cursum+a[i]&lt;0)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (a[i]&lt;0)&nbsp; cursum=0;</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else&nbsp; &nbsp;cursum=a[i];</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursum= cursum+a[i] ;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; printf("%d\n",maxsum);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 60px;">}</p>
<h4><span style="font-size: 18px;">习题13</span></h4>
<h5><span style="font-size: 16px;">13-1&nbsp; 最大差值</span></h5>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 本题选自洛谷题库 （https://www.luogu.org/problem/P5146）</p>
<p><strong>题目描述</strong></p>
<p>HKE最近热衷于研究序列，有一次他发现了一个有趣的问题：</p>
<p>对于一个序列A1 ,A2 ⋯An ，找出两个数i,j，1&le;i&lt;j&le;n，使得Aj &minus;Ai 最大。</p>
<p>现在给出这个序列，请找出Aj &minus;Ai 的最大值。</p>
<p><strong>输入格式</strong></p>
<p>第一行为一个正整数n。</p>
<p>接下来n个整数，第k+1个整数为Ak 。</p>
<p><strong>输出格式</strong></p>
<p>一行为 (Aj &minus;Ai )的最大值</p>
<p><strong>输入样例</strong></p>
<p>10</p>
<p>1 3 4 6 7 9 10 1 2 9</p>
<p><strong>输出样例</strong></p>
<p>9</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 由于求Aj &minus;Ai 的最大值的要求是下标j&gt;i，也就是说最大的数是在最小的数后面才符合要求，因此不能简单地求序列的一个最大数max和一个最小数min（无法保证max一定在min的后面），然后输出max-min作为答案。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 定义变量minnum保存序列的最小数，maxdiff保存最大差值，由于输入n&gt;=2，因此可以先输入序列前两个数a和b，赋minnum的初值为a与b中的较小数，maxdiff的初值为b-a。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 然后用循环for (i=3;i&lt;=n;i++)对序列中的每一个元素Ai进行扫描处理。处理时，若当前Ai与最小数minnum的差值大于maxdiff，则更新maxdiff，这个更新一定是有效的，因为保存的最小数minnum一定在当前数Ai之前；若当前数Ai比最小数小，则更新最小数minnum为当前数Ai。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 这样一趟扫描结束后，就可以得到正确结果。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序。</p>
<p style="margin-left: 60px;">#include &lt;stdio.h&gt;</p>
<p style="margin-left: 60px;">int main()</p>
<p style="margin-left: 60px;">{</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; int minnum,maxdiff;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; int i,n,a,b;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; scanf("%d",&amp;n);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; scanf("%d%d",&amp;a,&amp;b);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; minnum=a&lt;b?a:b;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; maxdiff=b-a;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; for (i=3;i&lt;=n;i++)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d",&amp;a);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a&lt;minnum) minnum=a;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a-minnum&gt;maxdiff) maxdiff=a-minnum;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; printf("%d\n",maxdiff);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 60px;">}</p>
<h5><span style="font-size: 16px;">13-2&nbsp; 连续自然数和</span></h5>
<p><strong>题目描述</strong></p>
<p>对一个给定的自然数M，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为M。</p>
<p>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为M=10000的一个解。</p>
<p><strong>输入格式</strong></p>
<p>包含一个整数的单独一行给出M的值（10&le;M&le;2,000,000）。</p>
<p><strong>输出格式</strong></p>
<p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p>
<p><strong>输入样例</strong></p>
<p>10000</p>
<p><strong>输出样例</strong></p>
<p>18 142</p>
<p>297 328</p>
<p>388 412</p>
<p>1998 2002</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 定义两个变量left和right用于指示待求子序列的最左端和最右端，初始时令left=1，right=(int)sqrt(2.0*n)，显然此时1+2+&hellip;+right的和值sum（sum=(right-left+1)*(left+right)/2）会非常接近n。之后进行如下操作过程：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 1）比较sum与n，根据sum与n的大小关系进行不同处理。简单描述就是若sum值大了，去掉子序列最左端的数，从而减少sum值；若sum值小了，将最右端数的下一个数加入子序列，从而增大sum值；若sum与n相等，则找到一个子序列的和等于n，输出此时子序列的left和right值，输出后和值sum中去掉子序列最左端的数以便继续向后找到其他的子序列。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2）重复上面的过程，直到left==right，此时子序列中只有一个数，搜索结束，退出。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 60px;">#include &lt;stdio.h&gt;</p>
<p style="margin-left: 60px;">#include &lt;math.h&gt;</p>
<p style="margin-left: 60px;">int main()</p>
<p style="margin-left: 60px;">{</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; int left,right,sum,n;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d",&amp;n);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; left=1;&nbsp;&nbsp; right=(int)sqrt(2.0*n);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; sum=(right-left+1)*(left+right)/2;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; while (left&lt;right)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; if (sum==n)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; {</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d %d\n",left,right);</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum-=left++;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; else if (sum&lt;n)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; {</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right++;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; sum+=right;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; else</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; {</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; sum-=left;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; left++;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 60px;">}</p>
<h5><span style="font-size: 16px;">13-3&nbsp; Subsequence</span></h5>
<p>本题选自北大POJ 题库（http://poj.org/problem?id=3061）。</p>
<p><strong>Description</strong></p>
<p>A sequence of N positive integers (10 &lt; N &lt; 100 000), each of them less than or equal 10000, and a positive integer S (S &lt; 100 000 000) are given. Write a program to find the minimal length of the subsequence of consecutive elements of the sequence, the sum of which is greater than or equal to S.</p>
<p><strong>Input</strong></p>
<p>The first line is the number of test cases. For each test case the program has to read the numbers N and S, separated by an interval, from the first line. The numbers of the sequence are given in the second line of the test case, separated by intervals. The input will finish with the end of file.</p>
<p><strong>Output</strong></p>
<p>For each the case the program has to print the result on separate line of the output file.if no answer, print 0.</p>
<p><strong>Sample Input</strong></p>
<p>2</p>
<p>10 15</p>
<p>5 1 3 5 10 7 4 9 2 8</p>
<p>5 11</p>
<p>1 2 3 4 5</p>
<p><strong>Sample Output</strong></p>
<p>2</p>
<p>3</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;本题题意是：输入整数N和S，N表示数列中元素的个数，S表示一个和值，然后输入数列中的N个元素，求一个子序列长度最短的连续子序列，使子序列中全部元素的和大于等于S。输出这个子序列的长度。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 用两个变量i和j表示子序列的两个端点，初始时i和j的值均为0，和值sum=0。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 这个搜索过程简单描述为：先让右端点移动，并将右端点的值累加到和值sum中（语句为sum+=a[j++]），直到sum大于等于S，按要求更新答案；然后再让左端点移动，并将左端点的值从和值sum中减掉（语句为sum-=a[i++];），也随之更新答案，直到出现sum小于S后，右端点再移动。重复这个过程，直到右端点越过了原序列的最后一个数据。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序。</p>
<p style="margin-left: 60px;">#include &lt;stdio.h&gt;</p>
<p style="margin-left: 60px;">int main()</p>
<p style="margin-left: 60px;">{</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; int t,i,j,a[100001],n,s,sum,minx;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d",&amp;t);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; while(t--)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d%d",&amp;n,&amp;s);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;n;i++)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d",&amp;a[i]);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=0;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minx=0x7fffffff;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum=0;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (j=0;j&lt;n;)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(sum&lt;s &amp;&amp; j&lt;n)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum+=a[j++];</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(sum&gt;=s)</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (minx&gt;j-i) minx=j-i;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum-=a[i++];</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (minx==0x7fffffff)</p>
<p style="margin-left: 60px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minx=0;</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%d\n",minx);</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 60px;">}</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>