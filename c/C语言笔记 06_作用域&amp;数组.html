<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C语言笔记 06_作用域&amp;数组' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C语言笔记 06_作用域&amp;数组</center></div><div class='banquan'>原文出处:本文由博客园博主RopeHuo提供。<br/>
原文连接:https://www.cnblogs.com/rope/p/12039568.html</div><br>
    <h2 id="作用域">作用域</h2>
<p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
<ol>
<li>在函数或块内部的<strong>局部</strong>变量</li>
<li>在所有函数外部的<strong>全局</strong>变量</li>
<li>在<strong>形式</strong>参数的函数参数定义中</li>
</ol>
<h3 id="局部变量">局部变量</h3>
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</p>
<h3 id="全局变量">全局变量</h3>
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</p>
<p>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。</p>
<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。</p>
<h3 id="形式参数">形式参数</h3>
<p>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。</p>
<blockquote>
<p><strong>全局变量与局部变量在内存中的区别</strong>：</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
<p>更多内容可参考：<a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C/C++ 中 static 的用法全局变量与局部变量</a></p>
</blockquote>
<h3 id="初始化局部变量和全局变量">初始化局部变量和全局变量</h3>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">数据类型</th>
<th style="text-align: left;">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">int</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">char</td>
<td style="text-align: left;">'\0'</td>
</tr>
<tr class="odd">
<td style="text-align: left;">float</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">double</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pointer</td>
<td style="text-align: left;">NULL</td>
</tr>
</tbody>
</table>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h2 id="数组">数组</h2>
<p>C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。数组中的特定元素可以通过索引访问。</p>
<p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<h3 id="声明数组">声明数组</h3>
<p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<pre><code><code>type arrayName [ arraySize ];</code></code></pre>
<p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下：</p>
<pre><code><code>double balance[10];</code></code></pre>
<p>现在 <em>balance</em> 是一个可用的数组，可以容纳 10 个类型为 double 的数字。</p>
<h3 id="初始化数组">初始化数组</h3>
<p>在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：</p>
<pre><code><code>double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code></code></pre>
<p>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。</p>
<p>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：</p>
<pre><code><code>double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code></code></pre>
<p>您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：</p>
<pre><code><code>balance[4] = 50.0;</code></code></pre>
<p>上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。</p>
<h3 id="访问数组元素">访问数组元素</h3>
<p>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。</p>
<h3 id="c-中数组详解">C 中数组详解</h3>
<p>在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">概念</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="https://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html">多维数组</a></td>
<td style="text-align: left;">C 支持多维数组。多维数组最简单的形式是二维数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://www.runoob.com/cprogramming/c-passing-arrays-to-functions.html">传递数组给函数</a></td>
<td style="text-align: left;">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://www.runoob.com/cprogramming/c-return-arrays-from-function.html">从函数返回数组</a></td>
<td style="text-align: left;">C 允许从函数返回数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://www.runoob.com/cprogramming/c-pointer-to-an-array.html">指向数组的指针</a></td>
<td style="text-align: left;">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td>
</tr>
</tbody>
</table>
<h4 id="多维数组">多维数组</h4>
<p>多维数组声明的一般形式如下：</p>
<pre><code><code>type name[size1][size2]...[sizeN];</code></code></pre>
<p>例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：</p>
<pre><code><code>int threedim[5][10][4];</code></code></pre>
<h5 id="二维数组">二维数组</h5>
<p>一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：</p>
<pre><code><code>type arrayName [ x ][ y ];</code></code></pre>
<p>一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：</p>
<pre><code><code>int x[3][4];</code></code></pre>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/09/two_dimensional_arrays.jpg" alt="img" /></p>
<h6 id="初始化二维数组">初始化二维数组</h6>
<p>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</p>
<pre><code><code>int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};</code></code></pre>
<p>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</p>
<pre><code><code>int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};</code></code></pre>
<h6 id="访问二维数组元素">访问二维数组元素</h6>
<p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：</p>
<pre><code><code>int val = a[2][3];</code></code></pre>
<p>上面的语句将获取数组中第 3 行第 4 个元素。</p>
<p>下面的程序，我们将使用嵌套循环来处理二维数组：</p>
<pre><code><code>#include &lt;stdio.h&gt;
 
int main ()
{
   /* 一个带有 5 行 2 列的数组 */
   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
   int i, j;
 
   /* 输出数组中每个元素的值 */
   for ( i = 0; i &lt; 5; i++ )
   {
      for ( j = 0; j &lt; 2; j++ )
      {
         printf(&quot;a[%d][%d] = %d\n&quot;, i,j, a[i][j] );
      }
   }
   return 0;
}</code></code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code><code>a[0][0] = 0
a[0][1] = 0
a[1][0] = 1
a[1][1] = 2
a[2][0] = 2
a[2][1] = 4
a[3][0] = 3
a[3][1] = 6
a[4][0] = 4
a[4][1] = 8</code></code></pre>
<h4 id="传递数组给函数">传递数组给函数</h4>
<p>如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，您也可以传递一个多维数组作为形式参数。</p>
<h5 id="方式-1">方式 1</h5>
<p>形式参数是一个指针：</p>
<pre><code><code>void myFunction(int *param)
{

}</code></code></pre>
<h5 id="方式-2">方式 2</h5>
<p>形式参数是一个已定义大小的数组：</p>
<pre><code><code>void myFunction(int param[10])
{

}</code></code></pre>
<h5 id="方式-3">方式 3</h5>
<p>形式参数是一个未定义大小的数组：</p>
<pre><code><code>void myFunction(int param[])
{

}</code></code></pre>
<p>就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。</p>
<h4 id="从函数返回数组">从函数返回数组</h4>
<p>C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。可以先跳过本章，等了解了 C 指针的概念之后，再来学习这里的内容。</p>
<p>如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：</p>
<pre><code><code>int * myFunction()
{

}</code></code></pre>
<p>另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>下面的函数，它会生成 10 个随机数，并使用数组来返回它们，请注意其中包含了<a href="https://www.runoob.com/cprogramming/c-standard-library.html">标准库</a>的函数，具体如下：</p>
<pre><code><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
 
/* 要生成和返回随机数的函数 */
int * getRandom( )
{
  static int  r[10];
  int i;
 
  /* 设置种子 */
  srand( (unsigned)time( NULL ) );
  for ( i = 0; i &lt; 10; ++i)
  {
     r[i] = rand();
     printf( &quot;r[%d] = %d\n&quot;, i, r[i]);
 
  }
 
  return r;
}
 
/* 要调用上面定义函数的主函数 */
int main ()
{
   /* 一个指向整数的指针 */
   int *p;
   int i;
 
   p = getRandom();
   for ( i = 0; i &lt; 10; i++ )
   {
       printf( &quot;*(p + %d) : %d\n&quot;, i, *(p + i));
   }
 
   return 0;
}</code></code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code><code>r[0] = 313959809
r[1] = 1759055877
r[2] = 1113101911
r[3] = 2133832223
r[4] = 2073354073
r[5] = 167288147
r[6] = 1827471542
r[7] = 834791014
r[8] = 1901409888
r[9] = 1990469526
*(p + 0) : 313959809
*(p + 1) : 1759055877
*(p + 2) : 1113101911
*(p + 3) : 2133832223
*(p + 4) : 2073354073
*(p + 5) : 167288147
*(p + 6) : 1827471542
*(p + 7) : 834791014
*(p + 8) : 1901409888
*(p + 9) : 1990469526</code></code></pre>
<h4 id="指向数组的指针">指向数组的指针</h4>
<p>可以先了解了 C 指针的概念之后，再来学习本章的内容。</p>
<p>数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：</p>
<pre><code><code>double balance[50];</code></code></pre>
<p><strong>balance</strong> 是一个指向 &amp;balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 <strong>p</strong> 赋值为 <strong>balance</strong> 的第一个元素的地址：</p>
<pre><code><code>double *p;
double balance[10];

p = balance;</code></code></pre>
<p>使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。</p>
<p>一旦您把第一个元素的地址存储在 p 中，您就可以使用 <em>p、</em>(p+1)、*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：</p>
<pre><code><code>#include &lt;stdio.h&gt;
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
   int i;
 
   p = balance;
 
   /* 输出数组中每个元素的值 */
   printf( &quot;使用指针的数组值\n&quot;);
   for ( i = 0; i &lt; 5; i++ )
   {
       printf(&quot;*(p + %d) : %f\n&quot;,  i, *(p + i) );
   }
 
   printf( &quot;使用 balance 作为地址的数组值\n&quot;);
   for ( i = 0; i &lt; 5; i++ )
   {
       printf(&quot;*(balance + %d) : %f\n&quot;,  i, *(balance + i) );
   }
 
   return 0;
}</code></code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<blockquote>
<p>使用指针的数组值<br />
<em>(p + 0) : 1000.000000<br />
</em>(p + 1) : 2.000000<br />
<em>(p + 2) : 3.400000<br />
</em>(p + 3) : 17.000000<br />
<em>(p + 4) : 50.000000<br />
使用 balance 作为地址的数组值<br />
</em>(balance + 0) : 1000.000000<br />
<em>(balance + 1) : 2.000000<br />
</em>(balance + 2) : 3.400000<br />
<em>(balance + 3) : 17.000000<br />
</em>(balance + 4) : 50.000000</p>
</blockquote>
<p>在上面的实例中，p 是一个指向 double 型的指针，这意味着它可以存储一个 double 类型的变量。一旦我们有了 p 中的地址，*<strong>p</strong> 将给出存储在 p 中相应地址的值。</p>
<hr />
<p>参考自：<a href="https://www.runoob.com/cprogramming/c-tutorial.html" class="uri">https://www.runoob.com/cprogramming/c-tutorial.html</a></p>


</div></div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>