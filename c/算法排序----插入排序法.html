<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修算法排序----插入排序法' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>算法排序----插入排序法</center></div><div class='banquan'>原文出处:本文由博客园博主yooooooo提供。<br/>
原文连接:https://www.cnblogs.com/linhaostudy/p/11671074.html</div><br>
    <p>接下来我来讲述一下插入排序法。</p>
<p>首先来解释一下插入排序法的原理，它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。</p>
<h2 id="直接插入排序算法分析">直接插入排序算法分析</h2>
<p>根据代码我们来解释一下直接插入排序的核心</p>
<p>例如，我们要对5,3,4,6,2这几个数进行排序</p>
<table>
<thead>
<tr class="header">
<th>a[]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>值</td>
<td>5</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>当这个数组进入函数后，下标首先定义到i = 1，即排序前，首先定义为a[0] = 5即是有序的。</p>
<p>进入循环内，比较a[1] 是否小于 a[0] 发现是小于的，这个时候按理说是要把a[0]这个元素右移动1位。然后将a[1]这个元素插在a[0]的位置上</p>
<p>但是考虑到这样子将覆盖原来的a[1]的值，所以先将a[1]的值拷贝一份给temp，然后将a[0]右移一位，再将temp的值传给a[0] .即</p>
<table>
<thead>
<tr class="header">
<th>a[]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>值</td>
<td>3</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>这时i =2了。此时a[0],a[1]属于有序的序列了，我们此时再次比较a[2]是否小于a[1]（前一位），4&lt;5，满足if条件</p>
<p>temp = a[2] 先拷贝一份，再将a[1] 右移一位，再次比较a[0]是否大于temp ,发现3并没有大于4，由此可见只要i前面有序数存在大于a[i]的值，有序序列就要向后移动，</p>
<p>然后再把a[i] 插在正确的位置。</p>
<table>
<thead>
<tr class="header">
<th>a[]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>值</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>当i = 3时，这个时候6比5大，不满足if条件，也可以发现，前面已经都是有序序列{3,4,5,6}.</p>
<p>最后当i = 4时，发现2 &lt; a[3] 这个时候同理前面操作，先将a[4]拷贝一份给temp ,a[4] = a[3],右移一位</p>
<p>再次比较 ,发现temp &lt; a[2] , a[3] =a[2] ,右移一位</p>
<p>再次比较 ,发现temp &lt; a[1] , a[2] =a[1] ,右移一位</p>
<p>再次比较 ,发现temp &lt; a[0] , a[1] =a[0] ,右移一位</p>
<p>此时就可以把temp 赋值给了a[0] ，这个时候就已经排序完成了。</p>
<table>
<thead>
<tr class="header">
<th>a[]</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>值</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<h2 id="直接插入排序复杂度分析">直接插入排序复杂度分析</h2>
<p>从空间上看，它只需要一个辅助空间temp ，因此我们关键看它的时间复杂度。</p>
<p>当最好的情况下，也就是序列本身就是有序的 ，这个时候我们只有进行每次的if判断(第20行)，比较的次数n-1,移动的次数0，这个时候时间复杂度O(n)</p>
<p><img src="./images/算法排序----插入排序法0.png" alt="image" /></p>
<p>如果排序记录是随机的话，那么根据概率相同的情况原则，平均比较和移动的次数约为(n^2)/4 次，因此我们可以得出直接插入排序法的书剑复杂度为O(n^2) 从这里也可以看出</p>
<p>直接插入排序比冒泡排序和简单选择排序性能要好一点，是一个稳定的排序算法。</p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>