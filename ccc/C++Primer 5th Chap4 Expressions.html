<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++Primer 5th Chap4 Expressions' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++Primer 5th Chap4 Expressions</center></div><div class='banquan'>原文出处:本文由博客园博主Dragonsburg提供。<br/>
原文连接:https://www.cnblogs.com/hfut-freshguy/p/11493981.html</div><br>
    <p>左值和右值：左值：用的是对象的身份（内存中的位置），右值：用的是对象的值（内容）</p>
<p>解引用与递增（递减）运算符连用：</p>
<p>　　*ivec++:取ivec当前值并向后移动一个元素，等价于*(ivec++),本来++的优先级高于*</p>
<p>条件运算符嵌套：(注意在语句两端加上括号，条件运算符优先级极低）</p>
<p>　　A?B:C?D:E等价于A?B:(C?D:E)</p>
<p>位运算符（建议仅将位运算用于无符号类型，避免因符号位问题造成错误）</p>
<p style="text-align: left;">　　用法：</p>
<table style="height: 251px; float: left; width: 553px;" border="0">
<tbody>
<tr>
<td><span style="font-size: 15px;">运算符</span></td>
<td><span style="font-size: 15px;">功能</span></td>
<td><span style="font-size: 15px;">用法</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">~</span></td>
<td><span style="font-size: 15px;">位求反</span></td>
<td><span style="font-size: 15px;">~exp</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">&lt;&lt;</span></td>
<td><span style="font-size: 15px;">左移</span></td>
<td><span style="font-size: 15px;">exp1&lt;&lt;exp2</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">&gt;&gt;</span></td>
<td><span style="font-size: 15px;">右移</span></td>
<td><span style="font-size: 15px;">exp1&gt;&gt;exp2</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">&amp;</span></td>
<td><span style="font-size: 15px;">位与</span></td>
<td><span style="font-size: 15px;">exp1&amp;exp2</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">^</span></td>
<td><span style="font-size: 15px;">位异或</span></td>
<td><span style="font-size: 15px;">exp1^exp2</span></td>
</tr>
<tr>
<td><span style="font-size: 15px;">|</span></td>
<td><span style="font-size: 15px;">位或</span></td>
<td><span style="font-size: 15px;">exp1|exp2</span></td>
</tr>
</tbody>
</table>
<p style="text-align: left;">　　　　　　</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　位运算的结果一旦超出位的范围，超出部分的位将会被舍弃</p>
<p>　　<strong>&lt;&lt;操作符满足左结合律</strong></p>
<p><strong>sizeof运算符</strong>：返回一条表达式或类型名所占的字节数，返回值类型为size_t，满足右结合律</p>
<p>　　sizeof（data.revenue);//获取类对象data的revenue成员对应类型的大小</p>
<p>　　sizeof（arr);//获取数组arr的类型大小，是其所有元素类型大小之和（利用sizeof(arr)/sizeof(*arr)可以获取arr的元素数量</p>
<p><strong>命名的强制类型转换</strong>：cast-name&lt;type&gt;(expression),cast-name有4种：static_cast,dynamic_cast（后续章节再提）,const_cast,reinterpret_cast</p>
<p>　　例如:</p>
<p>　　<strong>static_cast</strong>:</p>
<p>　　　　int j=10;</p>
<p>　　　　double slope=static_cast&lt;double&gt;( j ) / i;(只要不是底层const即可用，适用于将大类型赋给小类型）　　</p>
<p>　　　　void *vp=&amp;d;</p>
<p>　　　　double *dp=static_cast&lt;double*&gt;(vp);</p>
<p>　　<strong>const_cast</strong>:</p>
<p>　　　　const char*pc;</p>
<p>　　　　char *p=const_cast&lt;char*&gt;(pc);(要求对象是底层const，借此可以除掉const属性（多用于重载函数），但是不能改变类型）</p>
<p>　　<strong>reinterpret_cast</strong>:"为运算对象的位模式提供较低层次的重新解释",基本上用不到（极可能引起错误，慎用）</p>
<p>　　实际上强制类型转换是迫不得已的手段，若非必要无需使用</p>
<p>运算符优先级表见p147</p>
<p>　　<img src="C:\Users\acer\Pictures\Saved%20Pictures" alt="" /><img src="./images/C++Primer 5th Chap4 Expressions1.png" alt="" width="955" height="2202" /></p>
<p>　　　　</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>