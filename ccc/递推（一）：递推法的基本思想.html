<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修递推（一）：递推法的基本思想' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>递推（一）：递推法的基本思想</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11022438.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 所谓递推，是指从已知的初始条件出发，依据某种递推关系，逐次推出所要求的各中间结果及最后结果。其中初始条件或是问题本身已经给定，或是通过对问题的分析与化简后确定。</p>
<p>&nbsp; &nbsp; &nbsp; 利用递推算法求问题规模为n的解的基本思想是：当n=1时，解或为已知，或能非常方便地求得；通过采用递推法构造算法的递推性质，能从已求得的规模为1、2、&hellip;、i&minus;1的一系列解，构造出问题规模为i的解。这样，程序可从i=0或i=1出发，重复地由已知至i&minus;1规模的解，通过递推，获得规模为i的解，直至获得规模为n的解。</p>
<p>&nbsp; &nbsp; &nbsp; 可用递推算法求解的问题一般有以下两个特点： （1） 问题可以划分成多个状态； （2） 除初始状态外，其它各个状态都可以用固定的递推关系式来表示。当然，在实际问题中，大多数时候不会直接给出递推关系式，而是需要通过分析各种状态，找出递推关系式。</p>
<p>&nbsp; &nbsp; &nbsp; 利用递推算法解决问题，需要做好以下四个方面的工作：</p>
<p>&nbsp; &nbsp; &nbsp; （1）确定递推变量</p>
<p>&nbsp; &nbsp; &nbsp; 应用递推算法解决问题，要根据问题的具体实际设置递推变量。递推变量可以是简单变量，也可以是一维或多维数组。从直观角度出发，通常采用一维数组。</p>
<p>&nbsp; &nbsp; &nbsp; （2）建立递推关系</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;递推关系是指如何从变量的前一些值推出其下一个值，或从变量的后一些值推出其上一个值的公式（或关系）。递推关系是递推的依据，是解决递推问题的关键。有些问题，其递推关系是明确的，大多数实际问题并没有现成的明确的递推关系，需根据问题的具体实际，通过分析和推理，才能确定问题的递推关系。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（3）确定初始（边界）条件</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对所确定的递推变量，要根据问题最简单情形的数据确定递推变量的初始（边界）值，这是递推的基础。</p>
<p>&nbsp; &nbsp; &nbsp; （4）对递推过程进行控制</p>
<p>&nbsp; &nbsp; &nbsp; 递推过程不能无休止地重复执行下去。递推过程在什么时候结束，满足什么条件结束，这是编写递推算法必须考虑的问题。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;递推过程的控制通常可分为两种情形：一种是所需的递推次数是确定的值，可以计算出来；另一种是所需的递推次数无法确定。对于前一种情况，可以构建一个固定次数的循环来实现对递推过程的控制；对于后一种情况，需要进一步分析出用来结束递推过程的条件。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;递推通常由循环来实现，一般在循环外确定初始（边界）条件，在循环中实施递推。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;递推法从递推方向可分为顺推与倒推。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;所谓顺推法是从已知条件出发，通过递推关系逐步推算出要解决的问题的结果的方法。如求斐波拉契数列的第20项的值，设斐波拉契数列的第n项的为f(n)，已知f(1)=1，f(2)=1；通过递推关系式f(n)=f(n-2)+f(n-1) （n&gt;=3，n&isin;N），可以顺推出f(3)=f(1)+f(2)=2、f(4)=f(2)+f(3)=3、&hellip;直至要求的解f(20)=f(18)+f(19)=6765。</p>
<p>&nbsp; &nbsp; &nbsp; 所谓倒推法，就是在不知初始值的情况下，经某种递推关系而获知了问题的解或目标，从这个解或目标出发，采用倒推手段，一步步地倒推到这个问题的初始情况。</p>
<p>&nbsp; &nbsp; &nbsp; 一句话概括：顺推是从条件推出结果，倒推从结果推出条件。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;顺推法是从前往后推，从已求得的规模为1、2、&hellip;、i&minus;1的一系列解，推出问题规模为i的解，直至得到规模为n的解。顺推算法可描述为：</p>
<p style="margin-left: 30px;">for (k=1; k&lt;=i&minus;1; k++)</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp;f[k]= &lt;初始值&gt;；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 按初始条件，确定初始值</p>
<p style="margin-left: 30px;">for (k=i; k&lt;=n; k++)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; f[k]= &lt;递推关系式&gt;；&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 根据递推关系实施递推</p>
<p style="margin-left: 30px;">cout&lt;&lt;f[n]；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 输出n规模的解f(n)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;倒推法是从后往前推，从已求得的规模为n、n&minus;1、&hellip;、i+1的一系列解，推出问题规模为i的解，直至得到规模为1的解（即初始情况）。倒推算法可描述为：</p>
<p style="margin-left: 30px;">for (k=n; k&gt;=i+1; k--)</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp;f[k]= &lt;初始值&gt;；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 按初始条件，确定初始值</p>
<p style="margin-left: 30px;">for (k=i; k&gt;=1; k--)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; f[k]= &lt;递推关系式&gt;；&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; // 根据递推关系实施递推</p>
<p style="margin-left: 30px;">cout&lt;&lt;f[1]；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // 输出问题的初始情况f(1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;递推问题一般定义一维数组来保存各项推算结果，较复杂的递推问题还需定义二维数组。例如，当规模为i的解为规模为1、2、&hellip;、i&minus;1的解通过计算处理决定时，可利用二重循环处理这一较为复杂的递推。</p>
<p>【例1】RPG涂色问题</p>
<p>&nbsp; &nbsp; &nbsp; 有排成一行的n个方格，用红（Red）、粉（Pink）、绿（Green）三种颜色涂每个格子，每个格子涂一种色，要求任何相邻的方格不能同色，且首尾两格也不同色。</p>
<p>&nbsp; &nbsp; &nbsp; 编写一个程序，输入方格数n（0&lt;n&lt;=30），输出满足要求的全部涂法的种数。</p>
<p>&nbsp; &nbsp; &nbsp; （1） 编程思路</p>
<p>&nbsp; &nbsp; &nbsp; 设满足要求的n个方格的涂色方法数为F(n)。</p>
<p>&nbsp; &nbsp; &nbsp; 因为RPG有三种颜色，可以先枚举出当方格数为1、2、3时的涂法种数。</p>
<p>&nbsp; &nbsp; &nbsp; 显然，&nbsp; &nbsp; &nbsp;F(1)=3 &nbsp;&nbsp;（即R、P、G三种）</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(2)=6&nbsp; &nbsp;（即RP、RG、PR、PG、GR、GP六种）</p>
<p style="margin-left: 60px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F(3)=6&nbsp;&nbsp; （即RPG、RGP、PRG、PGR、GRP、GPR六种）</p>
<p>&nbsp; &nbsp; &nbsp; 当方格的个数大于3时，n个方格的涂色方案可以由n-1方格的涂色方案追加最后一个方格的涂色方案得出，分两种情况：</p>
<p>&nbsp; &nbsp; &nbsp; 1）对于已按要求涂好颜色的n-1个方格，在F(n-1)种合法的涂色方案后追加一个方格（第n个方格），由于合法方案的首尾颜色不同（即第n-1个方格的颜色不与第1个方格的相同），这样，第n个方格的颜色也是确定的，它必定是原n-1个方格的首尾两种颜色之外的一种，因此，在这种情况下的涂色方法数为F(n-1)。</p>
<p>&nbsp; &nbsp; &nbsp; 2）对于已按要求涂好颜色的n-2个方格，可以在第n-1个方格中涂与第1个方格相同的颜色，此时由于首尾颜色相同，这是不合法的涂色方案，但可以在第n个方格中涂上一个合法的颜色，使其成为方格长度为n的合法涂色方案（注意：当n等于3时，由于第1(3-2)个方格与第2(3-1)个方格颜色相同，第3个方格不论怎样涂都不会合法，因此递推的前提是n大于3），在第n个方格中可以涂上两种颜色（即首格外的两种颜色，因为与它相连的第n-1个方格和第1个方格的颜色是一样的），因此，在这种情况下的涂色方法数为2*F(n-2)。</p>
<p style="margin-left: 30px;">由此，可得递推公式：F(n)= F(n-1) + 2*F(n-2)&nbsp; (n&gt;=4)</p>
<p style="margin-left: 30px;">程序中定义3个变量f1、f2和f3分别表示F (n-2)、F(n-1)和F(n)，初始时f1=6、f2=6。</p>
<p style="margin-left: 30px;">当n&lt;4时，根据初始情况直接输出结果。</p>
<p style="margin-left: 30px;">当n&gt;=4时，用循环递推计算F(n)。程序段描述为：</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; for(i=4;i&lt;=n;i++)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f3=f1+f2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 计算当前F(i)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f1=f2;&nbsp;&nbsp; f2=f3;&nbsp;&nbsp;&nbsp; // 为下一次递推做准备</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序及运行结果</p>
<p style="margin-left: 30px;">#include &lt;iostream&gt;</p>
<p style="margin-left: 30px;">using namespace std;</p>
<p style="margin-left: 30px;">int main()</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; int i,n,f1,f2,f3,num;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cout&lt;&lt;"请输入方格的数目 n （0&lt;n&lt;=30）:";</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cin&gt;&gt;n;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; if (n==1)&nbsp; num=3;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; else if (n==2 || n==3)&nbsp; num=6;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; else</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; {</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; f1=6;&nbsp; f2=6;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=4;i&lt;=n;i++)&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; {</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f3=2*f1+f2;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 递推求F(i)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;f1=f2;&nbsp; f2=f3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 为下次递推做准备</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; }</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; num=f3;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; }</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cout&lt;&lt;n&lt;&lt;"个方格的正确涂色方案一共有"&lt;&lt;num&lt;&lt;"种。"&lt;&lt;endl;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 30px;">}</p>
<p>&nbsp; &nbsp; &nbsp; 为更清晰地描述递推过程并保存中间结果，可以定义一个一维数组f[31]，数组元素f[i]保存总数为i个方格的涂色方法数。初始值： f[1]=3、f[2]=6、f[3]=6。源程序清单如下。</p>
<p style="margin-left: 30px;">#include &lt;iostream&gt;</p>
<p style="margin-left: 30px;">using namespace std;</p>
<p style="margin-left: 30px;">int main()</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; int i,n,f[31];</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; f[0]=0;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; f[1]=3;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; f[2]=6;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; f[3]=6;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; for(i=4;i&lt;31;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; f[i]=f[i-1]+2*f[i-2];&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cout&lt;&lt;"请输入方格的数目 n （n&lt;=30）:";</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cin&gt;&gt;n;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; cout&lt;&lt;n&lt;&lt;"个方格的正确涂色方案一共有"&lt;&lt;f[n]&lt;&lt;"种。"&lt;&lt;endl;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp; return 0;</p>
<p style="margin-left: 30px;">}</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>