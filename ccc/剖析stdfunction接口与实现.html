<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修剖析stdfunction接口与实现' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>剖析stdfunction接口与实现</center></div><div class='banquan'>原文出处:本文由博客园博主jerry_fuyi提供。<br/>
原文连接:https://www.cnblogs.com/jerry-fuyi/p/std_function_interface_implementation.html</div><br>
    <h3><span style="font-size: 20px;">目录</span></h3>
<p><a href="#mark_preface">前言</a></p>
<p><a href="#mark_1">一、<span style="font-family: 'courier new', courier;">std::function</span>的原理与接口</a></p>
<p>　　<a href="#mark_1_1">1.1 <span style="font-family: 'courier new', courier;">std::function</span>是函数包装器</a></p>
<p>　　<a href="#mark_1_2">1.2 C++注重运行时效率</a></p>
<p>　　<a href="#mark_1_3">1.3 用函数指针实现多态</a></p>
<p>　　<a href="#mark_1_4">1.4 <span style="font-family: 'courier new', courier;">std::function</span>的接口</a></p>
<p><a href="#mark_2">二、<span style="font-family: 'courier new', courier;">std::function</span>的实现</a></p>
<p style="margin-left: 30px;"><a href="#mark_2_1">2.1 类型系统</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_1">2.1.1 异常类</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_2">2.1.2 数据存储</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_3">2.1.3 辅助类</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_4">2.1.4 内存管理基类</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_5">2.1.5 仿函数调用</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_6">2.1.6 接口定义</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_1_7">2.1.7 类型关系</a></p>
<p style="margin-left: 30px;"><a href="#mark_2_2">2.2 方法的功能与实现</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_1">2.2.1 多态性的体现</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_2">2.2.2 本地函数对象</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_3">2.2.3 heap函数对象</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_4">2.2.4 两种存储结构如何统一</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_5">2.2.5 根据形式区分仿函数类型</a></p>
<p style="margin-left: 60px;"><a href="#mark_2_2_6">2.2.6 实现组装成接口</a></p>
<p><a href="#mark_epilogue">后记</a></p>
<p><a href="#mark_appendix">附录</a></p>
<p>&nbsp;</p>
<h3><a name="mark_preface"></a><span style="font-size: 20px;">前言</span></h3>
<p>为什么要剖析&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;呢？因为笔者最近在做一个&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;向单片机系统的移植与扩展。</p>
<p>后续还会有&nbsp;<span class="cnblogs_code">std::bind</span>&nbsp;等标准库其他部分的移植。</p>
<p>&nbsp;</p>
<h3><span style="font-size: 20px;"><a name="mark_1"></a>一、<span style="font-family: 'courier new', courier;">std::function</span>的原理与接口</span></h3>
<h3><a name="mark_1_1"></a>1.1&nbsp;<span style="font-family: 'courier new', courier;">std::function</span>是函数包装器</h3>
<p><span class="cnblogs_code">std::function</span>&nbsp;，能存储任何符合模板参数的函数对象。换句话说，这些拥有一致参数类型、相同返回值类型（其实不必完全相同）的函数对象，可以由&nbsp;<span class="cnblogs_code">std::function</span> 统一包装起来。函数对象的大小是任意的、不能确定的，而C++中的类型都是固定大小的，那么，如何在一个固定大小的类型中存储任意大小的对象呢？</p>
<p>实际上问题还不止存储那么简单。存储了函数对象，必定是要在某一时刻调用；函数对象不是在创建的时候调用，这个特性成为延迟调用；函数对象也是对象，需要处理好构造、拷贝、移动、析构等问题&mdash;&mdash;这些也需要延迟调用，但总不能再用&nbsp;<span class="cnblogs_code">std::function</span> 来解决吧？</p>
<p>既然&nbsp;<span class="cnblogs_code">std::function</span> 能存储不同类型的函数对象，可以说它具有多态性。C++中体现多态性的主要是虚函数，继承与多态这一套体制是可以解决这个问题的。<a title="Naive std::function implementation" href="https://shaharmike.com/cpp/naive-std-function/" target="_blank">相关资料[1]</a>&nbsp;<a title="How is std::function implemented?" href="https://stackoverflow.com/questions/18453145/how-is-stdfunction-implemented" target="_blank">[2]</a>中的实现利用了继承与多态，相当简洁。</p>
<p>&nbsp;</p>
<h3><a name="mark_1_2"></a>1.2 C++注重运行时效率</h3>
<p>利用继承与多态，我们可以让编译器帮我们搞定函数对象的析构。就这种实现而言，这是简洁而有效的方法。然而这种实现需要动态内存，在一些情况下不划算，甚至完全没有必要。C++11引入了lambda表达式，其本质也是函数对象。这个对象有多大呢？取决于捕获列表。你写lambda会捕获多少东西？很多情况下就只是一对方括号而已吧。在这种情况下，lambda表达式的对象大小只有1字节（因为不能是0字节），你却为了这没有内容的1字节要调用动态内存的函数？C++注重运行时效率，这种浪费是不能接受的。</p>
<p>如何避免这种浪费呢？你也许会说我检查传入的对象是不是1字节的空类型。且不论这个trait怎么实现，函数指针、捕获一个int的lambda等类型都声称自己是trivial的小对象，也不应该分配到heap中去。</p>
<p>之前说过，<span class="cnblogs_code">std::function</span> 的大小是固定的，但是这个大小是可以自己定的。我们可以在&nbsp;<span class="cnblogs_code">std::function</span> 的类定义中加入一个空白的、大小适中的field，用在存放这些小对象，从而避免这些情况下的动态内存操作。同时，既然有了这片空间，也就不需要看传入的对象是不是1字节的空类型了。</p>
<p>而对于更大的类型，虽然这个field不足以存放函数对象，但足以存放一个指针，这种分时复用的结构可以用union来实现。这种小对象直接存储、大对象在heap上开辟空间并存储指针的方法，称为small object optimization。</p>
<p>在利用继承的实现中，函数对象被包装在一个子类中，<span class="cnblogs_code">std::function</span> 中持有一个其父类的指针。然而为了效率，我们需要把空白field和这个指针union起来。union总给人一种底层的感觉，在不确定这个union到底存储的是什么的时候，当然不能通过其中的指针去调用虚函数。在这样的设计中，多态性不再能用继承体系实现了，我们需要另一种实现多态的方法。</p>
<p>&nbsp;</p>
<h3><a name="mark_1_3"></a>1.3 用函数指针实现多态</h3>
<p>回想一下虚函数是如何实现的？带有virtual function的类的对象中会安插vptr，这个指针指向一个vtable，这个vtable含有多个slot，里面含有指向type_info对象的指针与函数指针&mdash;&mdash;对，我们需要函数指针！不知你有没有在C中实现过多态，在没有语言特性的帮助下，比较方便的方法是在struct中直接放函数指针。如果要像C++那样用上vptr和vtable，你得管理好每个类及其对应vtable的内容。你以为这种情况在C++中就有所好转吗？只有你用C++的继承体系，编译器才会帮你做这些事。想要自己建立一个从类型到vptr的映射，恐怕你得改编译器了。</p>
<p>vptr与vtable的意义是什么？其一，每个基类只对应一个vptr，大小固定，多重继承下便于管理，但这点与这篇文章的主题没有关联；其二，当基类有多个虚函数的时候，使用vptr可以节省存储对象的空间，而如果用函数指针的话，虽然少了一次寻址，但继承带来的空间overhead取决于虚函数的数量，由于至少一个，函数指针的占用的空间不会少于vptr，在虚函数数量较多的情况下，函数指针就要占用比较大的空间了。</p>
<p>既然我们已经无法在&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;中使用vptr，我们也应该尽可能减少函数指针的数量，而这又取决于这些函数的功能，进一步取决于&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;类的接口。</p>
<p>&nbsp;</p>
<h3><a name="mark_1_4"></a>1.4&nbsp;<span style="font-family: 'courier new', courier;">std::function</span>的接口</h3>
<p>虽然C++标准<span>规定了&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的</span>接口就应该是<a title="std::function - cppreference.com" href="https://en.cppreference.com/w/cpp/utility/functional/function" target="_blank">这样</a>，我还是想说说它为什么应该是这样。关于其他的一些问题，比如保存值还是保存引用等，可以参考<a title="The space of design choices for std::function" href="https://quuxplusone.github.io/blog/2019/03/27/design-space-for-std-function/" target="_blank">相关资料[4]</a>。</p>
<p>最基本的，<span class="cnblogs_code">std::function</span>&nbsp;是一个模板类，模板参数是一个类型（注意是一个类型，不是好几个类型）。我们可以这么写：</p>
<div class="cnblogs_code">
<pre>std::function&lt;<span style="color: #0000ff;">int</span>(<span style="color: #0000ff;">double</span>)&gt; f;</pre>
</div>
<p><span class="cnblogs_code">f</span>&nbsp;是一个可调用对象，参数为 <span class="cnblogs_code" style="color: #0000ff;">double</span>，返回值为&nbsp;<span class="cnblogs_code" style="color: #0000ff;">int</span>&nbsp;。你也许会问，这里既规定了参数类型又规定了返回值类型，怎么就成了一个类型呢？确实是一个类型，<span class="cnblogs_code"><span style="color: #0000ff;">int</span>(<span style="color: #0000ff;">double</span>)</span>&nbsp;是一个函数类型（注意不是函数指针）。</p>
<p><span class="cnblogs_code">std::function</span>&nbsp;要包装所有合适类型的对象，就必须有对应的构造函数，所以这是个模板构造函数。参数不是通用引用而是直接<a title="How true is &ldquo;Want Speed? Pass by value&rdquo;" href="https://stackoverflow.com/questions/21605579/how-true-is-want-speed-pass-by-value" target="_blank">传值</a>：</p>
<div class="cnblogs_code">
<pre>template &lt;<span style="color: #0000ff;">typename</span> F&gt;<span style="color: #000000;">
function(F);</span></pre>
</div>
<p>可能是为了让编译器对空对象进行优化。同样还有一个模板赋值函数，参数是通用引用。</p>
<p>每个构造函数都有一个添加了&nbsp;<span class="cnblogs_code">std::allocator_arg_t</span>&nbsp;作为第一个参数、内存分配器对象作为第二个参数的版本，C++17中已经移除（GCC从未提供，可能是因为&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的内存分配无法自定义）。同样删除的还有&nbsp;<span class="cnblogs_code">assign</span>&nbsp;，也是与内存分配器相关的。</p>
<p>另外有一个以&nbsp;<span class="cnblogs_code">std::reference_wrapper</span>&nbsp;作为参数的赋值函数：</p>
<div class="cnblogs_code">
<pre>template &lt;<span style="color: #0000ff;">typename</span> F&gt;<span style="color: #000000;">
function</span>&amp; <span style="color: #0000ff;">operator</span>=(std::reference_wrapper&lt;F&gt;) <span style="color: #0000ff;">noexcept</span>;</pre>
</div>
<p>可以理解为模板赋值函数的特化。没有相应的构造函数。</p>
<p>默认构造函数、<span class="cnblogs_code" style="color: #0000ff;">nullptr_t</span>&nbsp;构造函数、<span class="cnblogs_code" style="color: #0000ff;">nullptr_t</span>&nbsp;拷贝赋值函数都将&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象置空。当&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象没有保存任何函数对象时，&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">operator</span> <span style="color: #0000ff;">bool</span>()</span>&nbsp;返回&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">false</span></span>&nbsp;，与&nbsp;<span class="cnblogs_code" style="color: #0000ff;">nullptr_t</span>&nbsp;调用&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">operator</span>==</span>&nbsp;会返回&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">true</span></span>&nbsp;，如果调用将抛出&nbsp;<span class="cnblogs_code">std::bad_function_call</span>&nbsp;异常。</p>
<p>虽然&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;将函数对象包装了起来，但用户还是可以获得原始对象的。<span class="cnblogs_code">target_type()</span>&nbsp;返回函数对象的&nbsp;<span class="cnblogs_code" style="color: #0000ff;">typeid</span>&nbsp;，<span class="cnblogs_code">target()</span>&nbsp;模板函数当模板参数与函数对象类型相同时返回其指针，否则返回空指针。</p>
<p>作为函数包装器，<span class="cnblogs_code">std::function</span>&nbsp;也是函数对象，可以通过&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">operator</span>()</span>&nbsp;调用，参数按照模板参数中声明的类型传递。</p>
<p>还有一些接口与大部分STL设施相似，有Rule of Five规定的5个方法、&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;，以及&nbsp;<span class="cnblogs_code">std::swap()</span>&nbsp;的特化等。可别小看这个&nbsp;<span class="cnblogs_code">swap()</span> ，它有大用处。</p>
<p>总之，函数对象的复制、移动、赋值、交换等操作都是需要的。对客户来说，除了两个&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的相等性判定（笔者最近在尝试实现这个）以外，其他能想到的方法它都有。</p>
<p>&nbsp;</p>
<h3><span style="font-size: 20px;"><a name="mark_2"></a>二、<span style="font-family: 'courier new', courier;">std::function</span>的实现</span></h3>
<p><span class="cnblogs_code">std::function</span>&nbsp;的实现位于&nbsp;<span class="cnblogs_code">&lt;functional&gt;</span>&nbsp;，后续版本迁移至了&nbsp;<span class="cnblogs_code">&lt;bits/std_function.h&gt;</span>&nbsp;。下面这段代码是GCC 4.8.1（第一个支持完整C++11的版本）中的&nbsp;<span class="cnblogs_code">&lt;functional&gt;</span>&nbsp;头文件，共2579行，默认折叠，慎入。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('4396106c-caf2-444c-ae3a-acfd11fdb239')"><img id="code_img_closed_4396106c-caf2-444c-ae3a-acfd11fdb239" class="code_img_closed" src="./images/剖析stdfunction接口与实现0.png" alt="" /><img id="code_img_opened_4396106c-caf2-444c-ae3a-acfd11fdb239" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('4396106c-caf2-444c-ae3a-acfd11fdb239',event)" src="./images/剖析stdfunction接口与实现1.png" alt="" />
<div id="cnblogs_code_open_4396106c-caf2-444c-ae3a-acfd11fdb239" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;">   1</span> <span style="color: #008000;">//</span><span style="color: #008000;"> &lt;functional&gt; -*- C++ -*-
</span><span style="color: #008080;">   2</span> 
<span style="color: #008080;">   3</span> <span style="color: #008000;">//</span><span style="color: #008000;"> Copyright (C) 2001-2013 Free Software Foundation, Inc.
</span><span style="color: #008080;">   4</span> <span style="color: #008000;">//</span>
<span style="color: #008080;">   5</span> <span style="color: #008000;">//</span><span style="color: #008000;"> This file is part of the GNU ISO C++ Library.  This library is free
</span><span style="color: #008080;">   6</span> <span style="color: #008000;">//</span><span style="color: #008000;"> software; you can redistribute it and/or modify it under the
</span><span style="color: #008080;">   7</span> <span style="color: #008000;">//</span><span style="color: #008000;"> terms of the GNU General Public License as published by the
</span><span style="color: #008080;">   8</span> <span style="color: #008000;">//</span><span style="color: #008000;"> Free Software Foundation; either version 3, or (at your option)
</span><span style="color: #008080;">   9</span> <span style="color: #008000;">//</span><span style="color: #008000;"> any later version.
</span><span style="color: #008080;">  10</span> 
<span style="color: #008080;">  11</span> <span style="color: #008000;">//</span><span style="color: #008000;"> This library is distributed in the hope that it will be useful,
</span><span style="color: #008080;">  12</span> <span style="color: #008000;">//</span><span style="color: #008000;"> but WITHOUT ANY WARRANTY; without even the implied warranty of
</span><span style="color: #008080;">  13</span> <span style="color: #008000;">//</span><span style="color: #008000;"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
</span><span style="color: #008080;">  14</span> <span style="color: #008000;">//</span><span style="color: #008000;"> GNU General Public License for more details.
</span><span style="color: #008080;">  15</span> 
<span style="color: #008080;">  16</span> <span style="color: #008000;">//</span><span style="color: #008000;"> Under Section 7 of GPL version 3, you are granted additional
</span><span style="color: #008080;">  17</span> <span style="color: #008000;">//</span><span style="color: #008000;"> permissions described in the GCC Runtime Library Exception, version
</span><span style="color: #008080;">  18</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 3.1, as published by the Free Software Foundation.
</span><span style="color: #008080;">  19</span> 
<span style="color: #008080;">  20</span> <span style="color: #008000;">//</span><span style="color: #008000;"> You should have received a copy of the GNU General Public License and
</span><span style="color: #008080;">  21</span> <span style="color: #008000;">//</span><span style="color: #008000;"> a copy of the GCC Runtime Library Exception along with this program;
</span><span style="color: #008080;">  22</span> <span style="color: #008000;">//</span><span style="color: #008000;"> see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
</span><span style="color: #008080;">  23</span> <span style="color: #008000;">//</span><span style="color: #008000;"> &lt;</span><span style="color: #008000; text-decoration: underline;">http://www.gnu.org/licenses/</span><span style="color: #008000;">&gt;.</span>
<span style="color: #008080;">  24</span> 
<span style="color: #008080;">  25</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;">  26</span> <span style="color: #008000;"> * Copyright (c) 1997
</span><span style="color: #008080;">  27</span> <span style="color: #008000;"> * Silicon Graphics Computer Systems, Inc.
</span><span style="color: #008080;">  28</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">  29</span> <span style="color: #008000;"> * Permission to use, copy, modify, distribute and sell this software
</span><span style="color: #008080;">  30</span> <span style="color: #008000;"> * and its documentation for any purpose is hereby granted without fee,
</span><span style="color: #008080;">  31</span> <span style="color: #008000;"> * provided that the above copyright notice appear in all copies and
</span><span style="color: #008080;">  32</span> <span style="color: #008000;"> * that both that copyright notice and this permission notice appear
</span><span style="color: #008080;">  33</span> <span style="color: #008000;"> * in supporting documentation.  Silicon Graphics makes no
</span><span style="color: #008080;">  34</span> <span style="color: #008000;"> * representations about the suitability of this software for any
</span><span style="color: #008080;">  35</span> <span style="color: #008000;"> * purpose.  It is provided "as is" without express or implied warranty.
</span><span style="color: #008080;">  36</span> <span style="color: #008000;"> *
</span><span style="color: #008080;">  37</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">  38</span> 
<span style="color: #008080;">  39</span> <span style="color: #008000;">/*</span><span style="color: #008000;">* @file include/functional
</span><span style="color: #008080;">  40</span> <span style="color: #008000;"> *  This is a Standard C++ Library header.
</span><span style="color: #008080;">  41</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;">  42</span> 
<span style="color: #008080;">  43</span> <span style="color: #000000;">#ifndef _GLIBCXX_FUNCTIONAL
</span><span style="color: #008080;">  44</span> <span style="color: #0000ff;">#define</span> _GLIBCXX_FUNCTIONAL 1
<span style="color: #008080;">  45</span> 
<span style="color: #008080;">  46</span> <span style="color: #0000ff;">#pragma</span> GCC system_header
<span style="color: #008080;">  47</span> 
<span style="color: #008080;">  48</span> #include &lt;bits/c++config.h&gt;
<span style="color: #008080;">  49</span> #include &lt;bits/stl_function.h&gt;
<span style="color: #008080;">  50</span> 
<span style="color: #008080;">  51</span> <span style="color: #0000ff;">#if</span> __cplusplus &gt;= 201103L
<span style="color: #008080;">  52</span> 
<span style="color: #008080;">  53</span> #include &lt;typeinfo&gt;
<span style="color: #008080;">  54</span> #include &lt;<span style="color: #0000ff;">new</span>&gt;
<span style="color: #008080;">  55</span> #include &lt;tuple&gt;
<span style="color: #008080;">  56</span> #include &lt;type_traits&gt;
<span style="color: #008080;">  57</span> #include &lt;bits/functexcept.h&gt;
<span style="color: #008080;">  58</span> #include &lt;bits/functional_hash.h&gt;
<span style="color: #008080;">  59</span> 
<span style="color: #008080;">  60</span> <span style="color: #0000ff;">namespace</span> std _GLIBCXX_VISIBILITY(<span style="color: #0000ff;">default</span><span style="color: #000000;">)
</span><span style="color: #008080;">  61</span> <span style="color: #000000;">{
</span><span style="color: #008080;">  62</span> <span style="color: #000000;">_GLIBCXX_BEGIN_NAMESPACE_VERSION
</span><span style="color: #008080;">  63</span> 
<span style="color: #008080;">  64</span>   template&lt;typename _MemberPointer&gt;
<span style="color: #008080;">  65</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Mem_fn;
</span><span style="color: #008080;">  66</span>   template&lt;typename _Tp, typename _Class&gt;
<span style="color: #008080;">  67</span>     _Mem_fn&lt;_Tp _Class::*&gt;
<span style="color: #008080;">  68</span>     mem_fn(_Tp _Class::*<span style="color: #000000;">) noexcept;
</span><span style="color: #008080;">  69</span> 
<span style="color: #008080;">  70</span> <span style="color: #000000;">_GLIBCXX_HAS_NESTED_TYPE(result_type)
</span><span style="color: #008080;">  71</span> 
<span style="color: #008080;">  72</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> If we have found a result_type, extract it.</span>
<span style="color: #008080;">  73</span>   template&lt;<span style="color: #0000ff;">bool</span> _Has_result_type, typename _Functor&gt;
<span style="color: #008080;">  74</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Maybe_get_result_type
</span><span style="color: #008080;">  75</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">  76</span> 
<span style="color: #008080;">  77</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">  78</span>     <span style="color: #0000ff;">struct</span> _Maybe_get_result_type&lt;<span style="color: #0000ff;">true</span>, _Functor&gt;
<span style="color: #008080;">  79</span> <span style="color: #000000;">    { typedef typename _Functor::result_type result_type; };
</span><span style="color: #008080;">  80</span> 
<span style="color: #008080;">  81</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">  82</span> <span style="color: #008000;">   *  Base class for any function object that has a weak result type, as
</span><span style="color: #008080;">  83</span> <span style="color: #008000;">   *  defined in 3.3/3 of TR1.
</span><span style="color: #008080;">  84</span>   <span style="color: #008000;">*/</span>
<span style="color: #008080;">  85</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">  86</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Weak_result_type_impl
</span><span style="color: #008080;">  87</span>     : _Maybe_get_result_type&lt;__has_result_type&lt;_Functor&gt;::value, _Functor&gt;
<span style="color: #008080;">  88</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">  89</span> 
<span style="color: #008080;">  90</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve the result type for a function type.</span>
<span style="color: #008080;">  91</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">  92</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes...)&gt;
<span style="color: #008080;">  93</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;">  94</span> 
<span style="color: #008080;">  95</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">  96</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes......)&gt;
<span style="color: #008080;">  97</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;">  98</span> 
<span style="color: #008080;">  99</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 100</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes...) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 101</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 102</span> 
<span style="color: #008080;"> 103</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 104</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes......) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 105</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 106</span> 
<span style="color: #008080;"> 107</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 108</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes...) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 109</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 110</span> 
<span style="color: #008080;"> 111</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 112</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes......) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 113</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 114</span> 
<span style="color: #008080;"> 115</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 116</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes...) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 117</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 118</span> 
<span style="color: #008080;"> 119</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 120</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(_ArgTypes......) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 121</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 122</span> 
<span style="color: #008080;"> 123</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve the result type for a function reference.</span>
<span style="color: #008080;"> 124</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 125</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(&amp;)(_ArgTypes...)&gt;
<span style="color: #008080;"> 126</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 127</span> 
<span style="color: #008080;"> 128</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 129</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(&amp;)(_ArgTypes......)&gt;
<span style="color: #008080;"> 130</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 131</span> 
<span style="color: #008080;"> 132</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve the result type for a function pointer.</span>
<span style="color: #008080;"> 133</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 134</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(*)(_ArgTypes...)&gt;
<span style="color: #008080;"> 135</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 136</span> 
<span style="color: #008080;"> 137</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 138</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res(*)(_ArgTypes......)&gt;
<span style="color: #008080;"> 139</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 140</span> 
<span style="color: #008080;"> 141</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve result type for a member function pointer.</span>
<span style="color: #008080;"> 142</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 143</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes...)&gt;
<span style="color: #008080;"> 144</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 145</span> 
<span style="color: #008080;"> 146</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 147</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes......)&gt;
<span style="color: #008080;"> 148</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 149</span> 
<span style="color: #008080;"> 150</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve result type for a const member function pointer.</span>
<span style="color: #008080;"> 151</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 152</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes...) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 153</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 154</span> 
<span style="color: #008080;"> 155</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 156</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes......) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 157</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 158</span> 
<span style="color: #008080;"> 159</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve result type for a volatile member function pointer.</span>
<span style="color: #008080;"> 160</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 161</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes...) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 162</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 163</span> 
<span style="color: #008080;"> 164</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 165</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*)(_ArgTypes......) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 166</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 167</span> 
<span style="color: #008080;"> 168</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Retrieve result type for a const volatile member function pointer.</span>
<span style="color: #008080;"> 169</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 170</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*<span style="color: #000000;">)(_ArgTypes...)
</span><span style="color: #008080;"> 171</span>                                   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 172</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 173</span> 
<span style="color: #008080;"> 174</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 175</span>     <span style="color: #0000ff;">struct</span> _Weak_result_type_impl&lt;_Res (_Class::*<span style="color: #000000;">)(_ArgTypes......)
</span><span style="color: #008080;"> 176</span>                                   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 177</span> <span style="color: #000000;">    { typedef _Res result_type; };
</span><span style="color: #008080;"> 178</span> 
<span style="color: #008080;"> 179</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 180</span> <span style="color: #008000;">   *  Strip top-level cv-qualifiers from the function object and let
</span><span style="color: #008080;"> 181</span> <span style="color: #008000;">   *  _Weak_result_type_impl perform the real work.
</span><span style="color: #008080;"> 182</span>   <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 183</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;"> 184</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Weak_result_type
</span><span style="color: #008080;"> 185</span>     : _Weak_result_type_impl&lt;typename remove_cv&lt;_Functor&gt;::type&gt;
<span style="color: #008080;"> 186</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 187</span> 
<span style="color: #008080;"> 188</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Determines if the type _Tp derives from unary_function.</span>
<span style="color: #008080;"> 189</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 190</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Derives_from_unary_function : __sfinae_types
</span><span style="color: #008080;"> 191</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 192</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 193</span>       template&lt;typename _T1, typename _Res&gt;
<span style="color: #008080;"> 194</span>         <span style="color: #0000ff;">static</span> __one __test(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> unary_function&lt;_T1, _Res&gt;*<span style="color: #000000;">);
</span><span style="color: #008080;"> 195</span> 
<span style="color: #008080;"> 196</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> It's tempting to change "..." to const volatile void*, but
</span><span style="color: #008080;"> 197</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> that fails when _Tp is a function type.</span>
<span style="color: #008080;"> 198</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> __two __test(...);
</span><span style="color: #008080;"> 199</span> 
<span style="color: #008080;"> 200</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 201</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> value = <span style="color: #0000ff;">sizeof</span>(__test((_Tp*)<span style="color: #800080;">0</span>)) == <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 202</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 203</span> 
<span style="color: #008080;"> 204</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Determines if the type _Tp derives from binary_function.</span>
<span style="color: #008080;"> 205</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 206</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Derives_from_binary_function : __sfinae_types
</span><span style="color: #008080;"> 207</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 208</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 209</span>       template&lt;typename _T1, typename _T2, typename _Res&gt;
<span style="color: #008080;"> 210</span>         <span style="color: #0000ff;">static</span> __one __test(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> binary_function&lt;_T1, _T2, _Res&gt;*<span style="color: #000000;">);
</span><span style="color: #008080;"> 211</span> 
<span style="color: #008080;"> 212</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> It's tempting to change "..." to const volatile void*, but
</span><span style="color: #008080;"> 213</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> that fails when _Tp is a function type.</span>
<span style="color: #008080;"> 214</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> __two __test(...);
</span><span style="color: #008080;"> 215</span> 
<span style="color: #008080;"> 216</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 217</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> value = <span style="color: #0000ff;">sizeof</span>(__test((_Tp*)<span style="color: #800080;">0</span>)) == <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 218</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 219</span> 
<span style="color: #008080;"> 220</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 221</span> <span style="color: #008000;">   * Invoke a function object, which may be either a member pointer or a
</span><span style="color: #008080;"> 222</span> <span style="color: #008000;">   * function object. The first parameter will tell which.
</span><span style="color: #008080;"> 223</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 224</span>   template&lt;typename _Functor, typename... _Args&gt;
<span style="color: #008080;"> 225</span> <span style="color: #000000;">    inline
</span><span style="color: #008080;"> 226</span>     typename enable_if&lt;
<span style="color: #008080;"> 227</span>              (!is_member_pointer&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 228</span>               &amp;&amp; !is_function&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 229</span>               &amp;&amp; !is_function&lt;typename remove_pointer&lt;_Functor&gt;::type&gt;<span style="color: #000000;">::value),
</span><span style="color: #008080;"> 230</span>              typename result_of&lt;_Functor&amp;(_Args&amp;&amp;...)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 231</span>            &gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 232</span>     __invoke(_Functor&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;"> 233</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 234</span>       <span style="color: #0000ff;">return</span> __f(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 235</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 236</span> 
<span style="color: #008080;"> 237</span>   template&lt;typename _Functor, typename... _Args&gt;
<span style="color: #008080;"> 238</span> <span style="color: #000000;">    inline
</span><span style="color: #008080;"> 239</span>     typename enable_if&lt;
<span style="color: #008080;"> 240</span>              (is_member_pointer&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 241</span>               &amp;&amp; !is_function&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 242</span>               &amp;&amp; !is_function&lt;typename remove_pointer&lt;_Functor&gt;::type&gt;<span style="color: #000000;">::value),
</span><span style="color: #008080;"> 243</span>              typename result_of&lt;_Functor(_Args&amp;&amp;...)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 244</span>            &gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 245</span>     __invoke(_Functor&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;"> 246</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 247</span>       <span style="color: #0000ff;">return</span> std::mem_fn(__f)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 248</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 249</span> 
<span style="color: #008080;"> 250</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> To pick up function references (that will become function pointers)</span>
<span style="color: #008080;"> 251</span>   template&lt;typename _Functor, typename... _Args&gt;
<span style="color: #008080;"> 252</span> <span style="color: #000000;">    inline
</span><span style="color: #008080;"> 253</span>     typename enable_if&lt;
<span style="color: #008080;"> 254</span>              (is_pointer&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 255</span>               &amp;&amp; is_function&lt;typename remove_pointer&lt;_Functor&gt;::type&gt;<span style="color: #000000;">::value),
</span><span style="color: #008080;"> 256</span>              typename result_of&lt;_Functor(_Args&amp;&amp;...)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 257</span>            &gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 258</span>     __invoke(_Functor __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;"> 259</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 260</span>       <span style="color: #0000ff;">return</span> __f(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 261</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 262</span> 
<span style="color: #008080;"> 263</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 264</span> <span style="color: #008000;">   *  Knowing which of unary_function and binary_function _Tp derives
</span><span style="color: #008080;"> 265</span> <span style="color: #008000;">   *  from, derives from the same and ensures that reference_wrapper
</span><span style="color: #008080;"> 266</span> <span style="color: #008000;">   *  will have a weak result type. See cases below.
</span><span style="color: #008080;"> 267</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 268</span>   template&lt;<span style="color: #0000ff;">bool</span> _Unary, <span style="color: #0000ff;">bool</span> _Binary, typename _Tp&gt;
<span style="color: #008080;"> 269</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Reference_wrapper_base_impl;
</span><span style="color: #008080;"> 270</span> 
<span style="color: #008080;"> 271</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> None of the nested argument types.</span>
<span style="color: #008080;"> 272</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 273</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base_impl&lt;<span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>, _Tp&gt;
<span style="color: #008080;"> 274</span>     : _Weak_result_type&lt;_Tp&gt;
<span style="color: #008080;"> 275</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 276</span> 
<span style="color: #008080;"> 277</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Nested argument_type only.</span>
<span style="color: #008080;"> 278</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 279</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base_impl&lt;<span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">false</span>, _Tp&gt;
<span style="color: #008080;"> 280</span>     : _Weak_result_type&lt;_Tp&gt;
<span style="color: #008080;"> 281</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 282</span> <span style="color: #000000;">      typedef typename _Tp::argument_type argument_type;
</span><span style="color: #008080;"> 283</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 284</span> 
<span style="color: #008080;"> 285</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Nested first_argument_type and second_argument_type only.</span>
<span style="color: #008080;"> 286</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 287</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base_impl&lt;<span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">true</span>, _Tp&gt;
<span style="color: #008080;"> 288</span>     : _Weak_result_type&lt;_Tp&gt;
<span style="color: #008080;"> 289</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 290</span> <span style="color: #000000;">      typedef typename _Tp::first_argument_type first_argument_type;
</span><span style="color: #008080;"> 291</span> <span style="color: #000000;">      typedef typename _Tp::second_argument_type second_argument_type;
</span><span style="color: #008080;"> 292</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 293</span> 
<span style="color: #008080;"> 294</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> All the nested argument types.</span>
<span style="color: #008080;"> 295</span>    template&lt;typename _Tp&gt;
<span style="color: #008080;"> 296</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base_impl&lt;<span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">true</span>, _Tp&gt;
<span style="color: #008080;"> 297</span>     : _Weak_result_type&lt;_Tp&gt;
<span style="color: #008080;"> 298</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 299</span> <span style="color: #000000;">      typedef typename _Tp::argument_type argument_type;
</span><span style="color: #008080;"> 300</span> <span style="color: #000000;">      typedef typename _Tp::first_argument_type first_argument_type;
</span><span style="color: #008080;"> 301</span> <span style="color: #000000;">      typedef typename _Tp::second_argument_type second_argument_type;
</span><span style="color: #008080;"> 302</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 303</span> 
<span style="color: #008080;"> 304</span> <span style="color: #000000;">  _GLIBCXX_HAS_NESTED_TYPE(argument_type)
</span><span style="color: #008080;"> 305</span> <span style="color: #000000;">  _GLIBCXX_HAS_NESTED_TYPE(first_argument_type)
</span><span style="color: #008080;"> 306</span> <span style="color: #000000;">  _GLIBCXX_HAS_NESTED_TYPE(second_argument_type)
</span><span style="color: #008080;"> 307</span> 
<span style="color: #008080;"> 308</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 309</span> <span style="color: #008000;">   *  Derives from unary_function or binary_function when it
</span><span style="color: #008080;"> 310</span> <span style="color: #008000;">   *  can. Specializations handle all of the easy cases. The primary
</span><span style="color: #008080;"> 311</span> <span style="color: #008000;">   *  template determines what to do with a class type, which may
</span><span style="color: #008080;"> 312</span> <span style="color: #008000;">   *  derive from both unary_function and binary_function.
</span><span style="color: #008080;"> 313</span>   <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 314</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 315</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Reference_wrapper_base
</span><span style="color: #008080;"> 316</span>     : _Reference_wrapper_base_impl&lt;
<span style="color: #008080;"> 317</span>       __has_argument_type&lt;_Tp&gt;<span style="color: #000000;">::value,
</span><span style="color: #008080;"> 318</span>       __has_first_argument_type&lt;_Tp&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 319</span>       &amp;&amp; __has_second_argument_type&lt;_Tp&gt;<span style="color: #000000;">::value,
</span><span style="color: #008080;"> 320</span>       _Tp&gt;
<span style="color: #008080;"> 321</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 322</span> 
<span style="color: #008080;"> 323</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a function type (unary)</span>
<span style="color: #008080;"> 324</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 325</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1)&gt;
<span style="color: #008080;"> 326</span>     : unary_function&lt;_T1, _Res&gt;
<span style="color: #008080;"> 327</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 328</span> 
<span style="color: #008080;"> 329</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 330</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 331</span>     : unary_function&lt;_T1, _Res&gt;
<span style="color: #008080;"> 332</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 333</span> 
<span style="color: #008080;"> 334</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 335</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 336</span>     : unary_function&lt;_T1, _Res&gt;
<span style="color: #008080;"> 337</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 338</span> 
<span style="color: #008080;"> 339</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 340</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 341</span>     : unary_function&lt;_T1, _Res&gt;
<span style="color: #008080;"> 342</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 343</span> 
<span style="color: #008080;"> 344</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a function type (binary)</span>
<span style="color: #008080;"> 345</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 346</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1, _T2)&gt;
<span style="color: #008080;"> 347</span>     : binary_function&lt;_T1, _T2, _Res&gt;
<span style="color: #008080;"> 348</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 349</span> 
<span style="color: #008080;"> 350</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 351</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1, _T2) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 352</span>     : binary_function&lt;_T1, _T2, _Res&gt;
<span style="color: #008080;"> 353</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 354</span> 
<span style="color: #008080;"> 355</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 356</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1, _T2) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 357</span>     : binary_function&lt;_T1, _T2, _Res&gt;
<span style="color: #008080;"> 358</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 359</span> 
<span style="color: #008080;"> 360</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 361</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(_T1, _T2) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 362</span>     : binary_function&lt;_T1, _T2, _Res&gt;
<span style="color: #008080;"> 363</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 364</span> 
<span style="color: #008080;"> 365</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a function pointer type (unary)</span>
<span style="color: #008080;"> 366</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 367</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(*)(_T1)&gt;
<span style="color: #008080;"> 368</span>     : unary_function&lt;_T1, _Res&gt;
<span style="color: #008080;"> 369</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 370</span> 
<span style="color: #008080;"> 371</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a function pointer type (binary)</span>
<span style="color: #008080;"> 372</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 373</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res(*)(_T1, _T2)&gt;
<span style="color: #008080;"> 374</span>     : binary_function&lt;_T1, _T2, _Res&gt;
<span style="color: #008080;"> 375</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 376</span> 
<span style="color: #008080;"> 377</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (unary, no qualifiers)</span>
<span style="color: #008080;"> 378</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 379</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)()&gt;
<span style="color: #008080;"> 380</span>     : unary_function&lt;_T1*, _Res&gt;
<span style="color: #008080;"> 381</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 382</span> 
<span style="color: #008080;"> 383</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (binary, no qualifiers)</span>
<span style="color: #008080;"> 384</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 385</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)(_T2)&gt;
<span style="color: #008080;"> 386</span>     : binary_function&lt;_T1*, _T2, _Res&gt;
<span style="color: #008080;"> 387</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 388</span> 
<span style="color: #008080;"> 389</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (unary, const)</span>
<span style="color: #008080;"> 390</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 391</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)() <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 392</span>     : unary_function&lt;<span style="color: #0000ff;">const</span> _T1*, _Res&gt;
<span style="color: #008080;"> 393</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 394</span> 
<span style="color: #008080;"> 395</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (binary, const)</span>
<span style="color: #008080;"> 396</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 397</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)(_T2) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 398</span>     : binary_function&lt;<span style="color: #0000ff;">const</span> _T1*, _T2, _Res&gt;
<span style="color: #008080;"> 399</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 400</span> 
<span style="color: #008080;"> 401</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (unary, volatile)</span>
<span style="color: #008080;"> 402</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 403</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)() <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 404</span>     : unary_function&lt;<span style="color: #0000ff;">volatile</span> _T1*, _Res&gt;
<span style="color: #008080;"> 405</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 406</span> 
<span style="color: #008080;"> 407</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (binary, volatile)</span>
<span style="color: #008080;"> 408</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 409</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)(_T2) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 410</span>     : binary_function&lt;<span style="color: #0000ff;">volatile</span> _T1*, _T2, _Res&gt;
<span style="color: #008080;"> 411</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 412</span> 
<span style="color: #008080;"> 413</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (unary, const volatile)</span>
<span style="color: #008080;"> 414</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 415</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)() <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 416</span>     : unary_function&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _T1*, _Res&gt;
<span style="color: #008080;"> 417</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 418</span> 
<span style="color: #008080;"> 419</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> - a pointer to member function type (binary, const volatile)</span>
<span style="color: #008080;"> 420</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 421</span>     <span style="color: #0000ff;">struct</span> _Reference_wrapper_base&lt;_Res (_T1::*)(_T2) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 422</span>     : binary_function&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _T1*, _T2, _Res&gt;
<span style="color: #008080;"> 423</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 424</span> 
<span style="color: #008080;"> 425</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 426</span> <span style="color: #008000;">   *  @brief Primary class template for reference_wrapper.
</span><span style="color: #008080;"> 427</span> <span style="color: #008000;">   *  @ingroup functors
</span><span style="color: #008080;"> 428</span> <span style="color: #008000;">   *  @{
</span><span style="color: #008080;"> 429</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 430</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 431</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> reference_wrapper
</span><span style="color: #008080;"> 432</span>     : <span style="color: #0000ff;">public</span> _Reference_wrapper_base&lt;typename remove_cv&lt;_Tp&gt;::type&gt;
<span style="color: #008080;"> 433</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 434</span>       _Tp*<span style="color: #000000;"> _M_data;
</span><span style="color: #008080;"> 435</span> 
<span style="color: #008080;"> 436</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 437</span> <span style="color: #000000;">      typedef _Tp type;
</span><span style="color: #008080;"> 438</span> 
<span style="color: #008080;"> 439</span>       reference_wrapper(_Tp&amp;<span style="color: #000000;"> __indata) noexcept
</span><span style="color: #008080;"> 440</span> <span style="color: #000000;">      : _M_data(std::__addressof(__indata))
</span><span style="color: #008080;"> 441</span> <span style="color: #000000;">      { }
</span><span style="color: #008080;"> 442</span> 
<span style="color: #008080;"> 443</span>       reference_wrapper(_Tp&amp;&amp;) = <span style="color: #0000ff;">delete</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 444</span> 
<span style="color: #008080;"> 445</span>       reference_wrapper(<span style="color: #0000ff;">const</span> reference_wrapper&lt;_Tp&gt;&amp;<span style="color: #000000;"> __inref) noexcept
</span><span style="color: #008080;"> 446</span> <span style="color: #000000;">      : _M_data(__inref._M_data)
</span><span style="color: #008080;"> 447</span> <span style="color: #000000;">      { }
</span><span style="color: #008080;"> 448</span> 
<span style="color: #008080;"> 449</span>       reference_wrapper&amp;
<span style="color: #008080;"> 450</span>       <span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> reference_wrapper&lt;_Tp&gt;&amp;<span style="color: #000000;"> __inref) noexcept
</span><span style="color: #008080;"> 451</span> <span style="color: #000000;">      {
</span><span style="color: #008080;"> 452</span>         _M_data =<span style="color: #000000;"> __inref._M_data;
</span><span style="color: #008080;"> 453</span>         <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 454</span> <span style="color: #000000;">      }
</span><span style="color: #008080;"> 455</span> 
<span style="color: #008080;"> 456</span>       <span style="color: #0000ff;">operator</span> _Tp&amp;() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 457</span>       { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;<span style="color: #0000ff;">get</span><span style="color: #000000;">(); }
</span><span style="color: #008080;"> 458</span> 
<span style="color: #008080;"> 459</span>       _Tp&amp;
<span style="color: #008080;"> 460</span>       <span style="color: #0000ff;">get</span>() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 461</span>       { <span style="color: #0000ff;">return</span> *<span style="color: #000000;">_M_data; }
</span><span style="color: #008080;"> 462</span> 
<span style="color: #008080;"> 463</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;"> 464</span>         typename result_of&lt;_Tp&amp;(_Args&amp;&amp;...)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;"> 465</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 466</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 467</span>           <span style="color: #0000ff;">return</span> __invoke(<span style="color: #0000ff;">get</span>(), std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 468</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 469</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 470</span> 
<span style="color: #008080;"> 471</span> 
<span style="color: #008080;"> 472</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Denotes a reference should be taken to a variable.</span>
<span style="color: #008080;"> 473</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 474</span>     inline reference_wrapper&lt;_Tp&gt;
<span style="color: #008080;"> 475</span>     <span style="color: #0000ff;">ref</span>(_Tp&amp;<span style="color: #000000;"> __t) noexcept
</span><span style="color: #008080;"> 476</span>     { <span style="color: #0000ff;">return</span> reference_wrapper&lt;_Tp&gt;<span style="color: #000000;">(__t); }
</span><span style="color: #008080;"> 477</span> 
<span style="color: #008080;"> 478</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Denotes a const reference should be taken to a variable.</span>
<span style="color: #008080;"> 479</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 480</span>     inline reference_wrapper&lt;<span style="color: #0000ff;">const</span> _Tp&gt;
<span style="color: #008080;"> 481</span>     cref(<span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;"> __t) noexcept
</span><span style="color: #008080;"> 482</span>     { <span style="color: #0000ff;">return</span> reference_wrapper&lt;<span style="color: #0000ff;">const</span> _Tp&gt;<span style="color: #000000;">(__t); }
</span><span style="color: #008080;"> 483</span> 
<span style="color: #008080;"> 484</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 485</span>     <span style="color: #0000ff;">void</span> <span style="color: #0000ff;">ref</span>(<span style="color: #0000ff;">const</span> _Tp&amp;&amp;) = <span style="color: #0000ff;">delete</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 486</span> 
<span style="color: #008080;"> 487</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 488</span>     <span style="color: #0000ff;">void</span> cref(<span style="color: #0000ff;">const</span> _Tp&amp;&amp;) = <span style="color: #0000ff;">delete</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 489</span> 
<span style="color: #008080;"> 490</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Partial specialization.</span>
<span style="color: #008080;"> 491</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 492</span>     inline reference_wrapper&lt;_Tp&gt;
<span style="color: #008080;"> 493</span>     <span style="color: #0000ff;">ref</span>(reference_wrapper&lt;_Tp&gt;<span style="color: #000000;"> __t) noexcept
</span><span style="color: #008080;"> 494</span>     { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">ref</span>(__t.<span style="color: #0000ff;">get</span><span style="color: #000000;">()); }
</span><span style="color: #008080;"> 495</span> 
<span style="color: #008080;"> 496</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Partial specialization.</span>
<span style="color: #008080;"> 497</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 498</span>     inline reference_wrapper&lt;<span style="color: #0000ff;">const</span> _Tp&gt;
<span style="color: #008080;"> 499</span>     cref(reference_wrapper&lt;_Tp&gt;<span style="color: #000000;"> __t) noexcept
</span><span style="color: #008080;"> 500</span>     { <span style="color: #0000ff;">return</span> cref(__t.<span style="color: #0000ff;">get</span><span style="color: #000000;">()); }
</span><span style="color: #008080;"> 501</span> 
<span style="color: #008080;"> 502</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> @} group functors</span>
<span style="color: #008080;"> 503</span> 
<span style="color: #008080;"> 504</span>   template&lt;typename... _Types&gt;
<span style="color: #008080;"> 505</span>     <span style="color: #0000ff;">struct</span> _Pack : integral_constant&lt;size_t, <span style="color: #0000ff;">sizeof</span>...(_Types)&gt;
<span style="color: #008080;"> 506</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 507</span> 
<span style="color: #008080;"> 508</span>   template&lt;typename _From, typename _To, <span style="color: #0000ff;">bool</span> = _From::value == _To::value&gt;
<span style="color: #008080;"> 509</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _AllConvertible : false_type
</span><span style="color: #008080;"> 510</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 511</span> 
<span style="color: #008080;"> 512</span>   template&lt;typename... _From, typename... _To&gt;
<span style="color: #008080;"> 513</span>     <span style="color: #0000ff;">struct</span> _AllConvertible&lt;_Pack&lt;_From...&gt;, _Pack&lt;_To...&gt;, <span style="color: #0000ff;">true</span>&gt;
<span style="color: #008080;"> 514</span>     : __and_&lt;is_convertible&lt;_From, _To&gt;...&gt;
<span style="color: #008080;"> 515</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 516</span> 
<span style="color: #008080;"> 517</span>   template&lt;typename _Tp1, typename _Tp2&gt;
<span style="color: #008080;"> 518</span>     <span style="color: #0000ff;">using</span> _NotSame = __not_&lt;is_same&lt;typename std::decay&lt;_Tp1&gt;<span style="color: #000000;">::type,
</span><span style="color: #008080;"> 519</span>                                     typename std::decay&lt;_Tp2&gt;::type&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 520</span> 
<span style="color: #008080;"> 521</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 522</span> <span style="color: #008000;">   * Derives from @c unary_function or @c binary_function, or perhaps
</span><span style="color: #008080;"> 523</span> <span style="color: #008000;">   * nothing, depending on the number of arguments provided. The
</span><span style="color: #008080;"> 524</span> <span style="color: #008000;">   * primary template is the basis case, which derives nothing.
</span><span style="color: #008080;"> 525</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 526</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 527</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Maybe_unary_or_binary_function { };
</span><span style="color: #008080;"> 528</span> 
<span style="color: #008080;"> 529</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Derives from @c unary_function, as appropriate.</span>
<span style="color: #008080;"> 530</span>   template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 531</span>     <span style="color: #0000ff;">struct</span> _Maybe_unary_or_binary_function&lt;_Res, _T1&gt;
<span style="color: #008080;"> 532</span>     : std::unary_function&lt;_T1, _Res&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;"> 533</span> 
<span style="color: #008080;"> 534</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Derives from @c binary_function, as appropriate.</span>
<span style="color: #008080;"> 535</span>   template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 536</span>     <span style="color: #0000ff;">struct</span> _Maybe_unary_or_binary_function&lt;_Res, _T1, _T2&gt;
<span style="color: #008080;"> 537</span>     : std::binary_function&lt;_T1, _T2, _Res&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;"> 538</span> 
<span style="color: #008080;"> 539</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Implementation of @c mem_fn for member function pointers.</span>
<span style="color: #008080;"> 540</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 541</span>     <span style="color: #0000ff;">class</span> _Mem_fn&lt;_Res (_Class::*)(_ArgTypes...)&gt;
<span style="color: #008080;"> 542</span>     : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, _Class*, _ArgTypes...&gt;
<span style="color: #008080;"> 543</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 544</span>       typedef _Res (_Class::*<span style="color: #000000;">_Functor)(_ArgTypes...);
</span><span style="color: #008080;"> 545</span> 
<span style="color: #008080;"> 546</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 547</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 548</span>         _M_call(_Tp&amp;&amp; __object, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class *<span style="color: #000000;">,
</span><span style="color: #008080;"> 549</span>                 _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 550</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 551</span>           <span style="color: #0000ff;">return</span> (std::forward&lt;_Tp&gt;(__object).*<span style="color: #000000;">__pmf)
</span><span style="color: #008080;"> 552</span>             (std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 553</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 554</span> 
<span style="color: #008080;"> 555</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 556</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 557</span>         _M_call(_Tp&amp;&amp; __ptr, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">void</span> *, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 558</span>         { <span style="color: #0000ff;">return</span> ((*__ptr).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 559</span> 
<span style="color: #008080;"> 560</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Require each _Args to be convertible to corresponding _ArgTypes</span>
<span style="color: #008080;"> 561</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;"> 562</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs
</span><span style="color: #008080;"> 563</span>           = _Require&lt;_AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 564</span> 
<span style="color: #008080;"> 565</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Require each _Args to be convertible to corresponding _ArgTypes
</span><span style="color: #008080;"> 566</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> and require _Tp is not _Class, _Class&amp; or _Class*</span>
<span style="color: #008080;"> 567</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 568</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs2
</span><span style="color: #008080;"> 569</span>           = _Require&lt;_NotSame&lt;_Class, _Tp&gt;, _NotSame&lt;_Class*, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 570</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 571</span> 
<span style="color: #008080;"> 572</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Require each _Args to be convertible to corresponding _ArgTypes
</span><span style="color: #008080;"> 573</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> and require _Tp is _Class or derived from _Class</span>
<span style="color: #008080;"> 574</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 575</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs3
</span><span style="color: #008080;"> 576</span>           = _Require&lt;is_base_of&lt;_Class, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 577</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 578</span> 
<span style="color: #008080;"> 579</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 580</span> <span style="color: #000000;">      typedef _Res result_type;
</span><span style="color: #008080;"> 581</span> 
<span style="color: #008080;"> 582</span>       <span style="color: #0000ff;">explicit</span><span style="color: #000000;"> _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
</span><span style="color: #008080;"> 583</span> 
<span style="color: #008080;"> 584</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle objects</span>
<span style="color: #008080;"> 585</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 586</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 587</span>         <span style="color: #0000ff;">operator</span>()(_Class&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 588</span>         { <span style="color: #0000ff;">return</span> (__object.*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 589</span> 
<span style="color: #008080;"> 590</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 591</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 592</span>         <span style="color: #0000ff;">operator</span>()(_Class&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 593</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 594</span>           <span style="color: #0000ff;">return</span> (std::move(__object).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 595</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 596</span> 
<span style="color: #008080;"> 597</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle pointers</span>
<span style="color: #008080;"> 598</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 599</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 600</span>         <span style="color: #0000ff;">operator</span>()(_Class* __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 601</span>         { <span style="color: #0000ff;">return</span> (__object-&gt;*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 602</span> 
<span style="color: #008080;"> 603</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle smart pointers, references and pointers to derived</span>
<span style="color: #008080;"> 604</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 605</span>                typename _Req = _RequireValidArgs2&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 606</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 607</span>         <span style="color: #0000ff;">operator</span>()(_Tp&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 608</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 609</span>           <span style="color: #0000ff;">return</span> _M_call(std::forward&lt;_Tp&gt;(__object), &amp;<span style="color: #000000;">__object,
</span><span style="color: #008080;"> 610</span>               std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 611</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 612</span> 
<span style="color: #008080;"> 613</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 614</span>                typename _Req = _RequireValidArgs3&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 615</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 616</span>         <span style="color: #0000ff;">operator</span>()(reference_wrapper&lt;_Tp&gt; __ref, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 617</span>         { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">operator</span>()(__ref.<span style="color: #0000ff;">get</span>(), std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 618</span> 
<span style="color: #008080;"> 619</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 620</span> <span style="color: #000000;">      _Functor __pmf;
</span><span style="color: #008080;"> 621</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 622</span> 
<span style="color: #008080;"> 623</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Implementation of @c mem_fn for const member function pointers.</span>
<span style="color: #008080;"> 624</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 625</span>     <span style="color: #0000ff;">class</span> _Mem_fn&lt;_Res (_Class::*)(_ArgTypes...) <span style="color: #0000ff;">const</span>&gt;
<span style="color: #008080;"> 626</span>     : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, <span style="color: #0000ff;">const</span> _Class*<span style="color: #000000;">,
</span><span style="color: #008080;"> 627</span>                                              _ArgTypes...&gt;
<span style="color: #008080;"> 628</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 629</span>       typedef _Res (_Class::*_Functor)(_ArgTypes...) <span style="color: #0000ff;">const</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 630</span> 
<span style="color: #008080;"> 631</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 632</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 633</span>         _M_call(_Tp&amp;&amp; __object, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class *<span style="color: #000000;">,
</span><span style="color: #008080;"> 634</span>                 _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 635</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 636</span>           <span style="color: #0000ff;">return</span> (std::forward&lt;_Tp&gt;(__object).*<span style="color: #000000;">__pmf)
</span><span style="color: #008080;"> 637</span>             (std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 638</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 639</span> 
<span style="color: #008080;"> 640</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 641</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 642</span>         _M_call(_Tp&amp;&amp; __ptr, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">void</span> *, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 643</span>         { <span style="color: #0000ff;">return</span> ((*__ptr).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 644</span> 
<span style="color: #008080;"> 645</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;"> 646</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs
</span><span style="color: #008080;"> 647</span>           = _Require&lt;_AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 648</span> 
<span style="color: #008080;"> 649</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 650</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs2
</span><span style="color: #008080;"> 651</span>           = _Require&lt;_NotSame&lt;_Class, _Tp&gt;, _NotSame&lt;<span style="color: #0000ff;">const</span> _Class*, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 652</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 653</span> 
<span style="color: #008080;"> 654</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 655</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs3
</span><span style="color: #008080;"> 656</span>           = _Require&lt;is_base_of&lt;_Class, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 657</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 658</span> 
<span style="color: #008080;"> 659</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 660</span> <span style="color: #000000;">      typedef _Res result_type;
</span><span style="color: #008080;"> 661</span> 
<span style="color: #008080;"> 662</span>       <span style="color: #0000ff;">explicit</span><span style="color: #000000;"> _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
</span><span style="color: #008080;"> 663</span> 
<span style="color: #008080;"> 664</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle objects</span>
<span style="color: #008080;"> 665</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 666</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 667</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 668</span>         { <span style="color: #0000ff;">return</span> (__object.*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 669</span> 
<span style="color: #008080;"> 670</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 671</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 672</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 673</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 674</span>           <span style="color: #0000ff;">return</span> (std::move(__object).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 675</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 676</span> 
<span style="color: #008080;"> 677</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle pointers</span>
<span style="color: #008080;"> 678</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 679</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 680</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class* __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 681</span>         { <span style="color: #0000ff;">return</span> (__object-&gt;*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 682</span> 
<span style="color: #008080;"> 683</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle smart pointers, references and pointers to derived</span>
<span style="color: #008080;"> 684</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 685</span>                typename _Req = _RequireValidArgs2&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 686</span>         _Res <span style="color: #0000ff;">operator</span>()(_Tp&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 687</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 688</span>           <span style="color: #0000ff;">return</span> _M_call(std::forward&lt;_Tp&gt;(__object), &amp;<span style="color: #000000;">__object,
</span><span style="color: #008080;"> 689</span>               std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 690</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 691</span> 
<span style="color: #008080;"> 692</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 693</span>                typename _Req = _RequireValidArgs3&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 694</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 695</span>         <span style="color: #0000ff;">operator</span>()(reference_wrapper&lt;_Tp&gt; __ref, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 696</span>         { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">operator</span>()(__ref.<span style="color: #0000ff;">get</span>(), std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 697</span> 
<span style="color: #008080;"> 698</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 699</span> <span style="color: #000000;">      _Functor __pmf;
</span><span style="color: #008080;"> 700</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 701</span> 
<span style="color: #008080;"> 702</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Implementation of @c mem_fn for volatile member function pointers.</span>
<span style="color: #008080;"> 703</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 704</span>     <span style="color: #0000ff;">class</span> _Mem_fn&lt;_Res (_Class::*)(_ArgTypes...) <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 705</span>     : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, <span style="color: #0000ff;">volatile</span> _Class*<span style="color: #000000;">,
</span><span style="color: #008080;"> 706</span>                                              _ArgTypes...&gt;
<span style="color: #008080;"> 707</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 708</span>       typedef _Res (_Class::*_Functor)(_ArgTypes...) <span style="color: #0000ff;">volatile</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 709</span> 
<span style="color: #008080;"> 710</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 711</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 712</span>         _M_call(_Tp&amp;&amp; __object, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class *<span style="color: #000000;">,
</span><span style="color: #008080;"> 713</span>                 _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 714</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 715</span>           <span style="color: #0000ff;">return</span> (std::forward&lt;_Tp&gt;(__object).*<span style="color: #000000;">__pmf)
</span><span style="color: #008080;"> 716</span>             (std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 717</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 718</span> 
<span style="color: #008080;"> 719</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 720</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 721</span>         _M_call(_Tp&amp;&amp; __ptr, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">void</span> *, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 722</span>         { <span style="color: #0000ff;">return</span> ((*__ptr).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 723</span> 
<span style="color: #008080;"> 724</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;"> 725</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs
</span><span style="color: #008080;"> 726</span>           = _Require&lt;_AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 727</span> 
<span style="color: #008080;"> 728</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 729</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs2
</span><span style="color: #008080;"> 730</span>           = _Require&lt;_NotSame&lt;_Class, _Tp&gt;, _NotSame&lt;<span style="color: #0000ff;">volatile</span> _Class*, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 731</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 732</span> 
<span style="color: #008080;"> 733</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 734</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs3
</span><span style="color: #008080;"> 735</span>           = _Require&lt;is_base_of&lt;_Class, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 736</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 737</span> 
<span style="color: #008080;"> 738</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 739</span> <span style="color: #000000;">      typedef _Res result_type;
</span><span style="color: #008080;"> 740</span> 
<span style="color: #008080;"> 741</span>       <span style="color: #0000ff;">explicit</span><span style="color: #000000;"> _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
</span><span style="color: #008080;"> 742</span> 
<span style="color: #008080;"> 743</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle objects</span>
<span style="color: #008080;"> 744</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 745</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 746</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">volatile</span> _Class&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 747</span>         { <span style="color: #0000ff;">return</span> (__object.*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 748</span> 
<span style="color: #008080;"> 749</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 750</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 751</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">volatile</span> _Class&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 752</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 753</span>           <span style="color: #0000ff;">return</span> (std::move(__object).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 754</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 755</span> 
<span style="color: #008080;"> 756</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle pointers</span>
<span style="color: #008080;"> 757</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 758</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 759</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">volatile</span> _Class* __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 760</span>         { <span style="color: #0000ff;">return</span> (__object-&gt;*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 761</span> 
<span style="color: #008080;"> 762</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle smart pointers, references and pointers to derived</span>
<span style="color: #008080;"> 763</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 764</span>                typename _Req = _RequireValidArgs2&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 765</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 766</span>         <span style="color: #0000ff;">operator</span>()(_Tp&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 767</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 768</span>           <span style="color: #0000ff;">return</span> _M_call(std::forward&lt;_Tp&gt;(__object), &amp;<span style="color: #000000;">__object,
</span><span style="color: #008080;"> 769</span>               std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 770</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 771</span> 
<span style="color: #008080;"> 772</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 773</span>                typename _Req = _RequireValidArgs3&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 774</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 775</span>         <span style="color: #0000ff;">operator</span>()(reference_wrapper&lt;_Tp&gt; __ref, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 776</span>         { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">operator</span>()(__ref.<span style="color: #0000ff;">get</span>(), std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 777</span> 
<span style="color: #008080;"> 778</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 779</span> <span style="color: #000000;">      _Functor __pmf;
</span><span style="color: #008080;"> 780</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 781</span> 
<span style="color: #008080;"> 782</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Implementation of @c mem_fn for const volatile member function pointers.</span>
<span style="color: #008080;"> 783</span>   template&lt;typename _Res, typename _Class, typename... _ArgTypes&gt;
<span style="color: #008080;"> 784</span>     <span style="color: #0000ff;">class</span> _Mem_fn&lt;_Res (_Class::*)(_ArgTypes...) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&gt;
<span style="color: #008080;"> 785</span>     : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class*<span style="color: #000000;">,
</span><span style="color: #008080;"> 786</span>                                              _ArgTypes...&gt;
<span style="color: #008080;"> 787</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 788</span>       typedef _Res (_Class::*_Functor)(_ArgTypes...) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 789</span> 
<span style="color: #008080;"> 790</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 791</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 792</span>         _M_call(_Tp&amp;&amp; __object, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class *<span style="color: #000000;">,
</span><span style="color: #008080;"> 793</span>                 _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 794</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 795</span>           <span style="color: #0000ff;">return</span> (std::forward&lt;_Tp&gt;(__object).*<span style="color: #000000;">__pmf)
</span><span style="color: #008080;"> 796</span>             (std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 797</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 798</span> 
<span style="color: #008080;"> 799</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 800</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 801</span>         _M_call(_Tp&amp;&amp; __ptr, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">void</span> *, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 802</span>         { <span style="color: #0000ff;">return</span> ((*__ptr).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 803</span> 
<span style="color: #008080;"> 804</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;"> 805</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs
</span><span style="color: #008080;"> 806</span>           = _Require&lt;_AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 807</span> 
<span style="color: #008080;"> 808</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 809</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs2
</span><span style="color: #008080;"> 810</span>           = _Require&lt;_NotSame&lt;_Class, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 811</span>                      _NotSame&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class*, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 812</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 813</span> 
<span style="color: #008080;"> 814</span>       template&lt;typename _Tp, typename... _Args&gt;
<span style="color: #008080;"> 815</span>         <span style="color: #0000ff;">using</span><span style="color: #000000;"> _RequireValidArgs3
</span><span style="color: #008080;"> 816</span>           = _Require&lt;is_base_of&lt;_Class, _Tp&gt;<span style="color: #000000;">,
</span><span style="color: #008080;"> 817</span>                      _AllConvertible&lt;_Pack&lt;_Args...&gt;, _Pack&lt;_ArgTypes...&gt;&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 818</span> 
<span style="color: #008080;"> 819</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 820</span> <span style="color: #000000;">      typedef _Res result_type;
</span><span style="color: #008080;"> 821</span> 
<span style="color: #008080;"> 822</span>       <span style="color: #0000ff;">explicit</span><span style="color: #000000;"> _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
</span><span style="color: #008080;"> 823</span> 
<span style="color: #008080;"> 824</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle objects</span>
<span style="color: #008080;"> 825</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 826</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 827</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 828</span>         { <span style="color: #0000ff;">return</span> (__object.*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 829</span> 
<span style="color: #008080;"> 830</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 831</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 832</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 833</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 834</span>           <span style="color: #0000ff;">return</span> (std::move(__object).*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 835</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 836</span> 
<span style="color: #008080;"> 837</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle pointers</span>
<span style="color: #008080;"> 838</span>       template&lt;typename... _Args, typename _Req = _RequireValidArgs&lt;_Args...&gt;&gt;
<span style="color: #008080;"> 839</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 840</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Class* __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 841</span>         { <span style="color: #0000ff;">return</span> (__object-&gt;*__pmf)(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 842</span> 
<span style="color: #008080;"> 843</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle smart pointers, references and pointers to derived</span>
<span style="color: #008080;"> 844</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 845</span>                typename _Req = _RequireValidArgs2&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 846</span>         _Res <span style="color: #0000ff;">operator</span>()(_Tp&amp;&amp; __object, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 847</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 848</span>           <span style="color: #0000ff;">return</span> _M_call(std::forward&lt;_Tp&gt;(__object), &amp;<span style="color: #000000;">__object,
</span><span style="color: #008080;"> 849</span>               std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 850</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 851</span> 
<span style="color: #008080;"> 852</span>       template&lt;<span style="color: #000000;">typename _Tp, typename... _Args,
</span><span style="color: #008080;"> 853</span>                typename _Req = _RequireValidArgs3&lt;_Tp, _Args...&gt;&gt;
<span style="color: #008080;"> 854</span> <span style="color: #000000;">        _Res
</span><span style="color: #008080;"> 855</span>         <span style="color: #0000ff;">operator</span>()(reference_wrapper&lt;_Tp&gt; __ref, _Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 856</span>         { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">operator</span>()(__ref.<span style="color: #0000ff;">get</span>(), std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...); }
</span><span style="color: #008080;"> 857</span> 
<span style="color: #008080;"> 858</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 859</span> <span style="color: #000000;">      _Functor __pmf;
</span><span style="color: #008080;"> 860</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 861</span> 
<span style="color: #008080;"> 862</span> 
<span style="color: #008080;"> 863</span>   template&lt;typename _Tp, <span style="color: #0000ff;">bool</span>&gt;
<span style="color: #008080;"> 864</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Mem_fn_const_or_non
</span><span style="color: #008080;"> 865</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 866</span>       typedef <span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;"> type;
</span><span style="color: #008080;"> 867</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 868</span> 
<span style="color: #008080;"> 869</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 870</span>     <span style="color: #0000ff;">struct</span> _Mem_fn_const_or_non&lt;_Tp, <span style="color: #0000ff;">false</span>&gt;
<span style="color: #008080;"> 871</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 872</span>       typedef _Tp&amp;<span style="color: #000000;"> type;
</span><span style="color: #008080;"> 873</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 874</span> 
<span style="color: #008080;"> 875</span>   template&lt;typename _Res, typename _Class&gt;
<span style="color: #008080;"> 876</span>     <span style="color: #0000ff;">class</span> _Mem_fn&lt;_Res _Class::*&gt;
<span style="color: #008080;"> 877</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 878</span>       <span style="color: #0000ff;">using</span> __pm_type = _Res _Class::*<span style="color: #000000;">;
</span><span style="color: #008080;"> 879</span> 
<span style="color: #008080;"> 880</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> This bit of genius is due to Peter Dimov, improved slightly by
</span><span style="color: #008080;"> 881</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Douglas Gregor.
</span><span style="color: #008080;"> 882</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Made less elegant to support perfect forwarding and noexcept.</span>
<span style="color: #008080;"> 883</span>       template&lt;typename _Tp&gt;
<span style="color: #008080;"> 884</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;"> 885</span>         _M_call(_Tp&amp;&amp; __object, <span style="color: #0000ff;">const</span> _Class *) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 886</span>         -&gt; decltype(std::forward&lt;_Tp&gt;(__object).*std::declval&lt;__pm_type&amp;&gt;<span style="color: #000000;">())
</span><span style="color: #008080;"> 887</span>         { <span style="color: #0000ff;">return</span> std::forward&lt;_Tp&gt;(__object).*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 888</span> 
<span style="color: #008080;"> 889</span>       template&lt;typename _Tp, typename _Up&gt;
<span style="color: #008080;"> 890</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;"> 891</span>         _M_call(_Tp&amp;&amp; __object, _Up * <span style="color: #0000ff;">const</span> *) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 892</span>         -&gt; decltype((*std::forward&lt;_Tp&gt;(__object)).*std::declval&lt;__pm_type&amp;&gt;<span style="color: #000000;">())
</span><span style="color: #008080;"> 893</span>         { <span style="color: #0000ff;">return</span> (*std::forward&lt;_Tp&gt;(__object)).*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 894</span> 
<span style="color: #008080;"> 895</span>       template&lt;typename _Tp&gt;
<span style="color: #008080;"> 896</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;"> 897</span>         _M_call(_Tp&amp;&amp; __ptr, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">void</span>*) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 898</span>         noexcept(noexcept((*__ptr).*std::declval&lt;__pm_type&amp;&gt;<span style="color: #000000;">()))
</span><span style="color: #008080;"> 899</span>         -&gt; decltype((*__ptr).*std::declval&lt;__pm_type&amp;&gt;<span style="color: #000000;">())
</span><span style="color: #008080;"> 900</span>         { <span style="color: #0000ff;">return</span> (*__ptr).*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 901</span> 
<span style="color: #008080;"> 902</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 903</span>       <span style="color: #0000ff;">explicit</span>
<span style="color: #008080;"> 904</span>       _Mem_fn(_Res _Class::*<span style="color: #000000;">__pm) noexcept : __pm(__pm) { }
</span><span style="color: #008080;"> 905</span> 
<span style="color: #008080;"> 906</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle objects</span>
<span style="color: #008080;"> 907</span>       _Res&amp;
<span style="color: #008080;"> 908</span>       <span style="color: #0000ff;">operator</span>()(_Class&amp; __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 909</span>       { <span style="color: #0000ff;">return</span> __object.*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 910</span> 
<span style="color: #008080;"> 911</span>       <span style="color: #0000ff;">const</span> _Res&amp;
<span style="color: #008080;"> 912</span>       <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class&amp; __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 913</span>       { <span style="color: #0000ff;">return</span> __object.*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 914</span> 
<span style="color: #008080;"> 915</span>       _Res&amp;&amp;
<span style="color: #008080;"> 916</span>       <span style="color: #0000ff;">operator</span>()(_Class&amp;&amp; __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 917</span>       { <span style="color: #0000ff;">return</span> std::forward&lt;_Class&gt;(__object).*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 918</span> 
<span style="color: #008080;"> 919</span>       <span style="color: #0000ff;">const</span> _Res&amp;&amp;
<span style="color: #008080;"> 920</span>       <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class&amp;&amp; __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 921</span>       { <span style="color: #0000ff;">return</span> std::forward&lt;<span style="color: #0000ff;">const</span> _Class&gt;(__object).*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 922</span> 
<span style="color: #008080;"> 923</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle pointers</span>
<span style="color: #008080;"> 924</span>       _Res&amp;
<span style="color: #008080;"> 925</span>       <span style="color: #0000ff;">operator</span>()(_Class* __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 926</span>       { <span style="color: #0000ff;">return</span> __object-&gt;*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 927</span> 
<span style="color: #008080;"> 928</span>       <span style="color: #0000ff;">const</span> _Res&amp;
<span style="color: #008080;"> 929</span>       <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> _Class* __object) <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 930</span>       { <span style="color: #0000ff;">return</span> __object-&gt;*<span style="color: #000000;">__pm; }
</span><span style="color: #008080;"> 931</span> 
<span style="color: #008080;"> 932</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Handle smart pointers and derived</span>
<span style="color: #008080;"> 933</span>       template&lt;typename _Tp, typename _Req = _Require&lt;_NotSame&lt;_Class*, _Tp&gt;&gt;&gt;
<span style="color: #008080;"> 934</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;"> 935</span>         <span style="color: #0000ff;">operator</span>()(_Tp&amp;&amp; __unknown) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 936</span>         noexcept(noexcept(std::declval&lt;_Mem_fn*&gt;()-&gt;<span style="color: #000000;">_M_call
</span><span style="color: #008080;"> 937</span>                           (std::forward&lt;_Tp&gt;(__unknown), &amp;<span style="color: #000000;">__unknown)))
</span><span style="color: #008080;"> 938</span>         -&gt; decltype(<span style="color: #0000ff;">this</span>-&gt;_M_call(std::forward&lt;_Tp&gt;(__unknown), &amp;<span style="color: #000000;">__unknown))
</span><span style="color: #008080;"> 939</span>         { <span style="color: #0000ff;">return</span> _M_call(std::forward&lt;_Tp&gt;(__unknown), &amp;<span style="color: #000000;">__unknown); }
</span><span style="color: #008080;"> 940</span> 
<span style="color: #008080;"> 941</span>       template&lt;typename _Tp, typename _Req = _Require&lt;is_base_of&lt;_Class, _Tp&gt;&gt;&gt;
<span style="color: #008080;"> 942</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;"> 943</span>         <span style="color: #0000ff;">operator</span>()(reference_wrapper&lt;_Tp&gt; __ref) <span style="color: #0000ff;">const</span>
<span style="color: #008080;"> 944</span>         noexcept(noexcept(std::declval&lt;_Mem_fn&amp;&gt;()(__ref.<span style="color: #0000ff;">get</span><span style="color: #000000;">())))
</span><span style="color: #008080;"> 945</span>         -&gt; decltype((*<span style="color: #0000ff;">this</span>)(__ref.<span style="color: #0000ff;">get</span><span style="color: #000000;">()))
</span><span style="color: #008080;"> 946</span>         { <span style="color: #0000ff;">return</span> (*<span style="color: #0000ff;">this</span>)(__ref.<span style="color: #0000ff;">get</span><span style="color: #000000;">()); }
</span><span style="color: #008080;"> 947</span> 
<span style="color: #008080;"> 948</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 949</span>       _Res _Class::*<span style="color: #000000;">__pm;
</span><span style="color: #008080;"> 950</span> <span style="color: #000000;">    };
</span><span style="color: #008080;"> 951</span> 
<span style="color: #008080;"> 952</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> _GLIBCXX_RESOLVE_LIB_DEFECTS
</span><span style="color: #008080;"> 953</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> 2048.  Unnecessary mem_fn overloads</span>
<span style="color: #008080;"> 954</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 955</span> <span style="color: #008000;">   *  @brief Returns a function object that forwards to the member
</span><span style="color: #008080;"> 956</span> <span style="color: #008000;">   *  pointer @a pm.
</span><span style="color: #008080;"> 957</span> <span style="color: #008000;">   *  @ingroup functors
</span><span style="color: #008080;"> 958</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 959</span>   template&lt;typename _Tp, typename _Class&gt;
<span style="color: #008080;"> 960</span>     inline _Mem_fn&lt;_Tp _Class::*&gt;
<span style="color: #008080;"> 961</span>     mem_fn(_Tp _Class::*<span style="color: #000000;"> __pm) noexcept
</span><span style="color: #008080;"> 962</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 963</span>       <span style="color: #0000ff;">return</span> _Mem_fn&lt;_Tp _Class::*&gt;<span style="color: #000000;">(__pm);
</span><span style="color: #008080;"> 964</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 965</span> 
<span style="color: #008080;"> 966</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 967</span> <span style="color: #008000;">   *  @brief Determines if the given type _Tp is a function object
</span><span style="color: #008080;"> 968</span> <span style="color: #008000;">   *  should be treated as a subexpression when evaluating calls to
</span><span style="color: #008080;"> 969</span> <span style="color: #008000;">   *  function objects returned by bind(). [TR1 3.6.1]
</span><span style="color: #008080;"> 970</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;"> 971</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 972</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 973</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> is_bind_expression
</span><span style="color: #008080;"> 974</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> false_type { };
</span><span style="color: #008080;"> 975</span> 
<span style="color: #008080;"> 976</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;"> 977</span> <span style="color: #008000;">   *  @brief Determines if the given type _Tp is a placeholder in a
</span><span style="color: #008080;"> 978</span> <span style="color: #008000;">   *  bind() expression and, if so, which placeholder it is. [TR1 3.6.2]
</span><span style="color: #008080;"> 979</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;"> 980</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 981</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;"> 982</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> is_placeholder
</span><span style="color: #008080;"> 983</span>     : <span style="color: #0000ff;">public</span> integral_constant&lt;<span style="color: #0000ff;">int</span>, <span style="color: #800080;">0</span>&gt;
<span style="color: #008080;"> 984</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;"> 985</span> 
<span style="color: #008080;"> 986</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">* @brief The type of placeholder objects defined by libstdc++.
</span><span style="color: #008080;"> 987</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;"> 988</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 989</span>   template&lt;<span style="color: #0000ff;">int</span> _Num&gt; <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Placeholder { };
</span><span style="color: #008080;"> 990</span> 
<span style="color: #008080;"> 991</span> <span style="color: #000000;">  _GLIBCXX_END_NAMESPACE_VERSION
</span><span style="color: #008080;"> 992</span> 
<span style="color: #008080;"> 993</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">* @namespace std::placeholders
</span><span style="color: #008080;"> 994</span> <span style="color: #008000;">   *  @brief ISO C++11 entities sub-namespace for functional.
</span><span style="color: #008080;"> 995</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;"> 996</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 997</span>   <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> placeholders
</span><span style="color: #008080;"> 998</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 999</span> <span style="color: #000000;">  _GLIBCXX_BEGIN_NAMESPACE_VERSION
</span><span style="color: #008080;">1000</span>   <span style="color: #008000;">/*</span><span style="color: #008000;"> Define a large number of placeholders. There is no way to
</span><span style="color: #008080;">1001</span> <span style="color: #008000;">   * simplify this with variadic templates, because we're introducing
</span><span style="color: #008080;">1002</span> <span style="color: #008000;">   * unique names for each.
</span><span style="color: #008080;">1003</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1004</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">1</span>&gt;<span style="color: #000000;"> _1;
</span><span style="color: #008080;">1005</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">2</span>&gt;<span style="color: #000000;"> _2;
</span><span style="color: #008080;">1006</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">3</span>&gt;<span style="color: #000000;"> _3;
</span><span style="color: #008080;">1007</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">4</span>&gt;<span style="color: #000000;"> _4;
</span><span style="color: #008080;">1008</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">5</span>&gt;<span style="color: #000000;"> _5;
</span><span style="color: #008080;">1009</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">6</span>&gt;<span style="color: #000000;"> _6;
</span><span style="color: #008080;">1010</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">7</span>&gt;<span style="color: #000000;"> _7;
</span><span style="color: #008080;">1011</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">8</span>&gt;<span style="color: #000000;"> _8;
</span><span style="color: #008080;">1012</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">9</span>&gt;<span style="color: #000000;"> _9;
</span><span style="color: #008080;">1013</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">10</span>&gt;<span style="color: #000000;"> _10;
</span><span style="color: #008080;">1014</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">11</span>&gt;<span style="color: #000000;"> _11;
</span><span style="color: #008080;">1015</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">12</span>&gt;<span style="color: #000000;"> _12;
</span><span style="color: #008080;">1016</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">13</span>&gt;<span style="color: #000000;"> _13;
</span><span style="color: #008080;">1017</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">14</span>&gt;<span style="color: #000000;"> _14;
</span><span style="color: #008080;">1018</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">15</span>&gt;<span style="color: #000000;"> _15;
</span><span style="color: #008080;">1019</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">16</span>&gt;<span style="color: #000000;"> _16;
</span><span style="color: #008080;">1020</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">17</span>&gt;<span style="color: #000000;"> _17;
</span><span style="color: #008080;">1021</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">18</span>&gt;<span style="color: #000000;"> _18;
</span><span style="color: #008080;">1022</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">19</span>&gt;<span style="color: #000000;"> _19;
</span><span style="color: #008080;">1023</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">20</span>&gt;<span style="color: #000000;"> _20;
</span><span style="color: #008080;">1024</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">21</span>&gt;<span style="color: #000000;"> _21;
</span><span style="color: #008080;">1025</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">22</span>&gt;<span style="color: #000000;"> _22;
</span><span style="color: #008080;">1026</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">23</span>&gt;<span style="color: #000000;"> _23;
</span><span style="color: #008080;">1027</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">24</span>&gt;<span style="color: #000000;"> _24;
</span><span style="color: #008080;">1028</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">25</span>&gt;<span style="color: #000000;"> _25;
</span><span style="color: #008080;">1029</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">26</span>&gt;<span style="color: #000000;"> _26;
</span><span style="color: #008080;">1030</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">27</span>&gt;<span style="color: #000000;"> _27;
</span><span style="color: #008080;">1031</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">28</span>&gt;<span style="color: #000000;"> _28;
</span><span style="color: #008080;">1032</span>     <span style="color: #0000ff;">extern</span> <span style="color: #0000ff;">const</span> _Placeholder&lt;<span style="color: #800080;">29</span>&gt;<span style="color: #000000;"> _29;
</span><span style="color: #008080;">1033</span> <span style="color: #000000;">  _GLIBCXX_END_NAMESPACE_VERSION
</span><span style="color: #008080;">1034</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">1035</span> 
<span style="color: #008080;">1036</span> <span style="color: #000000;">  _GLIBCXX_BEGIN_NAMESPACE_VERSION
</span><span style="color: #008080;">1037</span> 
<span style="color: #008080;">1038</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1039</span> <span style="color: #008000;">   *  Partial specialization of is_placeholder that provides the placeholder
</span><span style="color: #008080;">1040</span> <span style="color: #008000;">   *  number for the placeholder objects defined by libstdc++.
</span><span style="color: #008080;">1041</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1042</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1043</span>   template&lt;<span style="color: #0000ff;">int</span> _Num&gt;
<span style="color: #008080;">1044</span>     <span style="color: #0000ff;">struct</span> is_placeholder&lt;_Placeholder&lt;_Num&gt; &gt;
<span style="color: #008080;">1045</span>     : <span style="color: #0000ff;">public</span> integral_constant&lt;<span style="color: #0000ff;">int</span>, _Num&gt;
<span style="color: #008080;">1046</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">1047</span> 
<span style="color: #008080;">1048</span>   template&lt;<span style="color: #0000ff;">int</span> _Num&gt;
<span style="color: #008080;">1049</span>     <span style="color: #0000ff;">struct</span> is_placeholder&lt;<span style="color: #0000ff;">const</span> _Placeholder&lt;_Num&gt; &gt;
<span style="color: #008080;">1050</span>     : <span style="color: #0000ff;">public</span> integral_constant&lt;<span style="color: #0000ff;">int</span>, _Num&gt;
<span style="color: #008080;">1051</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">1052</span> 
<span style="color: #008080;">1053</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1054</span> <span style="color: #008000;">   * Used by _Safe_tuple_element to indicate that there is no tuple
</span><span style="color: #008080;">1055</span> <span style="color: #008000;">   * element at this position.
</span><span style="color: #008080;">1056</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1057</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _No_tuple_element;
</span><span style="color: #008080;">1058</span> 
<span style="color: #008080;">1059</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1060</span> <span style="color: #008000;">   * Implementation helper for _Safe_tuple_element. This primary
</span><span style="color: #008080;">1061</span> <span style="color: #008000;">   * template handles the case where it is safe to use @c
</span><span style="color: #008080;">1062</span> <span style="color: #008000;">   * tuple_element.
</span><span style="color: #008080;">1063</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1064</span>   template&lt;std::size_t __i, typename _Tuple, <span style="color: #0000ff;">bool</span> _IsSafe&gt;
<span style="color: #008080;">1065</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Safe_tuple_element_impl
</span><span style="color: #008080;">1066</span>     : tuple_element&lt;__i, _Tuple&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;">1067</span> 
<span style="color: #008080;">1068</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1069</span> <span style="color: #008000;">   * Implementation helper for _Safe_tuple_element. This partial
</span><span style="color: #008080;">1070</span> <span style="color: #008000;">   * specialization handles the case where it is not safe to use @c
</span><span style="color: #008080;">1071</span> <span style="color: #008000;">   * tuple_element. We just return @c _No_tuple_element.
</span><span style="color: #008080;">1072</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1073</span>   template&lt;std::size_t __i, typename _Tuple&gt;
<span style="color: #008080;">1074</span>     <span style="color: #0000ff;">struct</span> _Safe_tuple_element_impl&lt;__i, _Tuple, <span style="color: #0000ff;">false</span>&gt;
<span style="color: #008080;">1075</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1076</span> <span style="color: #000000;">      typedef _No_tuple_element type;
</span><span style="color: #008080;">1077</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1078</span> 
<span style="color: #008080;">1079</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1080</span> <span style="color: #008000;">   * Like tuple_element, but returns @c _No_tuple_element when
</span><span style="color: #008080;">1081</span> <span style="color: #008000;">   * tuple_element would return an error.
</span><span style="color: #008080;">1082</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1083</span>  template&lt;std::size_t __i, typename _Tuple&gt;
<span style="color: #008080;">1084</span>    <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Safe_tuple_element
</span><span style="color: #008080;">1085</span>    : _Safe_tuple_element_impl&lt;<span style="color: #000000;">__i, _Tuple,
</span><span style="color: #008080;">1086</span>                               (__i &lt; tuple_size&lt;_Tuple&gt;::value)&gt;
<span style="color: #008080;">1087</span> <span style="color: #000000;">   { };
</span><span style="color: #008080;">1088</span> 
<span style="color: #008080;">1089</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1090</span> <span style="color: #008000;">   *  Maps an argument to bind() into an actual argument to the bound
</span><span style="color: #008080;">1091</span> <span style="color: #008000;">   *  function object [TR1 3.6.3/5]. Only the first parameter should
</span><span style="color: #008080;">1092</span> <span style="color: #008000;">   *  be specified: the rest are used to determine among the various
</span><span style="color: #008080;">1093</span> <span style="color: #008000;">   *  implementations. Note that, although this class is a function
</span><span style="color: #008080;">1094</span> <span style="color: #008000;">   *  object, it isn't entirely normal because it takes only two
</span><span style="color: #008080;">1095</span> <span style="color: #008000;">   *  parameters regardless of the number of parameters passed to the
</span><span style="color: #008080;">1096</span> <span style="color: #008000;">   *  bind expression. The first parameter is the bound argument and
</span><span style="color: #008080;">1097</span> <span style="color: #008000;">   *  the second parameter is a tuple containing references to the
</span><span style="color: #008080;">1098</span> <span style="color: #008000;">   *  rest of the arguments.
</span><span style="color: #008080;">1099</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1100</span>   template&lt;<span style="color: #000000;">typename _Arg,
</span><span style="color: #008080;">1101</span>            <span style="color: #0000ff;">bool</span> _IsBindExp = is_bind_expression&lt;_Arg&gt;<span style="color: #000000;">::value,
</span><span style="color: #008080;">1102</span>            <span style="color: #0000ff;">bool</span> _IsPlaceholder = (is_placeholder&lt;_Arg&gt;::value &gt; <span style="color: #800080;">0</span>)&gt;
<span style="color: #008080;">1103</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Mu;
</span><span style="color: #008080;">1104</span> 
<span style="color: #008080;">1105</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1106</span> <span style="color: #008000;">   *  If the argument is reference_wrapper&lt;_Tp&gt;, returns the
</span><span style="color: #008080;">1107</span> <span style="color: #008000;">   *  underlying reference. [TR1 3.6.3/5 bullet 1]
</span><span style="color: #008080;">1108</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1109</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">1110</span>     <span style="color: #0000ff;">class</span> _Mu&lt;reference_wrapper&lt;_Tp&gt;, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>&gt;
<span style="color: #008080;">1111</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1112</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1113</span>       typedef _Tp&amp;<span style="color: #000000;"> result_type;
</span><span style="color: #008080;">1114</span> 
<span style="color: #008080;">1115</span>       <span style="color: #008000;">/*</span><span style="color: #008000;"> Note: This won't actually work for const volatile
</span><span style="color: #008080;">1116</span> <span style="color: #008000;">       * reference_wrappers, because reference_wrapper::get() is const
</span><span style="color: #008080;">1117</span> <span style="color: #008000;">       * but not volatile-qualified. This might be a defect in the TR.
</span><span style="color: #008080;">1118</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">1119</span>       template&lt;typename _CVRef, typename _Tuple&gt;
<span style="color: #008080;">1120</span> <span style="color: #000000;">        result_type
</span><span style="color: #008080;">1121</span>         <span style="color: #0000ff;">operator</span>()(_CVRef&amp; __arg, _Tuple&amp;) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1122</span>         { <span style="color: #0000ff;">return</span> __arg.<span style="color: #0000ff;">get</span><span style="color: #000000;">(); }
</span><span style="color: #008080;">1123</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1124</span> 
<span style="color: #008080;">1125</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1126</span> <span style="color: #008000;">   *  If the argument is a bind expression, we invoke the underlying
</span><span style="color: #008080;">1127</span> <span style="color: #008000;">   *  function object with the same cv-qualifiers as we are given and
</span><span style="color: #008080;">1128</span> <span style="color: #008000;">   *  pass along all of our arguments (unwrapped). [TR1 3.6.3/5 bullet 2]
</span><span style="color: #008080;">1129</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1130</span>   template&lt;typename _Arg&gt;
<span style="color: #008080;">1131</span>     <span style="color: #0000ff;">class</span> _Mu&lt;_Arg, <span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">false</span>&gt;
<span style="color: #008080;">1132</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1133</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1134</span>       template&lt;typename _CVArg, typename... _Args&gt;
<span style="color: #008080;">1135</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;">1136</span>         <span style="color: #0000ff;">operator</span>()(_CVArg&amp;<span style="color: #000000;"> __arg,
</span><span style="color: #008080;">1137</span>                    tuple&lt;_Args...&gt;&amp; __tuple) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1138</span>         -&gt; decltype(__arg(declval&lt;_Args&gt;<span style="color: #000000;">()...))
</span><span style="color: #008080;">1139</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1140</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> Construct an index tuple and forward to __call</span>
<span style="color: #008080;">1141</span>           typedef typename _Build_index_tuple&lt;<span style="color: #0000ff;">sizeof</span>...(_Args)&gt;<span style="color: #000000;">::__type
</span><span style="color: #008080;">1142</span> <span style="color: #000000;">            _Indexes;
</span><span style="color: #008080;">1143</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;<span style="color: #000000;">__call(__arg, __tuple, _Indexes());
</span><span style="color: #008080;">1144</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1145</span> 
<span style="color: #008080;">1146</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;">1147</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Invokes the underlying function object __arg by unpacking all
</span><span style="color: #008080;">1148</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> of the arguments in the tuple.</span>
<span style="color: #008080;">1149</span>       template&lt;typename _CVArg, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1150</span> <span style="color: #000000;">        auto
</span><span style="color: #008080;">1151</span>         __call(_CVArg&amp; __arg, tuple&lt;_Args...&gt;&amp;<span style="color: #000000;"> __tuple,
</span><span style="color: #008080;">1152</span>                <span style="color: #0000ff;">const</span> _Index_tuple&lt;_Indexes...&gt;&amp;) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1153</span>         -&gt; decltype(__arg(declval&lt;_Args&gt;<span style="color: #000000;">()...))
</span><span style="color: #008080;">1154</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1155</span>           <span style="color: #0000ff;">return</span> __arg(std::forward&lt;_Args&gt;(<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(__tuple))...);
</span><span style="color: #008080;">1156</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1157</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1158</span> 
<span style="color: #008080;">1159</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1160</span> <span style="color: #008000;">   *  If the argument is a placeholder for the Nth argument, returns
</span><span style="color: #008080;">1161</span> <span style="color: #008000;">   *  a reference to the Nth argument to the bind function object.
</span><span style="color: #008080;">1162</span> <span style="color: #008000;">   *  [TR1 3.6.3/5 bullet 3]
</span><span style="color: #008080;">1163</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1164</span>   template&lt;typename _Arg&gt;
<span style="color: #008080;">1165</span>     <span style="color: #0000ff;">class</span> _Mu&lt;_Arg, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">true</span>&gt;
<span style="color: #008080;">1166</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1167</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1168</span>       template&lt;typename _Signature&gt; <span style="color: #0000ff;">class</span><span style="color: #000000;"> result;
</span><span style="color: #008080;">1169</span> 
<span style="color: #008080;">1170</span>       template&lt;typename _CVMu, typename _CVArg, typename _Tuple&gt;
<span style="color: #008080;">1171</span>         <span style="color: #0000ff;">class</span> result&lt;_CVMu(_CVArg, _Tuple)&gt;
<span style="color: #008080;">1172</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1173</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> Add a reference, if it hasn't already been done for us.
</span><span style="color: #008080;">1174</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> This allows us to be a little bit sloppy in constructing
</span><span style="color: #008080;">1175</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> the tuple that we pass to result_of&lt;...&gt;.</span>
<span style="color: #008080;">1176</span>           typedef typename _Safe_tuple_element&lt;(is_placeholder&lt;_Arg&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;">1177</span>                                                 - <span style="color: #800080;">1</span>), _Tuple&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;">1178</span> <span style="color: #000000;">            __base_type;
</span><span style="color: #008080;">1179</span> 
<span style="color: #008080;">1180</span>         <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1181</span>           typedef typename add_rvalue_reference&lt;__base_type&gt;<span style="color: #000000;">::type type;
</span><span style="color: #008080;">1182</span> <span style="color: #000000;">        };
</span><span style="color: #008080;">1183</span> 
<span style="color: #008080;">1184</span>       template&lt;typename _Tuple&gt;
<span style="color: #008080;">1185</span>         typename result&lt;_Mu(_Arg, _Tuple)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;">1186</span>         <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Arg&amp;, _Tuple&amp; __tuple) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1187</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1188</span>           <span style="color: #0000ff;">return</span> std::forward&lt;typename result&lt;_Mu(_Arg, _Tuple)&gt;::type&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1189</span>               ::std::<span style="color: #0000ff;">get</span>&lt;(is_placeholder&lt;_Arg&gt;::value - <span style="color: #800080;">1</span>)&gt;<span style="color: #000000;">(__tuple));
</span><span style="color: #008080;">1190</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1191</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1192</span> 
<span style="color: #008080;">1193</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1194</span> <span style="color: #008000;">   *  If the argument is just a value, returns a reference to that
</span><span style="color: #008080;">1195</span> <span style="color: #008000;">   *  value. The cv-qualifiers on the reference are the same as the
</span><span style="color: #008080;">1196</span> <span style="color: #008000;">   *  cv-qualifiers on the _Mu object. [TR1 3.6.3/5 bullet 4]
</span><span style="color: #008080;">1197</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1198</span>   template&lt;typename _Arg&gt;
<span style="color: #008080;">1199</span>     <span style="color: #0000ff;">class</span> _Mu&lt;_Arg, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span>&gt;
<span style="color: #008080;">1200</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1201</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1202</span>       template&lt;typename _Signature&gt; <span style="color: #0000ff;">struct</span><span style="color: #000000;"> result;
</span><span style="color: #008080;">1203</span> 
<span style="color: #008080;">1204</span>       template&lt;typename _CVMu, typename _CVArg, typename _Tuple&gt;
<span style="color: #008080;">1205</span>         <span style="color: #0000ff;">struct</span> result&lt;_CVMu(_CVArg, _Tuple)&gt;
<span style="color: #008080;">1206</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1207</span>           typedef typename add_lvalue_reference&lt;_CVArg&gt;<span style="color: #000000;">::type type;
</span><span style="color: #008080;">1208</span> <span style="color: #000000;">        };
</span><span style="color: #008080;">1209</span> 
<span style="color: #008080;">1210</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Pick up the cv-qualifiers of the argument</span>
<span style="color: #008080;">1211</span>       template&lt;typename _CVArg, typename _Tuple&gt;
<span style="color: #008080;">1212</span>         _CVArg&amp;&amp;
<span style="color: #008080;">1213</span>         <span style="color: #0000ff;">operator</span>()(_CVArg&amp;&amp; __arg, _Tuple&amp;) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1214</span>         { <span style="color: #0000ff;">return</span> std::forward&lt;_CVArg&gt;<span style="color: #000000;">(__arg); }
</span><span style="color: #008080;">1215</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1216</span> 
<span style="color: #008080;">1217</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1218</span> <span style="color: #008000;">   *  Maps member pointers into instances of _Mem_fn but leaves all
</span><span style="color: #008080;">1219</span> <span style="color: #008000;">   *  other function objects untouched. Used by tr1::bind(). The
</span><span style="color: #008080;">1220</span> <span style="color: #008000;">   *  primary template handles the non--member-pointer case.
</span><span style="color: #008080;">1221</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1222</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">1223</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Maybe_wrap_member_pointer
</span><span style="color: #008080;">1224</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1225</span> <span style="color: #000000;">      typedef _Tp type;
</span><span style="color: #008080;">1226</span> 
<span style="color: #008080;">1227</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> _Tp&amp;
<span style="color: #008080;">1228</span>       __do_wrap(<span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">1229</span>       { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __x; }
</span><span style="color: #008080;">1230</span> 
<span style="color: #008080;">1231</span>       <span style="color: #0000ff;">static</span> _Tp&amp;&amp;
<span style="color: #008080;">1232</span>       __do_wrap(_Tp&amp;&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">1233</span>       { <span style="color: #0000ff;">return</span> static_cast&lt;_Tp&amp;&amp;&gt;<span style="color: #000000;">(__x); }
</span><span style="color: #008080;">1234</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1235</span> 
<span style="color: #008080;">1236</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1237</span> <span style="color: #008000;">   *  Maps member pointers into instances of _Mem_fn but leaves all
</span><span style="color: #008080;">1238</span> <span style="color: #008000;">   *  other function objects untouched. Used by tr1::bind(). This
</span><span style="color: #008080;">1239</span> <span style="color: #008000;">   *  partial specialization handles the member pointer case.
</span><span style="color: #008080;">1240</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1241</span>   template&lt;typename _Tp, typename _Class&gt;
<span style="color: #008080;">1242</span>     <span style="color: #0000ff;">struct</span> _Maybe_wrap_member_pointer&lt;_Tp _Class::*&gt;
<span style="color: #008080;">1243</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1244</span>       typedef _Mem_fn&lt;_Tp _Class::*&gt;<span style="color: #000000;"> type;
</span><span style="color: #008080;">1245</span> 
<span style="color: #008080;">1246</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> type
</span><span style="color: #008080;">1247</span>       __do_wrap(_Tp _Class::*<span style="color: #000000;"> __pm)
</span><span style="color: #008080;">1248</span>       { <span style="color: #0000ff;">return</span><span style="color: #000000;"> type(__pm); }
</span><span style="color: #008080;">1249</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1250</span> 
<span style="color: #008080;">1251</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Specialization needed to prevent "forming reference to void" errors when
</span><span style="color: #008080;">1252</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> bind&lt;void&gt;() is called, because argument deduction instantiates
</span><span style="color: #008080;">1253</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> _Maybe_wrap_member_pointer&lt;void&gt; outside the immediate context where
</span><span style="color: #008080;">1254</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> SFINAE applies.</span>
<span style="color: #008080;">1255</span>   template&lt;&gt;
<span style="color: #008080;">1256</span>     <span style="color: #0000ff;">struct</span> _Maybe_wrap_member_pointer&lt;<span style="color: #0000ff;">void</span>&gt;
<span style="color: #008080;">1257</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1258</span>       typedef <span style="color: #0000ff;">void</span><span style="color: #000000;"> type;
</span><span style="color: #008080;">1259</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1260</span> 
<span style="color: #008080;">1261</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> std::get&lt;I&gt; for volatile-qualified tuples</span>
<span style="color: #008080;">1262</span>   template&lt;std::size_t _Ind, typename... _Tp&gt;
<span style="color: #008080;">1263</span> <span style="color: #000000;">    inline auto
</span><span style="color: #008080;">1264</span>     __volget(<span style="color: #0000ff;">volatile</span> tuple&lt;_Tp...&gt;&amp;<span style="color: #000000;"> __tuple)
</span><span style="color: #008080;">1265</span>     -&gt; typename tuple_element&lt;_Ind, tuple&lt;_Tp...&gt;&gt;::type <span style="color: #0000ff;">volatile</span>&amp;
<span style="color: #008080;">1266</span>     { <span style="color: #0000ff;">return</span> std::<span style="color: #0000ff;">get</span>&lt;_Ind&gt;(const_cast&lt;tuple&lt;_Tp...&gt;&amp;&gt;<span style="color: #000000;">(__tuple)); }
</span><span style="color: #008080;">1267</span> 
<span style="color: #008080;">1268</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> std::get&lt;I&gt; for const-volatile-qualified tuples</span>
<span style="color: #008080;">1269</span>   template&lt;std::size_t _Ind, typename... _Tp&gt;
<span style="color: #008080;">1270</span> <span style="color: #000000;">    inline auto
</span><span style="color: #008080;">1271</span>     __volget(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> tuple&lt;_Tp...&gt;&amp;<span style="color: #000000;"> __tuple)
</span><span style="color: #008080;">1272</span>     -&gt; typename tuple_element&lt;_Ind, tuple&lt;_Tp...&gt;&gt;::type <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>&amp;
<span style="color: #008080;">1273</span>     { <span style="color: #0000ff;">return</span> std::<span style="color: #0000ff;">get</span>&lt;_Ind&gt;(const_cast&lt;<span style="color: #0000ff;">const</span> tuple&lt;_Tp...&gt;&amp;&gt;<span style="color: #000000;">(__tuple)); }
</span><span style="color: #008080;">1274</span> 
<span style="color: #008080;">1275</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Type of the function object returned from bind().</span>
<span style="color: #008080;">1276</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1277</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bind;
</span><span style="color: #008080;">1278</span> 
<span style="color: #008080;">1279</span>    template&lt;typename _Functor, typename... _Bound_args&gt;
<span style="color: #008080;">1280</span>     <span style="color: #0000ff;">class</span> _Bind&lt;_Functor(_Bound_args...)&gt;
<span style="color: #008080;">1281</span>     : <span style="color: #0000ff;">public</span> _Weak_result_type&lt;_Functor&gt;
<span style="color: #008080;">1282</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1283</span> <span style="color: #000000;">      typedef _Bind __self_type;
</span><span style="color: #008080;">1284</span>       typedef typename _Build_index_tuple&lt;<span style="color: #0000ff;">sizeof</span>...(_Bound_args)&gt;<span style="color: #000000;">::__type
</span><span style="color: #008080;">1285</span> <span style="color: #000000;">        _Bound_indexes;
</span><span style="color: #008080;">1286</span> 
<span style="color: #008080;">1287</span> <span style="color: #000000;">      _Functor _M_f;
</span><span style="color: #008080;">1288</span>       tuple&lt;_Bound_args...&gt;<span style="color: #000000;"> _M_bound_args;
</span><span style="color: #008080;">1289</span> 
<span style="color: #008080;">1290</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call unqualified</span>
<span style="color: #008080;">1291</span>       template&lt;typename _Result, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1292</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1293</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">)
</span><span style="color: #008080;">1294</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1295</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1296</span>                       (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1297</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1298</span> 
<span style="color: #008080;">1299</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const</span>
<span style="color: #008080;">1300</span>       template&lt;typename _Result, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1301</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1302</span>         __call_c(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1303</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1304</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1305</span>                       (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1306</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1307</span> 
<span style="color: #008080;">1308</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as volatile</span>
<span style="color: #008080;">1309</span>       template&lt;typename _Result, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1310</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1311</span>         __call_v(tuple&lt;_Args...&gt;&amp;&amp;<span style="color: #000000;"> __args,
</span><span style="color: #008080;">1312</span>                  _Index_tuple&lt;_Indexes...&gt;) <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1313</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1314</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1315</span>                       (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1316</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1317</span> 
<span style="color: #008080;">1318</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const volatile</span>
<span style="color: #008080;">1319</span>       template&lt;typename _Result, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1320</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1321</span>         __call_c_v(tuple&lt;_Args...&gt;&amp;&amp;<span style="color: #000000;"> __args,
</span><span style="color: #008080;">1322</span>                    _Index_tuple&lt;_Indexes...&gt;) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1323</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1324</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1325</span>                       (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1326</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1327</span> 
<span style="color: #008080;">1328</span>      <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1329</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1330</span>         <span style="color: #0000ff;">explicit</span> _Bind(<span style="color: #0000ff;">const</span> _Functor&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1331</span>         : _M_f(__f), _M_bound_args(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1332</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1333</span> 
<span style="color: #008080;">1334</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1335</span>         <span style="color: #0000ff;">explicit</span> _Bind(_Functor&amp;&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1336</span>         : _M_f(std::move(__f)), _M_bound_args(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1337</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1338</span> 
<span style="color: #008080;">1339</span>       _Bind(<span style="color: #0000ff;">const</span> _Bind&amp;) = <span style="color: #0000ff;">default</span><span style="color: #000000;">;
</span><span style="color: #008080;">1340</span> 
<span style="color: #008080;">1341</span>       _Bind(_Bind&amp;&amp;<span style="color: #000000;"> __b)
</span><span style="color: #008080;">1342</span> <span style="color: #000000;">      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
</span><span style="color: #008080;">1343</span> <span style="color: #000000;">      { }
</span><span style="color: #008080;">1344</span> 
<span style="color: #008080;">1345</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call unqualified</span>
<span style="color: #008080;">1346</span>       template&lt;<span style="color: #000000;">typename... _Args, typename _Result
</span><span style="color: #008080;">1347</span>         = decltype( std::declval&lt;_Functor&gt;<span style="color: #000000;">()(
</span><span style="color: #008080;">1348</span>               _Mu&lt;_Bound_args&gt;()( std::declval&lt;_Bound_args&amp;&gt;<span style="color: #000000;">(),
</span><span style="color: #008080;">1349</span>                                   std::declval&lt;tuple&lt;_Args...&gt;&amp;&gt;() )... ) )&gt;
<span style="color: #008080;">1350</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1351</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1352</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1353</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1354</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1355</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1356</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1357</span> 
<span style="color: #008080;">1358</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const</span>
<span style="color: #008080;">1359</span>       template&lt;<span style="color: #000000;">typename... _Args, typename _Result
</span><span style="color: #008080;">1360</span>         = decltype( std::declval&lt;typename enable_if&lt;(<span style="color: #0000ff;">sizeof</span>...(_Args) &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">),
</span><span style="color: #008080;">1361</span>                        typename add_const&lt;_Functor&gt;::type&gt;::type&gt;<span style="color: #000000;">()(
</span><span style="color: #008080;">1362</span>               _Mu&lt;_Bound_args&gt;()( std::declval&lt;<span style="color: #0000ff;">const</span> _Bound_args&amp;&gt;<span style="color: #000000;">(),
</span><span style="color: #008080;">1363</span>                                   std::declval&lt;tuple&lt;_Args...&gt;&amp;&gt;() )... ) )&gt;
<span style="color: #008080;">1364</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1365</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1366</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1367</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call_c&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1368</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1369</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1370</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1371</span> 
<span style="color: #008080;">1372</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as volatile</span>
<span style="color: #008080;">1373</span>       template&lt;<span style="color: #000000;">typename... _Args, typename _Result
</span><span style="color: #008080;">1374</span>         = decltype( std::declval&lt;typename enable_if&lt;(<span style="color: #0000ff;">sizeof</span>...(_Args) &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">),
</span><span style="color: #008080;">1375</span>                        typename add_volatile&lt;_Functor&gt;::type&gt;::type&gt;<span style="color: #000000;">()(
</span><span style="color: #008080;">1376</span>               _Mu&lt;_Bound_args&gt;()( std::declval&lt;<span style="color: #0000ff;">volatile</span> _Bound_args&amp;&gt;<span style="color: #000000;">(),
</span><span style="color: #008080;">1377</span>                                   std::declval&lt;tuple&lt;_Args...&gt;&amp;&gt;() )... ) )&gt;
<span style="color: #008080;">1378</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1379</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1380</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1381</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call_v&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1382</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1383</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1384</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1385</span> 
<span style="color: #008080;">1386</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const volatile</span>
<span style="color: #008080;">1387</span>       template&lt;<span style="color: #000000;">typename... _Args, typename _Result
</span><span style="color: #008080;">1388</span>         = decltype( std::declval&lt;typename enable_if&lt;(<span style="color: #0000ff;">sizeof</span>...(_Args) &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">),
</span><span style="color: #008080;">1389</span>                        typename add_cv&lt;_Functor&gt;::type&gt;::type&gt;<span style="color: #000000;">()(
</span><span style="color: #008080;">1390</span>               _Mu&lt;_Bound_args&gt;()( std::declval&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Bound_args&amp;&gt;<span style="color: #000000;">(),
</span><span style="color: #008080;">1391</span>                                   std::declval&lt;tuple&lt;_Args...&gt;&amp;&gt;() )... ) )&gt;
<span style="color: #008080;">1392</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1393</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1394</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1395</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call_c_v&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1396</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1397</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1398</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1399</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1400</span> 
<span style="color: #008080;">1401</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Type of the function object returned from bind</span><span style="color: #808080;">&lt;R&gt;</span><span style="color: #008000;">().</span>
<span style="color: #008080;">1402</span>   template&lt;typename _Result, typename _Signature&gt;
<span style="color: #008080;">1403</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bind_result;
</span><span style="color: #008080;">1404</span> 
<span style="color: #008080;">1405</span>   template&lt;typename _Result, typename _Functor, typename... _Bound_args&gt;
<span style="color: #008080;">1406</span>     <span style="color: #0000ff;">class</span> _Bind_result&lt;_Result, _Functor(_Bound_args...)&gt;
<span style="color: #008080;">1407</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1408</span> <span style="color: #000000;">      typedef _Bind_result __self_type;
</span><span style="color: #008080;">1409</span>       typedef typename _Build_index_tuple&lt;<span style="color: #0000ff;">sizeof</span>...(_Bound_args)&gt;<span style="color: #000000;">::__type
</span><span style="color: #008080;">1410</span> <span style="color: #000000;">        _Bound_indexes;
</span><span style="color: #008080;">1411</span> 
<span style="color: #008080;">1412</span> <span style="color: #000000;">      _Functor _M_f;
</span><span style="color: #008080;">1413</span>       tuple&lt;_Bound_args...&gt;<span style="color: #000000;"> _M_bound_args;
</span><span style="color: #008080;">1414</span> 
<span style="color: #008080;">1415</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> sfinae types</span>
<span style="color: #008080;">1416</span>       template&lt;typename _Res&gt;
<span style="color: #008080;">1417</span>         <span style="color: #0000ff;">struct</span> __enable_if_void : enable_if&lt;is_void&lt;_Res&gt;::value, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;">1418</span>       template&lt;typename _Res&gt;
<span style="color: #008080;">1419</span>         <span style="color: #0000ff;">struct</span> __disable_if_void : enable_if&lt;!is_void&lt;_Res&gt;::value, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;">1420</span> 
<span style="color: #008080;">1421</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call unqualified</span>
<span style="color: #008080;">1422</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1423</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1424</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1425</span>             typename __disable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">1426</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1427</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1428</span>                       (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1429</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1430</span> 
<span style="color: #008080;">1431</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call unqualified, return void</span>
<span style="color: #008080;">1432</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1433</span>         <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1434</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1435</span>             typename __enable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008080;">1436</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1437</span>           _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1438</span>                (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1439</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1440</span> 
<span style="color: #008080;">1441</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const</span>
<span style="color: #008080;">1442</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1443</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1444</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1445</span>             typename __disable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1446</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1447</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1448</span>                       (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1449</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1450</span> 
<span style="color: #008080;">1451</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const, return void</span>
<span style="color: #008080;">1452</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1453</span>         <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1454</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1455</span>             typename __enable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1456</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1457</span>           _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1458</span>                (<span style="color: #0000ff;">get</span>&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args),  __args)...);
</span><span style="color: #008080;">1459</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1460</span> 
<span style="color: #008080;">1461</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as volatile</span>
<span style="color: #008080;">1462</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1463</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1464</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1465</span>             typename __disable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1466</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1467</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1468</span>                       (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1469</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1470</span> 
<span style="color: #008080;">1471</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as volatile, return void</span>
<span style="color: #008080;">1472</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1473</span>         <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1474</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1475</span>             typename __enable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1476</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1477</span>           _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1478</span>                (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1479</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1480</span> 
<span style="color: #008080;">1481</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const volatile</span>
<span style="color: #008080;">1482</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1483</span> <span style="color: #000000;">        _Result
</span><span style="color: #008080;">1484</span>         __call(tuple&lt;_Args...&gt;&amp;&amp; __args, _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1485</span>             typename __disable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1486</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1487</span>           <span style="color: #0000ff;">return</span> _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1488</span>                       (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1489</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1490</span> 
<span style="color: #008080;">1491</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const volatile, return void</span>
<span style="color: #008080;">1492</span>       template&lt;typename _Res, typename... _Args, std::size_t... _Indexes&gt;
<span style="color: #008080;">1493</span>         <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1494</span>         __call(tuple&lt;_Args...&gt;&amp;&amp;<span style="color: #000000;"> __args,
</span><span style="color: #008080;">1495</span>                _Index_tuple&lt;_Indexes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">1496</span>             typename __enable_if_void&lt;_Res&gt;::type = <span style="color: #800080;">0</span>) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1497</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1498</span>           _M_f(_Mu&lt;_Bound_args&gt;<span style="color: #000000;">()
</span><span style="color: #008080;">1499</span>                (__volget&lt;_Indexes&gt;<span style="color: #000000;">(_M_bound_args), __args)...);
</span><span style="color: #008080;">1500</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1501</span> 
<span style="color: #008080;">1502</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1503</span> <span style="color: #000000;">      typedef _Result result_type;
</span><span style="color: #008080;">1504</span> 
<span style="color: #008080;">1505</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1506</span>         <span style="color: #0000ff;">explicit</span> _Bind_result(<span style="color: #0000ff;">const</span> _Functor&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1507</span>         : _M_f(__f), _M_bound_args(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1508</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1509</span> 
<span style="color: #008080;">1510</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1511</span>         <span style="color: #0000ff;">explicit</span> _Bind_result(_Functor&amp;&amp; __f, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1512</span>         : _M_f(std::move(__f)), _M_bound_args(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1513</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1514</span> 
<span style="color: #008080;">1515</span>       _Bind_result(<span style="color: #0000ff;">const</span> _Bind_result&amp;) = <span style="color: #0000ff;">default</span><span style="color: #000000;">;
</span><span style="color: #008080;">1516</span> 
<span style="color: #008080;">1517</span>       _Bind_result(_Bind_result&amp;&amp;<span style="color: #000000;"> __b)
</span><span style="color: #008080;">1518</span> <span style="color: #000000;">      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
</span><span style="color: #008080;">1519</span> <span style="color: #000000;">      { }
</span><span style="color: #008080;">1520</span> 
<span style="color: #008080;">1521</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call unqualified</span>
<span style="color: #008080;">1522</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1523</span> <span style="color: #000000;">        result_type
</span><span style="color: #008080;">1524</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1525</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1526</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1527</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1528</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1529</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1530</span> 
<span style="color: #008080;">1531</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const</span>
<span style="color: #008080;">1532</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1533</span> <span style="color: #000000;">        result_type
</span><span style="color: #008080;">1534</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1535</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1536</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1537</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1538</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1539</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1540</span> 
<span style="color: #008080;">1541</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as volatile</span>
<span style="color: #008080;">1542</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1543</span> <span style="color: #000000;">        result_type
</span><span style="color: #008080;">1544</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1545</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1546</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1547</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1548</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1549</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1550</span> 
<span style="color: #008080;">1551</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> Call as const volatile</span>
<span style="color: #008080;">1552</span>       template&lt;typename... _Args&gt;
<span style="color: #008080;">1553</span> <span style="color: #000000;">        result_type
</span><span style="color: #008080;">1554</span>         <span style="color: #0000ff;">operator</span>()(_Args&amp;&amp;... __args) <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span>
<span style="color: #008080;">1555</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1556</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">this</span>-&gt;__call&lt;_Result&gt;<span style="color: #000000;">(
</span><span style="color: #008080;">1557</span>               std::forward_as_tuple(std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...),
</span><span style="color: #008080;">1558</span> <span style="color: #000000;">              _Bound_indexes());
</span><span style="color: #008080;">1559</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1560</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1561</span> 
<span style="color: #008080;">1562</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1563</span> <span style="color: #008000;">   *  @brief Class template _Bind is always a bind expression.
</span><span style="color: #008080;">1564</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1565</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1566</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1567</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;_Bind&lt;_Signature&gt; &gt;
<span style="color: #008080;">1568</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1569</span> 
<span style="color: #008080;">1570</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1571</span> <span style="color: #008000;">   *  @brief Class template _Bind is always a bind expression.
</span><span style="color: #008080;">1572</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1573</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1574</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1575</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">const</span> _Bind&lt;_Signature&gt; &gt;
<span style="color: #008080;">1576</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1577</span> 
<span style="color: #008080;">1578</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1579</span> <span style="color: #008000;">   *  @brief Class template _Bind is always a bind expression.
</span><span style="color: #008080;">1580</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1581</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1582</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1583</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">volatile</span> _Bind&lt;_Signature&gt; &gt;
<span style="color: #008080;">1584</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1585</span> 
<span style="color: #008080;">1586</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1587</span> <span style="color: #008000;">   *  @brief Class template _Bind is always a bind expression.
</span><span style="color: #008080;">1588</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1589</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1590</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1591</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Bind&lt;_Signature&gt;&gt;
<span style="color: #008080;">1592</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1593</span> 
<span style="color: #008080;">1594</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1595</span> <span style="color: #008000;">   *  @brief Class template _Bind_result is always a bind expression.
</span><span style="color: #008080;">1596</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1597</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1598</span>   template&lt;typename _Result, typename _Signature&gt;
<span style="color: #008080;">1599</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;_Bind_result&lt;_Result, _Signature&gt;&gt;
<span style="color: #008080;">1600</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1601</span> 
<span style="color: #008080;">1602</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1603</span> <span style="color: #008000;">   *  @brief Class template _Bind_result is always a bind expression.
</span><span style="color: #008080;">1604</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1605</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1606</span>   template&lt;typename _Result, typename _Signature&gt;
<span style="color: #008080;">1607</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">const</span> _Bind_result&lt;_Result, _Signature&gt;&gt;
<span style="color: #008080;">1608</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1609</span> 
<span style="color: #008080;">1610</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1611</span> <span style="color: #008000;">   *  @brief Class template _Bind_result is always a bind expression.
</span><span style="color: #008080;">1612</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1613</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1614</span>   template&lt;typename _Result, typename _Signature&gt;
<span style="color: #008080;">1615</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">volatile</span> _Bind_result&lt;_Result, _Signature&gt;&gt;
<span style="color: #008080;">1616</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1617</span> 
<span style="color: #008080;">1618</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1619</span> <span style="color: #008000;">   *  @brief Class template _Bind_result is always a bind expression.
</span><span style="color: #008080;">1620</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1621</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1622</span>   template&lt;typename _Result, typename _Signature&gt;
<span style="color: #008080;">1623</span>     <span style="color: #0000ff;">struct</span> is_bind_expression&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> _Bind_result&lt;_Result, _Signature&gt;&gt;
<span style="color: #008080;">1624</span>     : <span style="color: #0000ff;">public</span><span style="color: #000000;"> true_type { };
</span><span style="color: #008080;">1625</span> 
<span style="color: #008080;">1626</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Trait type used to remove std::bind() from overload set via SFINAE
</span><span style="color: #008080;">1627</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> when first argument has integer type, so that std::bind() will
</span><span style="color: #008080;">1628</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> not be a better match than ::bind() from the BSD Sockets API.</span>
<span style="color: #008080;">1629</span>   template&lt;typename _Tp, typename _Tp2 = typename decay&lt;_Tp&gt;::type&gt;
<span style="color: #008080;">1630</span>     <span style="color: #0000ff;">using</span> __is_socketlike = __or_&lt;is_integral&lt;_Tp2&gt;, is_enum&lt;_Tp2&gt;&gt;<span style="color: #000000;">;
</span><span style="color: #008080;">1631</span> 
<span style="color: #008080;">1632</span>   template&lt;<span style="color: #0000ff;">bool</span> _SocketLike, typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1633</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bind_helper
</span><span style="color: #008080;">1634</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1635</span>       typedef _Maybe_wrap_member_pointer&lt;typename decay&lt;_Func&gt;::type&gt;
<span style="color: #008080;">1636</span> <span style="color: #000000;">        __maybe_type;
</span><span style="color: #008080;">1637</span> <span style="color: #000000;">      typedef typename __maybe_type::type __func_type;
</span><span style="color: #008080;">1638</span>       typedef _Bind&lt;__func_type(typename decay&lt;_BoundArgs&gt;::type...)&gt;<span style="color: #000000;"> type;
</span><span style="color: #008080;">1639</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1640</span> 
<span style="color: #008080;">1641</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Partial specialization for is_socketlike == true, does not define
</span><span style="color: #008080;">1642</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> nested type so std::bind() will not participate in overload resolution
</span><span style="color: #008080;">1643</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> when the first argument might be a socket file descriptor.</span>
<span style="color: #008080;">1644</span>   template&lt;typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1645</span>     <span style="color: #0000ff;">struct</span> _Bind_helper&lt;<span style="color: #0000ff;">true</span>, _Func, _BoundArgs...&gt;
<span style="color: #008080;">1646</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">1647</span> 
<span style="color: #008080;">1648</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1649</span> <span style="color: #008000;">   *  @brief Function template for std::bind.
</span><span style="color: #008080;">1650</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1651</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1652</span>   template&lt;typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1653</span> <span style="color: #000000;">    inline typename
</span><span style="color: #008080;">1654</span>     _Bind_helper&lt;__is_socketlike&lt;_Func&gt;::value, _Func, _BoundArgs...&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;">1655</span>     bind(_Func&amp;&amp; __f, _BoundArgs&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1656</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1657</span>       typedef _Bind_helper&lt;<span style="color: #0000ff;">false</span>, _Func, _BoundArgs...&gt;<span style="color: #000000;"> __helper_type;
</span><span style="color: #008080;">1658</span> <span style="color: #000000;">      typedef typename __helper_type::__maybe_type __maybe_type;
</span><span style="color: #008080;">1659</span> <span style="color: #000000;">      typedef typename __helper_type::type __result_type;
</span><span style="color: #008080;">1660</span>       <span style="color: #0000ff;">return</span> __result_type(__maybe_type::__do_wrap(std::forward&lt;_Func&gt;<span style="color: #000000;">(__f)),
</span><span style="color: #008080;">1661</span>                            std::forward&lt;_BoundArgs&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">1662</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">1663</span> 
<span style="color: #008080;">1664</span>   template&lt;typename _Result, typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1665</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bindres_helper
</span><span style="color: #008080;">1666</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1667</span>       typedef _Maybe_wrap_member_pointer&lt;typename decay&lt;_Func&gt;::type&gt;
<span style="color: #008080;">1668</span> <span style="color: #000000;">        __maybe_type;
</span><span style="color: #008080;">1669</span> <span style="color: #000000;">      typedef typename __maybe_type::type __functor_type;
</span><span style="color: #008080;">1670</span>       typedef _Bind_result&lt;<span style="color: #000000;">_Result,
</span><span style="color: #008080;">1671</span>                            __functor_type(typename decay&lt;_BoundArgs&gt;::type...)&gt;
<span style="color: #008080;">1672</span> <span style="color: #000000;">        type;
</span><span style="color: #008080;">1673</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1674</span> 
<span style="color: #008080;">1675</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1676</span> <span style="color: #008000;">   *  @brief Function template for std::bind&lt;R&gt;.
</span><span style="color: #008080;">1677</span> <span style="color: #008000;">   *  @ingroup binders
</span><span style="color: #008080;">1678</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1679</span>   template&lt;typename _Result, typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1680</span> <span style="color: #000000;">    inline
</span><span style="color: #008080;">1681</span>     typename _Bindres_helper&lt;_Result, _Func, _BoundArgs...&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;">1682</span>     bind(_Func&amp;&amp; __f, _BoundArgs&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1683</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1684</span>       typedef _Bindres_helper&lt;_Result, _Func, _BoundArgs...&gt;<span style="color: #000000;"> __helper_type;
</span><span style="color: #008080;">1685</span> <span style="color: #000000;">      typedef typename __helper_type::__maybe_type __maybe_type;
</span><span style="color: #008080;">1686</span> <span style="color: #000000;">      typedef typename __helper_type::type __result_type;
</span><span style="color: #008080;">1687</span>       <span style="color: #0000ff;">return</span> __result_type(__maybe_type::__do_wrap(std::forward&lt;_Func&gt;<span style="color: #000000;">(__f)),
</span><span style="color: #008080;">1688</span>                            std::forward&lt;_BoundArgs&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">1689</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">1690</span> 
<span style="color: #008080;">1691</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1692</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bind_simple;
</span><span style="color: #008080;">1693</span> 
<span style="color: #008080;">1694</span>   template&lt;typename _Callable, typename... _Args&gt;
<span style="color: #008080;">1695</span>     <span style="color: #0000ff;">struct</span> _Bind_simple&lt;_Callable(_Args...)&gt;
<span style="color: #008080;">1696</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1697</span>       typedef typename result_of&lt;_Callable(_Args...)&gt;<span style="color: #000000;">::type result_type;
</span><span style="color: #008080;">1698</span> 
<span style="color: #008080;">1699</span>       template&lt;typename... _Args2, typename =<span style="color: #000000;"> typename
</span><span style="color: #008080;">1700</span>                enable_if&lt; <span style="color: #0000ff;">sizeof</span>...(_Args) == <span style="color: #0000ff;">sizeof</span>...(_Args2)&gt;::type&gt;
<span style="color: #008080;">1701</span>         <span style="color: #0000ff;">explicit</span>
<span style="color: #008080;">1702</span>         _Bind_simple(<span style="color: #0000ff;">const</span> _Callable&amp; __callable, _Args2&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1703</span>         : _M_bound(__callable, std::forward&lt;_Args2&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1704</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1705</span> 
<span style="color: #008080;">1706</span>       template&lt;typename... _Args2, typename =<span style="color: #000000;"> typename
</span><span style="color: #008080;">1707</span>                enable_if&lt; <span style="color: #0000ff;">sizeof</span>...(_Args) == <span style="color: #0000ff;">sizeof</span>...(_Args2)&gt;::type&gt;
<span style="color: #008080;">1708</span>         <span style="color: #0000ff;">explicit</span>
<span style="color: #008080;">1709</span>         _Bind_simple(_Callable&amp;&amp; __callable, _Args2&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1710</span>         : _M_bound(std::move(__callable), std::forward&lt;_Args2&gt;<span style="color: #000000;">(__args)...)
</span><span style="color: #008080;">1711</span> <span style="color: #000000;">        { }
</span><span style="color: #008080;">1712</span> 
<span style="color: #008080;">1713</span>       _Bind_simple(<span style="color: #0000ff;">const</span> _Bind_simple&amp;) = <span style="color: #0000ff;">default</span><span style="color: #000000;">;
</span><span style="color: #008080;">1714</span>       _Bind_simple(_Bind_simple&amp;&amp;) = <span style="color: #0000ff;">default</span><span style="color: #000000;">;
</span><span style="color: #008080;">1715</span> 
<span style="color: #008080;">1716</span> <span style="color: #000000;">      result_type
</span><span style="color: #008080;">1717</span>       <span style="color: #0000ff;">operator</span><span style="color: #000000;">()()
</span><span style="color: #008080;">1718</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">1719</span>         typedef typename _Build_index_tuple&lt;<span style="color: #0000ff;">sizeof</span>...(_Args)&gt;<span style="color: #000000;">::__type _Indices;
</span><span style="color: #008080;">1720</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> _M_invoke(_Indices());
</span><span style="color: #008080;">1721</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">1722</span> 
<span style="color: #008080;">1723</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;">1724</span> 
<span style="color: #008080;">1725</span>       template&lt;std::size_t... _Indices&gt;
<span style="color: #008080;">1726</span>         typename result_of&lt;_Callable(_Args...)&gt;<span style="color: #000000;">::type
</span><span style="color: #008080;">1727</span>         _M_invoke(_Index_tuple&lt;_Indices...&gt;<span style="color: #000000;">)
</span><span style="color: #008080;">1728</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1729</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> std::bind always forwards bound arguments as lvalues,
</span><span style="color: #008080;">1730</span>           <span style="color: #008000;">//</span><span style="color: #008000;"> but this type can call functions which only accept rvalues.</span>
<span style="color: #008080;">1731</span>           <span style="color: #0000ff;">return</span> std::forward&lt;_Callable&gt;(std::<span style="color: #0000ff;">get</span>&lt;<span style="color: #800080;">0</span>&gt;<span style="color: #000000;">(_M_bound))(
</span><span style="color: #008080;">1732</span>               std::forward&lt;_Args&gt;(std::<span style="color: #0000ff;">get</span>&lt;_Indices+<span style="color: #800080;">1</span>&gt;<span style="color: #000000;">(_M_bound))...);
</span><span style="color: #008080;">1733</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1734</span> 
<span style="color: #008080;">1735</span>       std::tuple&lt;_Callable, _Args...&gt;<span style="color: #000000;"> _M_bound;
</span><span style="color: #008080;">1736</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1737</span> 
<span style="color: #008080;">1738</span>   template&lt;typename _Func, typename... _BoundArgs&gt;
<span style="color: #008080;">1739</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Bind_simple_helper
</span><span style="color: #008080;">1740</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1741</span>       typedef _Maybe_wrap_member_pointer&lt;typename decay&lt;_Func&gt;::type&gt;
<span style="color: #008080;">1742</span> <span style="color: #000000;">        __maybe_type;
</span><span style="color: #008080;">1743</span> <span style="color: #000000;">      typedef typename __maybe_type::type __func_type;
</span><span style="color: #008080;">1744</span>       typedef _Bind_simple&lt;__func_type(typename decay&lt;_BoundArgs&gt;::type...)&gt;
<span style="color: #008080;">1745</span> <span style="color: #000000;">               __type;
</span><span style="color: #008080;">1746</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1747</span> 
<span style="color: #008080;">1748</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Simplified version of std::bind for internal use, without support for
</span><span style="color: #008080;">1749</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> unbound arguments, placeholders or nested bind expressions.</span>
<span style="color: #008080;">1750</span>   template&lt;typename _Callable, typename... _Args&gt;
<span style="color: #008080;">1751</span>     typename _Bind_simple_helper&lt;_Callable, _Args...&gt;<span style="color: #000000;">::__type
</span><span style="color: #008080;">1752</span>     __bind_simple(_Callable&amp;&amp; __callable, _Args&amp;&amp;<span style="color: #000000;">... __args)
</span><span style="color: #008080;">1753</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1754</span>       typedef _Bind_simple_helper&lt;_Callable, _Args...&gt;<span style="color: #000000;"> __helper_type;
</span><span style="color: #008080;">1755</span> <span style="color: #000000;">      typedef typename __helper_type::__maybe_type __maybe_type;
</span><span style="color: #008080;">1756</span> <span style="color: #000000;">      typedef typename __helper_type::__type __result_type;
</span><span style="color: #008080;">1757</span>       <span style="color: #0000ff;">return</span><span style="color: #000000;"> __result_type(
</span><span style="color: #008080;">1758</span>           __maybe_type::__do_wrap( std::forward&lt;_Callable&gt;<span style="color: #000000;">(__callable)),
</span><span style="color: #008080;">1759</span>           std::forward&lt;_Args&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">1760</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">1761</span> 
<span style="color: #008080;">1762</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1763</span> <span style="color: #008000;">   *  @brief Exception class thrown when class template function's
</span><span style="color: #008080;">1764</span> <span style="color: #008000;">   *  operator() is called with an empty target.
</span><span style="color: #008080;">1765</span> <span style="color: #008000;">   *  @ingroup exceptions
</span><span style="color: #008080;">1766</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1767</span>   <span style="color: #0000ff;">class</span> bad_function_call : <span style="color: #0000ff;">public</span><span style="color: #000000;"> std::exception
</span><span style="color: #008080;">1768</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">1769</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1770</span>     <span style="color: #0000ff;">virtual</span> ~<span style="color: #000000;">bad_function_call() noexcept;
</span><span style="color: #008080;">1771</span> 
<span style="color: #008080;">1772</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* what() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;">1773</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">1774</span> 
<span style="color: #008080;">1775</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">1776</span> <span style="color: #008000;">   *  Trait identifying "location-invariant" types, meaning that the
</span><span style="color: #008080;">1777</span> <span style="color: #008000;">   *  address of the object (or any of its members) will not escape.
</span><span style="color: #008080;">1778</span> <span style="color: #008000;">   *  Also implies a trivial copy constructor and assignment operator.
</span><span style="color: #008080;">1779</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">1780</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">1781</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> __is_location_invariant
</span><span style="color: #008080;">1782</span>     : integral_constant&lt;<span style="color: #0000ff;">bool</span>, (is_pointer&lt;_Tp&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;">1783</span>                                || is_member_pointer&lt;_Tp&gt;::value)&gt;
<span style="color: #008080;">1784</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">1785</span> 
<span style="color: #008080;">1786</span>   <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Undefined_class;
</span><span style="color: #008080;">1787</span> 
<span style="color: #008080;">1788</span> <span style="color: #000000;">  union _Nocopy_types
</span><span style="color: #008080;">1789</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">1790</span>     <span style="color: #0000ff;">void</span>*<span style="color: #000000;">       _M_object;
</span><span style="color: #008080;">1791</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>*<span style="color: #000000;"> _M_const_object;
</span><span style="color: #008080;">1792</span>     <span style="color: #0000ff;">void</span> (*<span style="color: #000000;">_M_function_pointer)();
</span><span style="color: #008080;">1793</span>     <span style="color: #0000ff;">void</span> (_Undefined_class::*<span style="color: #000000;">_M_member_pointer)();
</span><span style="color: #008080;">1794</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">1795</span> 
<span style="color: #008080;">1796</span> <span style="color: #000000;">  union _Any_data
</span><span style="color: #008080;">1797</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">1798</span>     <span style="color: #0000ff;">void</span>*       _M_access()       { <span style="color: #0000ff;">return</span> &amp;_M_pod_data[<span style="color: #800080;">0</span><span style="color: #000000;">]; }
</span><span style="color: #008080;">1799</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* _M_access() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> &amp;_M_pod_data[<span style="color: #800080;">0</span><span style="color: #000000;">]; }
</span><span style="color: #008080;">1800</span> 
<span style="color: #008080;">1801</span>     template&lt;typename _Tp&gt;
<span style="color: #008080;">1802</span>       _Tp&amp;
<span style="color: #008080;">1803</span> <span style="color: #000000;">      _M_access()
</span><span style="color: #008080;">1804</span>       { <span style="color: #0000ff;">return</span> *static_cast&lt;_Tp*&gt;<span style="color: #000000;">(_M_access()); }
</span><span style="color: #008080;">1805</span> 
<span style="color: #008080;">1806</span>     template&lt;typename _Tp&gt;
<span style="color: #008080;">1807</span>       <span style="color: #0000ff;">const</span> _Tp&amp;
<span style="color: #008080;">1808</span>       _M_access() <span style="color: #0000ff;">const</span>
<span style="color: #008080;">1809</span>       { <span style="color: #0000ff;">return</span> *static_cast&lt;<span style="color: #0000ff;">const</span> _Tp*&gt;<span style="color: #000000;">(_M_access()); }
</span><span style="color: #008080;">1810</span> 
<span style="color: #008080;">1811</span> <span style="color: #000000;">    _Nocopy_types _M_unused;
</span><span style="color: #008080;">1812</span>     <span style="color: #0000ff;">char</span> _M_pod_data[<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(_Nocopy_types)];
</span><span style="color: #008080;">1813</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">1814</span> 
<span style="color: #008080;">1815</span>   <span style="color: #0000ff;">enum</span><span style="color: #000000;"> _Manager_operation
</span><span style="color: #008080;">1816</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">1817</span> <span style="color: #000000;">    __get_type_info,
</span><span style="color: #008080;">1818</span> <span style="color: #000000;">    __get_functor_ptr,
</span><span style="color: #008080;">1819</span> <span style="color: #000000;">    __clone_functor,
</span><span style="color: #008080;">1820</span> <span style="color: #000000;">    __destroy_functor
</span><span style="color: #008080;">1821</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">1822</span> 
<span style="color: #008080;">1823</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Simple type wrapper that helps avoid annoying const problems
</span><span style="color: #008080;">1824</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> when casting between void pointers and pointers-to-pointers.</span>
<span style="color: #008080;">1825</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">1826</span>     <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Simple_type_wrapper
</span><span style="color: #008080;">1827</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">1828</span> <span style="color: #000000;">      _Simple_type_wrapper(_Tp __value) : __value(__value) { }
</span><span style="color: #008080;">1829</span> 
<span style="color: #008080;">1830</span> <span style="color: #000000;">      _Tp __value;
</span><span style="color: #008080;">1831</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">1832</span> 
<span style="color: #008080;">1833</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">1834</span>     <span style="color: #0000ff;">struct</span> __is_location_invariant&lt;_Simple_type_wrapper&lt;_Tp&gt; &gt;
<span style="color: #008080;">1835</span>     : __is_location_invariant&lt;_Tp&gt;
<span style="color: #008080;">1836</span> <span style="color: #000000;">    { };
</span><span style="color: #008080;">1837</span> 
<span style="color: #008080;">1838</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Converts a reference to a function object into a callable
</span><span style="color: #008080;">1839</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> function object.</span>
<span style="color: #008080;">1840</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">1841</span>     inline _Functor&amp;
<span style="color: #008080;">1842</span>     __callable_functor(_Functor&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;">1843</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __f; }
</span><span style="color: #008080;">1844</span> 
<span style="color: #008080;">1845</span>   template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">1846</span>     inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">1847</span>     __callable_functor(_Member _Class::* &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">1848</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">1849</span> 
<span style="color: #008080;">1850</span>   template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">1851</span>     inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">1852</span>     __callable_functor(_Member _Class::* <span style="color: #0000ff;">const</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">1853</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">1854</span> 
<span style="color: #008080;">1855</span>   template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">1856</span>     inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">1857</span>     __callable_functor(_Member _Class::* <span style="color: #0000ff;">volatile</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">1858</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">1859</span> 
<span style="color: #008080;">1860</span>   template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">1861</span>     inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">1862</span>     __callable_functor(_Member _Class::* <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">1863</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">1864</span> 
<span style="color: #008080;">1865</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;">1866</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> function;
</span><span style="color: #008080;">1867</span> 
<span style="color: #008080;">1868</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> Base class of all polymorphic function object wrappers.</span>
<span style="color: #008080;">1869</span>   <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Function_base
</span><span style="color: #008080;">1870</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">1871</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1872</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> std::size_t _M_max_size = <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(_Nocopy_types);
</span><span style="color: #008080;">1873</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> std::size_t _M_max_align =<span style="color: #000000;"> __alignof__(_Nocopy_types);
</span><span style="color: #008080;">1874</span> 
<span style="color: #008080;">1875</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;">1876</span>       <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Base_manager
</span><span style="color: #008080;">1877</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">1878</span>       <span style="color: #0000ff;">protected</span><span style="color: #000000;">:
</span><span style="color: #008080;">1879</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> __stored_locally =
<span style="color: #008080;">1880</span>         (__is_location_invariant&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;">1881</span>          &amp;&amp; <span style="color: #0000ff;">sizeof</span>(_Functor) &lt;=<span style="color: #000000;"> _M_max_size
</span><span style="color: #008080;">1882</span>          &amp;&amp; __alignof__(_Functor) &lt;=<span style="color: #000000;"> _M_max_align
</span><span style="color: #008080;">1883</span>          &amp;&amp; (_M_max_align % __alignof__(_Functor) == <span style="color: #800080;">0</span><span style="color: #000000;">));
</span><span style="color: #008080;">1884</span> 
<span style="color: #008080;">1885</span>         typedef integral_constant&lt;<span style="color: #0000ff;">bool</span>, __stored_locally&gt;<span style="color: #000000;"> _Local_storage;
</span><span style="color: #008080;">1886</span> 
<span style="color: #008080;">1887</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Retrieve a pointer to the function object</span>
<span style="color: #008080;">1888</span>         <span style="color: #0000ff;">static</span> _Functor*
<span style="color: #008080;">1889</span>         _M_get_pointer(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source)
</span><span style="color: #008080;">1890</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1891</span>           <span style="color: #0000ff;">const</span> _Functor* __ptr =
<span style="color: #008080;">1892</span>             __stored_locally? std::__addressof(__source._M_access&lt;_Functor&gt;<span style="color: #000000;">())
</span><span style="color: #008080;">1893</span>             <span style="color: #008000;">/*</span><span style="color: #008000;"> have stored a pointer </span><span style="color: #008000;">*/</span> : __source._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">1894</span>           <span style="color: #0000ff;">return</span> const_cast&lt;_Functor*&gt;<span style="color: #000000;">(__ptr);
</span><span style="color: #008080;">1895</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1896</span> 
<span style="color: #008080;">1897</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Clone a location-invariant function object that fits within
</span><span style="color: #008080;">1898</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> an _Any_data structure.</span>
<span style="color: #008080;">1899</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1900</span>         _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, true_type)
</span><span style="color: #008080;">1901</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1902</span>           <span style="color: #0000ff;">new</span> (__dest._M_access()) _Functor(__source._M_access&lt;_Functor&gt;<span style="color: #000000;">());
</span><span style="color: #008080;">1903</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1904</span> 
<span style="color: #008080;">1905</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Clone a function object that is not location-invariant or
</span><span style="color: #008080;">1906</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> that cannot fit into an _Any_data structure.</span>
<span style="color: #008080;">1907</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1908</span>         _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, false_type)
</span><span style="color: #008080;">1909</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1910</span>           __dest._M_access&lt;_Functor*&gt;() =
<span style="color: #008080;">1911</span>             <span style="color: #0000ff;">new</span> _Functor(*__source._M_access&lt;_Functor*&gt;<span style="color: #000000;">());
</span><span style="color: #008080;">1912</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1913</span> 
<span style="color: #008080;">1914</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Destroying a location-invariant object may still require
</span><span style="color: #008080;">1915</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> destruction.</span>
<span style="color: #008080;">1916</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1917</span>         _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, true_type)
</span><span style="color: #008080;">1918</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1919</span>           __victim._M_access&lt;_Functor&gt;().~<span style="color: #000000;">_Functor();
</span><span style="color: #008080;">1920</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1921</span> 
<span style="color: #008080;">1922</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> Destroying an object located on the heap.</span>
<span style="color: #008080;">1923</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1924</span>         _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, false_type)
</span><span style="color: #008080;">1925</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1926</span>           <span style="color: #0000ff;">delete</span> __victim._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">1927</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1928</span> 
<span style="color: #008080;">1929</span>       <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1930</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1931</span>         _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">1932</span> <span style="color: #000000;">                   _Manager_operation __op)
</span><span style="color: #008080;">1933</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">1934</span>           <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;">1935</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">1936</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">1937</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">1938</span>               __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">1939</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">1940</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">1941</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">1942</span>               __dest._M_access&lt;_Functor*&gt;() =<span style="color: #000000;"> _M_get_pointer(__source);
</span><span style="color: #008080;">1943</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">1944</span> 
<span style="color: #008080;">1945</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __clone_functor:
</span><span style="color: #008080;">1946</span> <span style="color: #000000;">              _M_clone(__dest, __source, _Local_storage());
</span><span style="color: #008080;">1947</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">1948</span> 
<span style="color: #008080;">1949</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __destroy_functor:
</span><span style="color: #008080;">1950</span> <span style="color: #000000;">              _M_destroy(__dest, _Local_storage());
</span><span style="color: #008080;">1951</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">1952</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">1953</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">1954</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">1955</span> 
<span style="color: #008080;">1956</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1957</span>         _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;">1958</span> <span style="color: #000000;">        { _M_init_functor(__functor, std::move(__f), _Local_storage()); }
</span><span style="color: #008080;">1959</span> 
<span style="color: #008080;">1960</span>         template&lt;typename _Signature&gt;
<span style="color: #008080;">1961</span>           <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1962</span>           _M_not_empty_function(<span style="color: #0000ff;">const</span> function&lt;_Signature&gt;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;">1963</span>           { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">1964</span> 
<span style="color: #008080;">1965</span>         template&lt;typename _Tp&gt;
<span style="color: #008080;">1966</span>           <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1967</span>           _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp*&amp;<span style="color: #000000;"> __fp)
</span><span style="color: #008080;">1968</span>           { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __fp; }
</span><span style="color: #008080;">1969</span> 
<span style="color: #008080;">1970</span>         template&lt;typename _Class, typename _Tp&gt;
<span style="color: #008080;">1971</span>           <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1972</span>           _M_not_empty_function(_Tp _Class::* <span style="color: #0000ff;">const</span>&amp;<span style="color: #000000;"> __mp)
</span><span style="color: #008080;">1973</span>           { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __mp; }
</span><span style="color: #008080;">1974</span> 
<span style="color: #008080;">1975</span>         template&lt;typename _Tp&gt;
<span style="color: #008080;">1976</span>           <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1977</span>           _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;">)
</span><span style="color: #008080;">1978</span>           { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">; }
</span><span style="color: #008080;">1979</span> 
<span style="color: #008080;">1980</span>       <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;">1981</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1982</span>         _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, true_type)
</span><span style="color: #008080;">1983</span>         { <span style="color: #0000ff;">new</span><span style="color: #000000;"> (__functor._M_access()) _Functor(std::move(__f)); }
</span><span style="color: #008080;">1984</span> 
<span style="color: #008080;">1985</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">1986</span>         _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, false_type)
</span><span style="color: #008080;">1987</span>         { __functor._M_access&lt;_Functor*&gt;() = <span style="color: #0000ff;">new</span><span style="color: #000000;"> _Functor(std::move(__f)); }
</span><span style="color: #008080;">1988</span> <span style="color: #000000;">      };
</span><span style="color: #008080;">1989</span> 
<span style="color: #008080;">1990</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;">1991</span>       <span style="color: #0000ff;">class</span> _Ref_manager : <span style="color: #0000ff;">public</span> _Base_manager&lt;_Functor*&gt;
<span style="color: #008080;">1992</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">1993</span>         typedef _Function_base::_Base_manager&lt;_Functor*&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">1994</span> 
<span style="color: #008080;">1995</span>       <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">1996</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">1997</span>         _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">1998</span> <span style="color: #000000;">                   _Manager_operation __op)
</span><span style="color: #008080;">1999</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2000</span>           <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;">2001</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">2002</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">2003</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">2004</span>               __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">2005</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">2006</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">2007</span>             <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">2008</span>               __dest._M_access&lt;_Functor*&gt;() = *<span style="color: #000000;">_Base::_M_get_pointer(__source);
</span><span style="color: #008080;">2009</span>               <span style="color: #0000ff;">return</span> is_const&lt;_Functor&gt;<span style="color: #000000;">::value;
</span><span style="color: #008080;">2010</span>               <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">2011</span> 
<span style="color: #008080;">2012</span>             <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;">2013</span> <span style="color: #000000;">              _Base::_M_manager(__dest, __source, __op);
</span><span style="color: #008080;">2014</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">2015</span>           <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">2016</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2017</span> 
<span style="color: #008080;">2018</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">2019</span>         _M_init_functor(_Any_data&amp; __functor, reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f)
</span><span style="color: #008080;">2020</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2021</span>           _Base::_M_init_functor(__functor, std::__addressof(__f.<span style="color: #0000ff;">get</span><span style="color: #000000;">()));
</span><span style="color: #008080;">2022</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2023</span> <span style="color: #000000;">      };
</span><span style="color: #008080;">2024</span> 
<span style="color: #008080;">2025</span>     _Function_base() : _M_manager(<span style="color: #800080;">0</span><span style="color: #000000;">) { }
</span><span style="color: #008080;">2026</span> 
<span style="color: #008080;">2027</span>     ~<span style="color: #000000;">_Function_base()
</span><span style="color: #008080;">2028</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2029</span>       <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;">2030</span> <span style="color: #000000;">        _M_manager(_M_functor, _M_functor, __destroy_functor);
</span><span style="color: #008080;">2031</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">2032</span> 
<span style="color: #008080;">2033</span> 
<span style="color: #008080;">2034</span>     <span style="color: #0000ff;">bool</span> _M_empty() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> !<span style="color: #000000;">_M_manager; }
</span><span style="color: #008080;">2035</span> 
<span style="color: #008080;">2036</span>     typedef <span style="color: #0000ff;">bool</span> (*_Manager_type)(_Any_data&amp;, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;">,
</span><span style="color: #008080;">2037</span> <span style="color: #000000;">                                  _Manager_operation);
</span><span style="color: #008080;">2038</span> 
<span style="color: #008080;">2039</span> <span style="color: #000000;">    _Any_data     _M_functor;
</span><span style="color: #008080;">2040</span> <span style="color: #000000;">    _Manager_type _M_manager;
</span><span style="color: #008080;">2041</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">2042</span> 
<span style="color: #008080;">2043</span>   template&lt;typename _Signature, typename _Functor&gt;
<span style="color: #008080;">2044</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Function_handler;
</span><span style="color: #008080;">2045</span> 
<span style="color: #008080;">2046</span>   template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">2047</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt;
<span style="color: #008080;">2048</span>     : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;_Functor&gt;
<span style="color: #008080;">2049</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2050</span>       typedef _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">2051</span> 
<span style="color: #008080;">2052</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2053</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">2054</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2055</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2056</span>         <span style="color: #0000ff;">return</span> (*<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">2057</span>             std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2058</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2059</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2060</span> 
<span style="color: #008080;">2061</span>   template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">2062</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Functor&gt;
<span style="color: #008080;">2063</span>     : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;_Functor&gt;
<span style="color: #008080;">2064</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2065</span>       typedef _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">2066</span> 
<span style="color: #008080;">2067</span>      <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2068</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">2069</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2070</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2071</span>         (*<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">2072</span>             std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2073</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2074</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2075</span> 
<span style="color: #008080;">2076</span>   template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">2077</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;
<span style="color: #008080;">2078</span>     : <span style="color: #0000ff;">public</span> _Function_base::_Ref_manager&lt;_Functor&gt;
<span style="color: #008080;">2079</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2080</span>       typedef _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">2081</span> 
<span style="color: #008080;">2082</span>      <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2083</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">2084</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2085</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2086</span>         <span style="color: #0000ff;">return</span> __callable_functor(**<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">2087</span>               std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2088</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2089</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2090</span> 
<span style="color: #008080;">2091</span>   template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">2092</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;
<span style="color: #008080;">2093</span>     : <span style="color: #0000ff;">public</span> _Function_base::_Ref_manager&lt;_Functor&gt;
<span style="color: #008080;">2094</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2095</span>       typedef _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">2096</span> 
<span style="color: #008080;">2097</span>      <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2098</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">2099</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2100</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2101</span>         __callable_functor(**<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">2102</span>             std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2103</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2104</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2105</span> 
<span style="color: #008080;">2106</span>   template&lt;<span style="color: #000000;">typename _Class, typename _Member, typename _Res,
</span><span style="color: #008080;">2107</span>            typename... _ArgTypes&gt;
<span style="color: #008080;">2108</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">2109</span>     : <span style="color: #0000ff;">public</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">2110</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2111</span>       typedef _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">2112</span> <span style="color: #000000;">        _Base;
</span><span style="color: #008080;">2113</span> 
<span style="color: #008080;">2114</span>      <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2115</span>       <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">2116</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2117</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2118</span>         <span style="color: #0000ff;">return</span> std::mem_fn(_Base::_M_get_pointer(__functor)-&gt;<span style="color: #000000;">__value)(
</span><span style="color: #008080;">2119</span>             std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2120</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2121</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2122</span> 
<span style="color: #008080;">2123</span>   template&lt;typename _Class, typename _Member, typename... _ArgTypes&gt;
<span style="color: #008080;">2124</span>     <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">2125</span>     : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;
<span style="color: #008080;">2126</span>                  _Simple_type_wrapper&lt; _Member _Class::* &gt; &gt;
<span style="color: #008080;">2127</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2128</span>       typedef _Member _Class::*<span style="color: #000000;"> _Functor;
</span><span style="color: #008080;">2129</span>       typedef _Simple_type_wrapper&lt;_Functor&gt;<span style="color: #000000;"> _Wrapper;
</span><span style="color: #008080;">2130</span>       typedef _Function_base::_Base_manager&lt;_Wrapper&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">2131</span> 
<span style="color: #008080;">2132</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2133</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">2134</span>       _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">2135</span> <span style="color: #000000;">                 _Manager_operation __op)
</span><span style="color: #008080;">2136</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2137</span>         <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;">2138</span> <span style="color: #000000;">          {
</span><span style="color: #008080;">2139</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">2140</span>           <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">2141</span>             __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">2142</span>             <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">2143</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">2144</span>           <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">2145</span>             __dest._M_access&lt;_Functor*&gt;() =
<span style="color: #008080;">2146</span>               &amp;_Base::_M_get_pointer(__source)-&gt;<span style="color: #000000;">__value;
</span><span style="color: #008080;">2147</span>             <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">2148</span> 
<span style="color: #008080;">2149</span>           <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;">2150</span> <span style="color: #000000;">            _Base::_M_manager(__dest, __source, __op);
</span><span style="color: #008080;">2151</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">2152</span>         <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">2153</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2154</span> 
<span style="color: #008080;">2155</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">2156</span>       _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">2157</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2158</span>         std::mem_fn(_Base::_M_get_pointer(__functor)-&gt;<span style="color: #000000;">__value)(
</span><span style="color: #008080;">2159</span>             std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2160</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2161</span> <span style="color: #000000;">    };
</span><span style="color: #008080;">2162</span> 
<span style="color: #008080;">2163</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2164</span> <span style="color: #008000;">   *  @brief Primary class template for std::function.
</span><span style="color: #008080;">2165</span> <span style="color: #008000;">   *  @ingroup functors
</span><span style="color: #008080;">2166</span> <span style="color: #008000;">   *
</span><span style="color: #008080;">2167</span> <span style="color: #008000;">   *  Polymorphic function wrapper.
</span><span style="color: #008080;">2168</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">2169</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2170</span>     <span style="color: #0000ff;">class</span> function&lt;_Res(_ArgTypes...)&gt;
<span style="color: #008080;">2171</span>     : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, _ArgTypes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">2172</span>       <span style="color: #0000ff;">private</span><span style="color: #000000;"> _Function_base
</span><span style="color: #008080;">2173</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2174</span> <span style="color: #000000;">      typedef _Res _Signature_type(_ArgTypes...);
</span><span style="color: #008080;">2175</span> 
<span style="color: #008080;">2176</span>       template&lt;typename _Functor&gt;
<span style="color: #008080;">2177</span>         <span style="color: #0000ff;">using</span> _Invoke = decltype(__callable_functor(std::declval&lt;_Functor&amp;&gt;<span style="color: #000000;">())
</span><span style="color: #008080;">2178</span>                                  (std::declval&lt;_ArgTypes&gt;<span style="color: #000000;">()...) );
</span><span style="color: #008080;">2179</span> 
<span style="color: #008080;">2180</span>       template&lt;typename _CallRes, typename _Res1&gt;
<span style="color: #008080;">2181</span>         <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _CheckResult
</span><span style="color: #008080;">2182</span>         : is_convertible&lt;_CallRes, _Res1&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;">2183</span> 
<span style="color: #008080;">2184</span>       template&lt;typename _CallRes&gt;
<span style="color: #008080;">2185</span>         <span style="color: #0000ff;">struct</span> _CheckResult&lt;_CallRes, <span style="color: #0000ff;">void</span>&gt;
<span style="color: #008080;">2186</span> <span style="color: #000000;">        : true_type { };
</span><span style="color: #008080;">2187</span> 
<span style="color: #008080;">2188</span>       template&lt;typename _Functor&gt;
<span style="color: #008080;">2189</span>         <span style="color: #0000ff;">using</span> _Callable = _CheckResult&lt;_Invoke&lt;_Functor&gt;, _Res&gt;<span style="color: #000000;">;
</span><span style="color: #008080;">2190</span> 
<span style="color: #008080;">2191</span>       template&lt;typename _Cond, typename _Tp&gt;
<span style="color: #008080;">2192</span>         <span style="color: #0000ff;">using</span> _Requires = typename enable_if&lt;_Cond::value, _Tp&gt;<span style="color: #000000;">::type;
</span><span style="color: #008080;">2193</span> 
<span style="color: #008080;">2194</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">2195</span> <span style="color: #000000;">      typedef _Res result_type;
</span><span style="color: #008080;">2196</span> 
<span style="color: #008080;">2197</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> [3.7.2.1] construct/copy/destroy</span>
<span style="color: #008080;">2198</span> 
<span style="color: #008080;">2199</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2200</span> <span style="color: #008000;">       *  @brief Default construct creates an empty function call wrapper.
</span><span style="color: #008080;">2201</span> <span style="color: #008000;">       *  @post @c !(bool)*this
</span><span style="color: #008080;">2202</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2203</span> <span style="color: #000000;">      function() noexcept
</span><span style="color: #008080;">2204</span> <span style="color: #000000;">      : _Function_base() { }
</span><span style="color: #008080;">2205</span> 
<span style="color: #008080;">2206</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2207</span> <span style="color: #008000;">       *  @brief Creates an empty function call wrapper.
</span><span style="color: #008080;">2208</span> <span style="color: #008000;">       *  @post @c !(bool)*this
</span><span style="color: #008080;">2209</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2210</span> <span style="color: #000000;">      function(nullptr_t) noexcept
</span><span style="color: #008080;">2211</span> <span style="color: #000000;">      : _Function_base() { }
</span><span style="color: #008080;">2212</span> 
<span style="color: #008080;">2213</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2214</span> <span style="color: #008000;">       *  @brief %Function copy constructor.
</span><span style="color: #008080;">2215</span> <span style="color: #008000;">       *  @param __x A %function object with identical call signature.
</span><span style="color: #008080;">2216</span> <span style="color: #008000;">       *  @post @c bool(*this) == bool(__x)
</span><span style="color: #008080;">2217</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2218</span> <span style="color: #008000;">       *  The newly-created %function contains a copy of the target of @a
</span><span style="color: #008080;">2219</span> <span style="color: #008000;">       *  __x (if it has one).
</span><span style="color: #008080;">2220</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2221</span>       function(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;">2222</span> 
<span style="color: #008080;">2223</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2224</span> <span style="color: #008000;">       *  @brief %Function move constructor.
</span><span style="color: #008080;">2225</span> <span style="color: #008000;">       *  @param __x A %function object rvalue with identical call signature.
</span><span style="color: #008080;">2226</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2227</span> <span style="color: #008000;">       *  The newly-created %function contains the target of @a __x
</span><span style="color: #008080;">2228</span> <span style="color: #008000;">       *  (if it has one).
</span><span style="color: #008080;">2229</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2230</span>       function(function&amp;&amp;<span style="color: #000000;"> __x) : _Function_base()
</span><span style="color: #008080;">2231</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2232</span>         __x.swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">2233</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2234</span> 
<span style="color: #008080;">2235</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> TODO: needs allocator_arg_t</span>
<span style="color: #008080;">2236</span> 
<span style="color: #008080;">2237</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2238</span> <span style="color: #008000;">       *  @brief Builds a %function that targets a copy of the incoming
</span><span style="color: #008080;">2239</span> <span style="color: #008000;">       *  function object.
</span><span style="color: #008080;">2240</span> <span style="color: #008000;">       *  @param __f A %function object that is callable with parameters of
</span><span style="color: #008080;">2241</span> <span style="color: #008000;">       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
</span><span style="color: #008080;">2242</span> <span style="color: #008000;">       *  to @c Res.
</span><span style="color: #008080;">2243</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2244</span> <span style="color: #008000;">       *  The newly-created %function object will target a copy of 
</span><span style="color: #008080;">2245</span> <span style="color: #008000;">       *  @a __f. If @a __f is @c reference_wrapper&lt;F&gt;, then this function
</span><span style="color: #008080;">2246</span> <span style="color: #008000;">       *  object will contain a reference to the function object @c
</span><span style="color: #008080;">2247</span> <span style="color: #008000;">       *  __f.get(). If @a __f is a NULL function pointer or NULL
</span><span style="color: #008080;">2248</span> <span style="color: #008000;">       *  pointer-to-member, the newly-created object will be empty.
</span><span style="color: #008080;">2249</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2250</span> <span style="color: #008000;">       *  If @a __f is a non-NULL function pointer or an object of type @c
</span><span style="color: #008080;">2251</span> <span style="color: #008000;">       *  reference_wrapper&lt;F&gt;, this function will not throw.
</span><span style="color: #008080;">2252</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2253</span>       template&lt;<span style="color: #000000;">typename _Functor,
</span><span style="color: #008080;">2254</span>                typename = _Requires&lt;_Callable&lt;_Functor&gt;, <span style="color: #0000ff;">void</span>&gt;&gt;
<span style="color: #008080;">2255</span> <span style="color: #000000;">        function(_Functor);
</span><span style="color: #008080;">2256</span> 
<span style="color: #008080;">2257</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2258</span> <span style="color: #008000;">       *  @brief %Function assignment operator.
</span><span style="color: #008080;">2259</span> <span style="color: #008000;">       *  @param __x A %function with identical call signature.
</span><span style="color: #008080;">2260</span> <span style="color: #008000;">       *  @post @c (bool)*this == (bool)x
</span><span style="color: #008080;">2261</span> <span style="color: #008000;">       *  @returns @c *this
</span><span style="color: #008080;">2262</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2263</span> <span style="color: #008000;">       *  The target of @a __x is copied to @c *this. If @a __x has no
</span><span style="color: #008080;">2264</span> <span style="color: #008000;">       *  target, then @c *this will be empty.
</span><span style="color: #008080;">2265</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2266</span> <span style="color: #008000;">       *  If @a __x targets a function pointer or a reference to a function
</span><span style="color: #008080;">2267</span> <span style="color: #008000;">       *  object, then this operation will not throw an %exception.
</span><span style="color: #008080;">2268</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2269</span>       function&amp;
<span style="color: #008080;">2270</span>       <span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">2271</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2272</span>         function(__x).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">2273</span>         <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">2274</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2275</span> 
<span style="color: #008080;">2276</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2277</span> <span style="color: #008000;">       *  @brief %Function move-assignment operator.
</span><span style="color: #008080;">2278</span> <span style="color: #008000;">       *  @param __x A %function rvalue with identical call signature.
</span><span style="color: #008080;">2279</span> <span style="color: #008000;">       *  @returns @c *this
</span><span style="color: #008080;">2280</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2281</span> <span style="color: #008000;">       *  The target of @a __x is moved to @c *this. If @a __x has no
</span><span style="color: #008080;">2282</span> <span style="color: #008000;">       *  target, then @c *this will be empty.
</span><span style="color: #008080;">2283</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2284</span> <span style="color: #008000;">       *  If @a __x targets a function pointer or a reference to a function
</span><span style="color: #008080;">2285</span> <span style="color: #008000;">       *  object, then this operation will not throw an %exception.
</span><span style="color: #008080;">2286</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2287</span>       function&amp;
<span style="color: #008080;">2288</span>       <span style="color: #0000ff;">operator</span>=(function&amp;&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">2289</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2290</span>         function(std::move(__x)).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">2291</span>         <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">2292</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2293</span> 
<span style="color: #008080;">2294</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2295</span> <span style="color: #008000;">       *  @brief %Function assignment to zero.
</span><span style="color: #008080;">2296</span> <span style="color: #008000;">       *  @post @c !(bool)*this
</span><span style="color: #008080;">2297</span> <span style="color: #008000;">       *  @returns @c *this
</span><span style="color: #008080;">2298</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2299</span> <span style="color: #008000;">       *  The target of @c *this is deallocated, leaving it empty.
</span><span style="color: #008080;">2300</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2301</span>       function&amp;
<span style="color: #008080;">2302</span>       <span style="color: #0000ff;">operator</span>=<span style="color: #000000;">(nullptr_t)
</span><span style="color: #008080;">2303</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2304</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;">2305</span> <span style="color: #000000;">          {
</span><span style="color: #008080;">2306</span> <span style="color: #000000;">            _M_manager(_M_functor, _M_functor, __destroy_functor);
</span><span style="color: #008080;">2307</span>             _M_manager = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2308</span>             _M_invoker = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2309</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">2310</span>         <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">2311</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2312</span> 
<span style="color: #008080;">2313</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2314</span> <span style="color: #008000;">       *  @brief %Function assignment to a new target.
</span><span style="color: #008080;">2315</span> <span style="color: #008000;">       *  @param __f A %function object that is callable with parameters of
</span><span style="color: #008080;">2316</span> <span style="color: #008000;">       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
</span><span style="color: #008080;">2317</span> <span style="color: #008000;">       *  to @c Res.
</span><span style="color: #008080;">2318</span> <span style="color: #008000;">       *  @return @c *this
</span><span style="color: #008080;">2319</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2320</span> <span style="color: #008000;">       *  This  %function object wrapper will target a copy of @a
</span><span style="color: #008080;">2321</span> <span style="color: #008000;">       *  __f. If @a __f is @c reference_wrapper&lt;F&gt;, then this function
</span><span style="color: #008080;">2322</span> <span style="color: #008000;">       *  object will contain a reference to the function object @c
</span><span style="color: #008080;">2323</span> <span style="color: #008000;">       *  __f.get(). If @a __f is a NULL function pointer or NULL
</span><span style="color: #008080;">2324</span> <span style="color: #008000;">       *  pointer-to-member, @c this object will be empty.
</span><span style="color: #008080;">2325</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2326</span> <span style="color: #008000;">       *  If @a __f is a non-NULL function pointer or an object of type @c
</span><span style="color: #008080;">2327</span> <span style="color: #008000;">       *  reference_wrapper&lt;F&gt;, this function will not throw.
</span><span style="color: #008080;">2328</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2329</span>       template&lt;typename _Functor&gt;
<span style="color: #008080;">2330</span>         _Requires&lt;_Callable&lt;_Functor&gt;, function&amp;&gt;
<span style="color: #008080;">2331</span>         <span style="color: #0000ff;">operator</span>=(_Functor&amp;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;">2332</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2333</span>           function(std::forward&lt;_Functor&gt;(__f)).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">2334</span>           <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">2335</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2336</span> 
<span style="color: #008080;">2337</span>       <span style="color: #808080;">///</span><span style="color: #008000;"> @overload</span>
<span style="color: #008080;">2338</span>       template&lt;typename _Functor&gt;
<span style="color: #008080;">2339</span>         function&amp;
<span style="color: #008080;">2340</span>         <span style="color: #0000ff;">operator</span>=(reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;">2341</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2342</span>           function(__f).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;">2343</span>           <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;">2344</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2345</span> 
<span style="color: #008080;">2346</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> [3.7.2.2] function modifiers</span>
<span style="color: #008080;">2347</span> 
<span style="color: #008080;">2348</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2349</span> <span style="color: #008000;">       *  @brief Swap the targets of two %function objects.
</span><span style="color: #008080;">2350</span> <span style="color: #008000;">       *  @param __x A %function with identical call signature.
</span><span style="color: #008080;">2351</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2352</span> <span style="color: #008000;">       *  Swap the targets of @c this function object and @a __f. This
</span><span style="color: #008080;">2353</span> <span style="color: #008000;">       *  function will not throw an %exception.
</span><span style="color: #008080;">2354</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2355</span>       <span style="color: #0000ff;">void</span> swap(function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">2356</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2357</span> <span style="color: #000000;">        std::swap(_M_functor, __x._M_functor);
</span><span style="color: #008080;">2358</span> <span style="color: #000000;">        std::swap(_M_manager, __x._M_manager);
</span><span style="color: #008080;">2359</span> <span style="color: #000000;">        std::swap(_M_invoker, __x._M_invoker);
</span><span style="color: #008080;">2360</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2361</span> 
<span style="color: #008080;">2362</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> TODO: needs allocator_arg_t</span>
<span style="color: #008080;">2363</span>       <span style="color: #008000;">/*</span>
<span style="color: #008080;">2364</span> <span style="color: #008000;">      template&lt;typename _Functor, typename _Alloc&gt;
</span><span style="color: #008080;">2365</span> <span style="color: #008000;">        void
</span><span style="color: #008080;">2366</span> <span style="color: #008000;">        assign(_Functor&amp;&amp; __f, const _Alloc&amp; __a)
</span><span style="color: #008080;">2367</span> <span style="color: #008000;">        {
</span><span style="color: #008080;">2368</span> <span style="color: #008000;">          function(allocator_arg, __a,
</span><span style="color: #008080;">2369</span> <span style="color: #008000;">                   std::forward&lt;_Functor&gt;(__f)).swap(*this);
</span><span style="color: #008080;">2370</span> <span style="color: #008000;">        }
</span><span style="color: #008080;">2371</span>       <span style="color: #008000;">*/</span>
<span style="color: #008080;">2372</span> 
<span style="color: #008080;">2373</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> [3.7.2.3] function capacity</span>
<span style="color: #008080;">2374</span> 
<span style="color: #008080;">2375</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2376</span> <span style="color: #008000;">       *  @brief Determine if the %function wrapper has a target.
</span><span style="color: #008080;">2377</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2378</span> <span style="color: #008000;">       *  @return @c true when this %function object contains a target,
</span><span style="color: #008080;">2379</span> <span style="color: #008000;">       *  or @c false when it is empty.
</span><span style="color: #008080;">2380</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2381</span> <span style="color: #008000;">       *  This function will not throw an %exception.
</span><span style="color: #008080;">2382</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2383</span>       <span style="color: #0000ff;">explicit</span> <span style="color: #0000ff;">operator</span> <span style="color: #0000ff;">bool</span>() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;">2384</span>       { <span style="color: #0000ff;">return</span> !<span style="color: #000000;">_M_empty(); }
</span><span style="color: #008080;">2385</span> 
<span style="color: #008080;">2386</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> [3.7.2.4] function invocation</span>
<span style="color: #008080;">2387</span> 
<span style="color: #008080;">2388</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2389</span> <span style="color: #008000;">       *  @brief Invokes the function targeted by @c *this.
</span><span style="color: #008080;">2390</span> <span style="color: #008000;">       *  @returns the result of the target.
</span><span style="color: #008080;">2391</span> <span style="color: #008000;">       *  @throws bad_function_call when @c !(bool)*this
</span><span style="color: #008080;">2392</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2393</span> <span style="color: #008000;">       *  The function call operator invokes the target function object
</span><span style="color: #008080;">2394</span> <span style="color: #008000;">       *  stored by @c this.
</span><span style="color: #008080;">2395</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2396</span>       _Res <span style="color: #0000ff;">operator</span>()(_ArgTypes... __args) <span style="color: #0000ff;">const</span><span style="color: #000000;">;
</span><span style="color: #008080;">2397</span> 
<span style="color: #008080;">2398</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">2399</span>       <span style="color: #008000;">//</span><span style="color: #008000;"> [3.7.2.5] function target access</span>
<span style="color: #008080;">2400</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2401</span> <span style="color: #008000;">       *  @brief Determine the type of the target of this function object
</span><span style="color: #008080;">2402</span> <span style="color: #008000;">       *  wrapper.
</span><span style="color: #008080;">2403</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2404</span> <span style="color: #008000;">       *  @returns the type identifier of the target function object, or
</span><span style="color: #008080;">2405</span> <span style="color: #008000;">       *  @c typeid(void) if @c !(bool)*this.
</span><span style="color: #008080;">2406</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2407</span> <span style="color: #008000;">       *  This function will not throw an %exception.
</span><span style="color: #008080;">2408</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2409</span>       <span style="color: #0000ff;">const</span> type_info&amp; target_type() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;">2410</span> 
<span style="color: #008080;">2411</span>       <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2412</span> <span style="color: #008000;">       *  @brief Access the stored target function object.
</span><span style="color: #008080;">2413</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2414</span> <span style="color: #008000;">       *  @return Returns a pointer to the stored target function object,
</span><span style="color: #008080;">2415</span> <span style="color: #008000;">       *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL
</span><span style="color: #008080;">2416</span> <span style="color: #008000;">       *  pointer.
</span><span style="color: #008080;">2417</span> <span style="color: #008000;">       *
</span><span style="color: #008080;">2418</span> <span style="color: #008000;">       * This function will not throw an %exception.
</span><span style="color: #008080;">2419</span>        <span style="color: #008000;">*/</span>
<span style="color: #008080;">2420</span>       template&lt;typename _Functor&gt;       _Functor*<span style="color: #000000;"> target() noexcept;
</span><span style="color: #008080;">2421</span> 
<span style="color: #008080;">2422</span>       <span style="color: #808080;">///</span><span style="color: #008000;"> @overload</span>
<span style="color: #008080;">2423</span>       template&lt;typename _Functor&gt; <span style="color: #0000ff;">const</span> _Functor* target() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;">2424</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">2425</span> 
<span style="color: #008080;">2426</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;">2427</span>       typedef _Res (*_Invoker_type)(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;">, _ArgTypes...);
</span><span style="color: #008080;">2428</span> <span style="color: #000000;">      _Invoker_type _M_invoker;
</span><span style="color: #008080;">2429</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">2430</span> 
<span style="color: #008080;">2431</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> Out-of-line member definitions.</span>
<span style="color: #008080;">2432</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2433</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2434</span>     function(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;">2435</span> <span style="color: #000000;">    : _Function_base()
</span><span style="color: #008080;">2436</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2437</span>       <span style="color: #0000ff;">if</span> (static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__x))
</span><span style="color: #008080;">2438</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2439</span>           _M_invoker =<span style="color: #000000;"> __x._M_invoker;
</span><span style="color: #008080;">2440</span>           _M_manager =<span style="color: #000000;"> __x._M_manager;
</span><span style="color: #008080;">2441</span> <span style="color: #000000;">          __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
</span><span style="color: #008080;">2442</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2443</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">2444</span> 
<span style="color: #008080;">2445</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2446</span>     template&lt;typename _Functor, typename&gt;
<span style="color: #008080;">2447</span>       function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2448</span> <span style="color: #000000;">      function(_Functor __f)
</span><span style="color: #008080;">2449</span> <span style="color: #000000;">      : _Function_base()
</span><span style="color: #008080;">2450</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2451</span>         typedef _Function_handler&lt;_Signature_type, _Functor&gt;<span style="color: #000000;"> _My_handler;
</span><span style="color: #008080;">2452</span> 
<span style="color: #008080;">2453</span>         <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_My_handler::_M_not_empty_function(__f))
</span><span style="color: #008080;">2454</span> <span style="color: #000000;">          {
</span><span style="color: #008080;">2455</span> <span style="color: #000000;">            _My_handler::_M_init_functor(_M_functor, std::move(__f));
</span><span style="color: #008080;">2456</span>             _M_invoker = &amp;<span style="color: #000000;">_My_handler::_M_invoke;
</span><span style="color: #008080;">2457</span>             _M_manager = &amp;<span style="color: #000000;">_My_handler::_M_manager;
</span><span style="color: #008080;">2458</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">2459</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2460</span> 
<span style="color: #008080;">2461</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2462</span> <span style="color: #000000;">    _Res
</span><span style="color: #008080;">2463</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2464</span>     <span style="color: #0000ff;">operator</span>()(_ArgTypes... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">2465</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2466</span>       <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_empty())
</span><span style="color: #008080;">2467</span> <span style="color: #000000;">        __throw_bad_function_call();
</span><span style="color: #008080;">2468</span>       <span style="color: #0000ff;">return</span> _M_invoker(_M_functor, std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">2469</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">2470</span> 
<span style="color: #008080;">2471</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">2472</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2473</span>     <span style="color: #0000ff;">const</span> type_info&amp;
<span style="color: #008080;">2474</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2475</span>     target_type() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;">2476</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">2477</span>       <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;">2478</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">2479</span> <span style="color: #000000;">          _Any_data __typeinfo_result;
</span><span style="color: #008080;">2480</span> <span style="color: #000000;">          _M_manager(__typeinfo_result, _M_functor, __get_type_info);
</span><span style="color: #008080;">2481</span>           <span style="color: #0000ff;">return</span> *__typeinfo_result._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">2482</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">2483</span>       <span style="color: #0000ff;">else</span>
<span style="color: #008080;">2484</span>         <span style="color: #0000ff;">return</span> typeid(<span style="color: #0000ff;">void</span><span style="color: #000000;">);
</span><span style="color: #008080;">2485</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">2486</span> 
<span style="color: #008080;">2487</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2488</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;">2489</span>       _Functor*
<span style="color: #008080;">2490</span>       function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2491</span> <span style="color: #000000;">      target() noexcept
</span><span style="color: #008080;">2492</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2493</span>         <span style="color: #0000ff;">if</span> (typeid(_Functor) == target_type() &amp;&amp;<span style="color: #000000;"> _M_manager)
</span><span style="color: #008080;">2494</span> <span style="color: #000000;">          {
</span><span style="color: #008080;">2495</span> <span style="color: #000000;">            _Any_data __ptr;
</span><span style="color: #008080;">2496</span>             <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager(__ptr, _M_functor, __get_functor_ptr)
</span><span style="color: #008080;">2497</span>                 &amp;&amp; !is_const&lt;_Functor&gt;<span style="color: #000000;">::value)
</span><span style="color: #008080;">2498</span>               <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2499</span>             <span style="color: #0000ff;">else</span>
<span style="color: #008080;">2500</span>               <span style="color: #0000ff;">return</span> __ptr._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">2501</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">2502</span>         <span style="color: #0000ff;">else</span>
<span style="color: #008080;">2503</span>           <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2504</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2505</span> 
<span style="color: #008080;">2506</span>   template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">2507</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;">2508</span>       <span style="color: #0000ff;">const</span> _Functor*
<span style="color: #008080;">2509</span>       function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">2510</span>       target() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;">2511</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">2512</span>         <span style="color: #0000ff;">if</span> (typeid(_Functor) == target_type() &amp;&amp;<span style="color: #000000;"> _M_manager)
</span><span style="color: #008080;">2513</span> <span style="color: #000000;">          {
</span><span style="color: #008080;">2514</span> <span style="color: #000000;">            _Any_data __ptr;
</span><span style="color: #008080;">2515</span> <span style="color: #000000;">            _M_manager(__ptr, _M_functor, __get_functor_ptr);
</span><span style="color: #008080;">2516</span>             <span style="color: #0000ff;">return</span> __ptr._M_access&lt;<span style="color: #0000ff;">const</span> _Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">2517</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">2518</span>         <span style="color: #0000ff;">else</span>
<span style="color: #008080;">2519</span>           <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">2520</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">2521</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">2522</span> 
<span style="color: #008080;">2523</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> [20.7.15.2.6] null pointer comparisons</span>
<span style="color: #008080;">2524</span> 
<span style="color: #008080;">2525</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2526</span> <span style="color: #008000;">   *  @brief Compares a polymorphic function object wrapper against 0
</span><span style="color: #008080;">2527</span> <span style="color: #008000;">   *  (the NULL pointer).
</span><span style="color: #008080;">2528</span> <span style="color: #008000;">   *  @returns @c true if the wrapper has no target, @c false otherwise
</span><span style="color: #008080;">2529</span> <span style="color: #008000;">   *
</span><span style="color: #008080;">2530</span> <span style="color: #008000;">   *  This function will not throw an %exception.
</span><span style="color: #008080;">2531</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">2532</span>   template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">2533</span>     inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">2534</span>     <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept
</span><span style="color: #008080;">2535</span>     { <span style="color: #0000ff;">return</span> !static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">2536</span> 
<span style="color: #008080;">2537</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> @overload</span>
<span style="color: #008080;">2538</span>   template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">2539</span>     inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">2540</span>     <span style="color: #0000ff;">operator</span>==(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;">2541</span>     { <span style="color: #0000ff;">return</span> !static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">2542</span> 
<span style="color: #008080;">2543</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2544</span> <span style="color: #008000;">   *  @brief Compares a polymorphic function object wrapper against 0
</span><span style="color: #008080;">2545</span> <span style="color: #008000;">   *  (the NULL pointer).
</span><span style="color: #008080;">2546</span> <span style="color: #008000;">   *  @returns @c false if the wrapper has no target, @c true otherwise
</span><span style="color: #008080;">2547</span> <span style="color: #008000;">   *
</span><span style="color: #008080;">2548</span> <span style="color: #008000;">   *  This function will not throw an %exception.
</span><span style="color: #008080;">2549</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">2550</span>   template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">2551</span>     inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">2552</span>     <span style="color: #0000ff;">operator</span>!=(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept
</span><span style="color: #008080;">2553</span>     { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">2554</span> 
<span style="color: #008080;">2555</span>   <span style="color: #808080;">///</span><span style="color: #008000;"> @overload</span>
<span style="color: #008080;">2556</span>   template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">2557</span>     inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">2558</span>     <span style="color: #0000ff;">operator</span>!=(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;">2559</span>     { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">2560</span> 
<span style="color: #008080;">2561</span>   <span style="color: #008000;">//</span><span style="color: #008000;"> [20.7.15.2.7] specialized algorithms</span>
<span style="color: #008080;">2562</span> 
<span style="color: #008080;">2563</span>   <span style="color: #008000;">/*</span><span style="color: #008000;">*
</span><span style="color: #008080;">2564</span> <span style="color: #008000;">   *  @brief Swap the targets of two polymorphic function object wrappers.
</span><span style="color: #008080;">2565</span> <span style="color: #008000;">   *
</span><span style="color: #008080;">2566</span> <span style="color: #008000;">   *  This function will not throw an %exception.
</span><span style="color: #008080;">2567</span>    <span style="color: #008000;">*/</span>
<span style="color: #008080;">2568</span>   template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">2569</span>     inline <span style="color: #0000ff;">void</span>
<span style="color: #008080;">2570</span>     swap(function&lt;_Res(_Args...)&gt;&amp; __x, function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __y)
</span><span style="color: #008080;">2571</span> <span style="color: #000000;">    { __x.swap(__y); }
</span><span style="color: #008080;">2572</span> 
<span style="color: #008080;">2573</span> <span style="color: #000000;">_GLIBCXX_END_NAMESPACE_VERSION
</span><span style="color: #008080;">2574</span> } <span style="color: #008000;">//</span><span style="color: #008000;"> namespace std</span>
<span style="color: #008080;">2575</span> 
<span style="color: #008080;">2576</span> <span style="color: #0000ff;">#endif</span> <span style="color: #008000;">//</span><span style="color: #008000;"> C++11</span>
<span style="color: #008080;">2577</span> 
<span style="color: #008080;">2578</span> <span style="color: #0000ff;">#endif</span> <span style="color: #008000;">//</span><span style="color: #008000;"> _GLIBCXX_FUNCTIONAL</span>
<span style="color: #008080;">2579</span></pre>
</div>
<span class="cnblogs_code_collapse">functional</span></div>
<p>这个实现的原理与上面分析的大致相同，使用函数指针实现多态，也使用了small object optimization。</p>
<p>注：标准库的文件的缩进是2格，有时8个空格会用一个tab代替，在将tab显示为4字节的编辑器中缩进会比较乱，我已经把tab全部替换为8个空格；很多人缩进习惯是4格，但如果把2格全部替换成4格也会乱了格式，所以以下摘录自标准库文件的代码全部都是2格缩进。</p>
<p>&nbsp;</p>
<h3><a name="mark_2_1"></a>2.1 类型系统</h3>
<p>类型之间的关系，无非是继承、嵌套、组合。这个实现中三者都有。</p>
<p>关于继承，你也许会问，我们刚才不是说了这种实现没法用继承吗？实际上没有矛盾。刚才说的继承，是接口上的继承，讲得更具体点就是要继承虚函数，是一种is-a的关系；而这里的继承，是实现上的继承，是一种is-implemented-in-terms-of的关系，在语言层面大多是private继承。</p>
<p>在泛型编程中，还有一个关于继承的问题，就是在继承体系的哪一层引入模板参数。</p>
<p>嵌套，即类中定义嵌套类型，使类之间的结构更加清晰，在泛型编程中还可以简化设计。</p>
<p>组合，在于一个类的对象中包含其他类的对象，本应属于对象关系的范畴，但是在这个实现中，一个类一般不会在同一个scope内出现多个对象，因此我这里就直接把对象组合的概念拿来用了。</p>
<h4><a name="mark_2_1_1"></a>2.1.1 异常类</h4>
<p>首先出现的是&nbsp;<span class="cnblogs_code">bad_function_call</span>&nbsp;类型，这是一个异常类，当调用空&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象时抛出：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">class</span> bad_function_call : <span style="color: #0000ff;">public</span><span style="color: #000000;"> std::exception
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">4</span>   <span style="color: #0000ff;">virtual</span> ~<span style="color: #000000;">bad_function_call() noexcept;
</span><span style="color: #008080;">5</span>   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* what() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;">6</span> };</pre>
</div>
<p>由于不是模板类（难得能在STL中发现非模板类），实现被编译好放在了目标文件中。虽然GCC开源，但既然这个类不太重要，而且稍微想想就能知道它是怎么实现的了，所以这里就不深究了。</p>
<p>相关的还有一个用于抛出异常的函数：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">void </span>__throw_bad_function_call() __attribute__((__noreturn__));</pre>
</div>
<p>在&nbsp;<span class="cnblogs_code">&lt;bits/functexcept.h&gt;</span>&nbsp;中。同样只有声明没有定义。</p>
<h4><a name="mark_2_1_2"></a>2.1.2 数据存储</h4>
<p>有关数据存储的类共有3个：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Undefined_class;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #000000;"><span style="color: #0000ff;">union</span> _Nocopy_types
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">void</span>*<span style="color: #000000;">       _M_object;
</span><span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>*<span style="color: #000000;"> _M_const_object;
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">void</span> (*<span style="color: #000000;">_M_function_pointer)();
</span><span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">void</span> (_Undefined_class::*<span style="color: #000000;">_M_member_pointer)();
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">};
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #000000;"><span style="color: #0000ff;">union</span> _Any_data
</span><span style="color: #008080;">12</span> <span style="color: #000000;">{
</span><span style="color: #008080;">13</span>   <span style="color: #0000ff;">void</span>*       _M_access()       { <span style="color: #0000ff;">return</span> &amp;_M_pod_data[<span style="color: #800080;">0</span><span style="color: #000000;">]; }
</span><span style="color: #008080;">14</span>   <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">void</span>* _M_access() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> &amp;_M_pod_data[<span style="color: #800080;">0</span><span style="color: #000000;">]; }
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">17</span>     _Tp&amp;
<span style="color: #008080;">18</span> <span style="color: #000000;">    _M_access()
</span><span style="color: #008080;">19</span>     { <span style="color: #0000ff;">return</span> *static_cast&lt;_Tp*&gt;<span style="color: #000000;">(_M_access()); }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">const</span> _Tp&amp;
<span style="color: #008080;">23</span>     _M_access() <span style="color: #0000ff;">const</span>
<span style="color: #008080;">24</span>     { <span style="color: #0000ff;">return</span> *static_cast&lt;<span style="color: #0000ff;">const</span> _Tp*&gt;<span style="color: #000000;">(_M_access()); }
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span> <span style="color: #000000;">  _Nocopy_types _M_unused;
</span><span style="color: #008080;">27</span>   <span style="color: #0000ff;">char</span> _M_pod_data[<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(_Nocopy_types)];
</span><span style="color: #008080;">28</span> };</pre>
</div>
<p><span class="cnblogs_code">_Undefined_class</span>&nbsp;，顾名思义，连定义都没有，只是用于声明&nbsp;<span class="cnblogs_code">_Nocopy_types</span>&nbsp;中的成员指针数据域，因为同一个平台上成员指针的大小是相同的。</p>
<p><span class="cnblogs_code">_Nocopy_types</span>&nbsp;，是4种类型的联合体类型，分别为指针、常量指针、函数指针与成员指针。&ldquo;nocopy&rdquo;指的是这几种类型指向的对象类型，而不是本身。</p>
<p><span class="cnblogs_code">_Any_data</span>&nbsp;，是两种类型的联合体类型，一个是&nbsp;<span class="cnblogs_code">_Nocopy_types</span>&nbsp;，另一个是&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">char</span></span>&nbsp;数组，两者大小相等。后者是POD的，POD的好处多啊，memcpy可以用，最重要的是复制不会抛异常。非模板&nbsp;<span class="cnblogs_code">_M_access()</span>&nbsp;返回指针，模板&nbsp;<span class="cnblogs_code">_M_access()</span>&nbsp;返回解引用的结果，两者都有&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">const</span></span>&nbsp;重载。</p>
<h4><a name="mark_2_1_3"></a>2.1.3 辅助类</h4>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;"> _Manager_operation
</span><span style="color: #008080;">2</span> <span style="color: #000000;">{
</span><span style="color: #008080;">3</span> <span style="color: #000000;">  __get_type_info,
</span><span style="color: #008080;">4</span> <span style="color: #000000;">  __get_functor_ptr,
</span><span style="color: #008080;">5</span> <span style="color: #000000;">  __clone_functor,
</span><span style="color: #008080;">6</span> <span style="color: #000000;">  __destroy_functor
</span><span style="color: #008080;">7</span> };</pre>
</div>
<p><span class="cnblogs_code">_Manager_operation</span>&nbsp;，枚举类，是前面所说控制&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的函数指针需要的参数类型。定义了4种操作：获得&nbsp;<span class="cnblogs_code">type_info</span>&nbsp;、获得仿函数（就是函数对象）指针、复制仿函数、销毁（析构）仿函数。从这个定义中可以看出，<a href="#mark_1_4" target="_blank">1.4</a>节所说的各种功能中，需要延迟调用的，除了函数对象调用以外，都可以通过这4个功能来组合起来。我们后面还会进一步探讨这个问题。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> template&lt;typename _Tp&gt;
<span style="color: #008080;">2</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> __is_location_invariant
</span><span style="color: #008080;">3</span>   : integral_constant&lt;<span style="color: #0000ff;">bool</span>, (is_pointer&lt;_Tp&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;">4</span>                              || is_member_pointer&lt;_Tp&gt;::value)&gt;
<span style="color: #008080;">5</span>   { };</pre>
</div>
<p><span class="cnblogs_code">__is_location_invariant</span>&nbsp;，一个trait类，判断一个类型是不是&ldquo;位置不变&rdquo;的。从字面上来理解，一个类型如果是&ldquo;位置不变&rdquo;的，那么对于一个这种类型的对象，无论它复制到哪里，各个对象的底层表示都是相同的。在这个定义中，一个类型是&ldquo;位置不变&rdquo;的，当且仅当它是一个指针或成员指针（与一般的理解有所不同）。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Tp&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Simple_type_wrapper
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    _Simple_type_wrapper(_Tp __value) : __value(__value) { }
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    _Tp __value;
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">  };
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> template&lt;typename _Tp&gt;
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">struct</span> __is_location_invariant&lt;_Simple_type_wrapper&lt;_Tp&gt; &gt;
<span style="color: #008080;">11</span>   : __is_location_invariant&lt;_Tp&gt;
<span style="color: #008080;">12</span>   { };</pre>
</div>
<p><span class="cnblogs_code">_Simple_type_wrapper</span>&nbsp;，一个简单的包装器，用于避免&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span>*</span>&nbsp;与指针的指针之间类型转换的&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">const</span></span>&nbsp;问题。以及&nbsp;<span class="cnblogs_code">__is_location_invariant</span>&nbsp;对&nbsp;<span class="cnblogs_code">_Simple_type_wrapper</span>&nbsp;的偏特化。</p>
<h4><a name="mark_2_1_4"></a>2.1.4 内存管理基类</h4>
<p>类&nbsp;<span class="cnblogs_code">_Function_base</span>&nbsp;定义了一系列用于管理函数对象内存的函数，这是一个非模板类：</p>
<div class="cnblogs_code">
<pre><code><span><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Function_base
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> std::size_t _M_max_size = <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(_Nocopy_types);
</span><span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> std::size_t _M_max_align =<span style="color: #000000;"> __alignof__(_Nocopy_types);
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Base_manager;
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Ref_manager;
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>   _Function_base() : _M_manager(<span style="color: #800080;">0</span><span style="color: #000000;">) { }
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>   ~<span style="color: #000000;">_Function_base()
</span><span style="color: #008080;">16</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">17</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;">18</span> <span style="color: #000000;">      _M_manager(_M_functor, _M_functor, __destroy_functor);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>   <span style="color: #0000ff;">bool</span> _M_empty() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> !<span style="color: #000000;">_M_manager; }
</span><span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span>   typedef <span style="color: #0000ff;">bool</span> (*_Manager_type)(_Any_data&amp;, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;">,
</span><span style="color: #008080;">24</span> <span style="color: #000000;">                                _Manager_operation);
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span> <span style="color: #000000;">  _Any_data     _M_functor;
</span><span style="color: #008080;">27</span> <span style="color: #000000;">  _Manager_type _M_manager;
</span><span style="color: #008080;">28</span> };</span></pre>
</div>
<p><span class="cnblogs_code">_Function_base</span>&nbsp;是&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的实现基类，定义了两个静态常量，用于后面的trait类；两个内部类，用于包装静态方法；函数指针类型&nbsp;<span class="cnblogs_code">_Manager_type</span>&nbsp;的对象&nbsp;<span class="cnblogs_code">_M_manager</span>&nbsp;，用于存取&nbsp;<span class="cnblogs_code">_Any_data</span>&nbsp;类型的&nbsp;<span class="cnblogs_code">_M_functor</span>&nbsp;中的数据；构造函数，将函数指针置为空；析构函数，调用函数指针，销毁函数对象；<span class="cnblogs_code">_M_empty()</span>&nbsp;方法，检测内部是否存有函数对象。</p>
<p>我们来看其中的&nbsp;<span class="cnblogs_code">_Base_manager</span>&nbsp;类：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Base_manager
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span>   <span style="color: #0000ff;">protected</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">bool</span> __stored_locally =
<span style="color: #008080;"> 6</span>     (__is_location_invariant&lt;_Functor&gt;<span style="color: #000000;">::value
</span><span style="color: #008080;"> 7</span>      &amp;&amp; <span style="color: #0000ff;">sizeof</span>(_Functor) &lt;=<span style="color: #000000;"> _M_max_size
</span><span style="color: #008080;"> 8</span>      &amp;&amp; __alignof__(_Functor) &lt;=<span style="color: #000000;"> _M_max_align
</span><span style="color: #008080;"> 9</span>      &amp;&amp; (_M_max_align % __alignof__(_Functor) == <span style="color: #800080;">0</span><span style="color: #000000;">));
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>     typedef integral_constant&lt;<span style="color: #0000ff;">bool</span>, __stored_locally&gt;<span style="color: #000000;"> _Local_storage;
</span><span style="color: #008080;">12</span> 
<span style="color: #008080;">13</span>     <span style="color: #0000ff;">static</span> _Functor*
<span style="color: #008080;">14</span>     _M_get_pointer(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source);
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">17</span>     _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, true_type);
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">20</span>     _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, false_type);
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">23</span>     _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, true_type);
</span><span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">26</span>     _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, false_type);
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">30</span>     _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">31</span> <span style="color: #000000;">               _Manager_operation __op);
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">34</span>     _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f);
</span><span style="color: #008080;">35</span> 
<span style="color: #008080;">36</span>     template&lt;typename _Signature&gt;
<span style="color: #008080;">37</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">38</span>       _M_not_empty_function(<span style="color: #0000ff;">const</span> function&lt;_Signature&gt;&amp;<span style="color: #000000;"> __f);
</span><span style="color: #008080;">39</span> 
<span style="color: #008080;">40</span>     template&lt;typename _Tp&gt;
<span style="color: #008080;">41</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">42</span>       _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp*&amp;<span style="color: #000000;"> __fp);
</span><span style="color: #008080;">43</span> 
<span style="color: #008080;">44</span>     template&lt;typename _Class, typename _Tp&gt;
<span style="color: #008080;">45</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">46</span>       _M_not_empty_function(_Tp _Class::* <span style="color: #0000ff;">const</span>&amp;<span style="color: #000000;"> __mp);
</span><span style="color: #008080;">47</span> 
<span style="color: #008080;">48</span>     template&lt;typename _Tp&gt;
<span style="color: #008080;">49</span>       <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">50</span>       _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;">);
</span><span style="color: #008080;">51</span> 
<span style="color: #008080;">52</span>   <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;">53</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">54</span>     _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, true_type);
</span><span style="color: #008080;">55</span> 
<span style="color: #008080;">56</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">57</span>     _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, false_type);
</span><span style="color: #008080;">58</span>   };</pre>
</div>
<p>定义了一个静态布尔常量&nbsp;<span class="cnblogs_code">__stored_locally</span>&nbsp;，它为真当且仅当&nbsp;<span class="cnblogs_code">__is_location_invariant</span>&nbsp;trait为真、仿函数放得下、仿函数的align符合两个要求。然后再反过来根据这个值定义trait类&nbsp;<span class="cnblogs_code">_Local_storage</span>&nbsp;（标准库里一般都是根据value trait来生成value）。</p>
<p>其余几个静态方法，顾名思义即可。有个值得思考的问题，就是为什么&nbsp;<span class="cnblogs_code">_M_init_functor</span>&nbsp;是public的，没有被放进&nbsp;<span class="cnblogs_code">_M_manager</span>&nbsp;呢？</p>
<p>再来看&nbsp;<span class="cnblogs_code">_Ref_manager</span>&nbsp;类：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">class</span> _Ref_manager : <span style="color: #0000ff;">public</span> _Base_manager&lt;_Functor*&gt;
<span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span>     typedef _Function_base::_Base_manager&lt;_Functor*&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 8</span>     _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">               _Manager_operation __op);
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">12</span>     _M_init_functor(_Any_data&amp; __functor, reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f);
</span><span style="color: #008080;">13</span>   };</pre>
</div>
<p><span class="cnblogs_code">_Ref_manager</span>&nbsp;继承自&nbsp;<span class="cnblogs_code">_Base_manager</span>&nbsp;类，覆写了两个静态方法。<span style="color: #ff0000; font-size: 18px;"><br /></span></p>
<h4><a name="mark_2_1_5"></a>2.1.5 仿函数调用</h4>
<p>起辅助作用的模板函数&nbsp;<span class="cnblogs_code">__callable_functor</span>&nbsp;：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   inline _Functor&amp;
<span style="color: #008080;"> 3</span>   __callable_functor(_Functor&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;"> 4</span>   { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __f; }
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;"> 7</span>   inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;"> 8</span>   __callable_functor(_Member _Class::* &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;"> 9</span>   { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">12</span>   inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">13</span>   __callable_functor(_Member _Class::* <span style="color: #0000ff;">const</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">14</span>   { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">17</span>   inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">18</span>   __callable_functor(_Member _Class::* <span style="color: #0000ff;">volatile</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">19</span>   { <span style="color: #0000ff;">return</span><span style="color: #000000;"> std::mem_fn(__p); }
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span> template&lt;typename _Member, typename _Class&gt;
<span style="color: #008080;">22</span>   inline _Mem_fn&lt;_Member _Class::*&gt;
<span style="color: #008080;">23</span>   __callable_functor(_Member _Class::* <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">volatile</span> &amp;<span style="color: #000000;">__p)
</span><span style="color: #008080;">24</span>   { <span style="color: #0000ff;">return</span> std::mem_fn(__p); }</pre>
</div>
<p>对非成员指针类型，直接返回参数本身；对成员指针类型，返回&nbsp;<span class="cnblogs_code">mem_fn()</span>&nbsp;的结果（将类对象转换为第一个参数；这个标准库函数的实现不在这篇文章中涉及），并有cv-qualified重载。它改变了调用的形式，把所有的参数都放在了小括号中。</p>
<p><span class="cnblogs_code">_Function_handler</span>&nbsp;类，管理仿函数调用：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Signature, typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">class</span><span style="color: #000000;"> _Function_handler;
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt;
<span style="color: #008080;"> 6</span>   : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;_Functor&gt;
<span style="color: #008080;"> 7</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 8</span>     typedef _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">12</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">16</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Functor&gt;
<span style="color: #008080;">17</span>   : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;_Functor&gt;
<span style="color: #008080;">18</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">19</span>     typedef _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">20</span> 
<span style="color: #008080;">21</span>    <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">23</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">24</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span> template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">27</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;
<span style="color: #008080;">28</span>   : <span style="color: #0000ff;">public</span> _Function_base::_Ref_manager&lt;_Functor&gt;
<span style="color: #008080;">29</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">30</span>     typedef _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">31</span> 
<span style="color: #008080;">32</span>    <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">33</span>     <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">34</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">35</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">36</span> 
<span style="color: #008080;">37</span> template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">38</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;
<span style="color: #008080;">39</span>   : <span style="color: #0000ff;">public</span> _Function_base::_Ref_manager&lt;_Functor&gt;
<span style="color: #008080;">40</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">41</span>     typedef _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">42</span> 
<span style="color: #008080;">43</span>    <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">44</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">45</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">46</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">47</span> 
<span style="color: #008080;">48</span> template&lt;<span style="color: #000000;">typename _Class, typename _Member, typename _Res,
</span><span style="color: #008080;">49</span>          typename... _ArgTypes&gt;
<span style="color: #008080;">50</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;_Res(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">51</span>   : <span style="color: #0000ff;">public</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">52</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">53</span>     typedef _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">54</span> <span style="color: #000000;">      _Base;
</span><span style="color: #008080;">55</span> 
<span style="color: #008080;">56</span>    <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">57</span>     <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">58</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">59</span> <span style="color: #000000;">  };
</span><span style="color: #008080;">60</span> 
<span style="color: #008080;">61</span> template&lt;typename _Class, typename _Member, typename... _ArgTypes&gt;
<span style="color: #008080;">62</span>   <span style="color: #0000ff;">class</span> _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;
<span style="color: #008080;">63</span>   : <span style="color: #0000ff;">public</span> _Function_base::_Base_manager&lt;
<span style="color: #008080;">64</span>                _Simple_type_wrapper&lt; _Member _Class::* &gt; &gt;
<span style="color: #008080;">65</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">66</span>     typedef _Member _Class::*<span style="color: #000000;"> _Functor;
</span><span style="color: #008080;">67</span>     typedef _Simple_type_wrapper&lt;_Functor&gt;<span style="color: #000000;"> _Wrapper;
</span><span style="color: #008080;">68</span>     typedef _Function_base::_Base_manager&lt;_Wrapper&gt;<span style="color: #000000;"> _Base;
</span><span style="color: #008080;">69</span> 
<span style="color: #008080;">70</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">71</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">72</span>     _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">73</span> <span style="color: #000000;">               _Manager_operation __op);
</span><span style="color: #008080;">74</span> 
<span style="color: #008080;">75</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">76</span>     _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args);
</span><span style="color: #008080;">77</span>   };</pre>
</div>
<p>共有6个特化版本：返回值类型为&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;、其他；函数对象类型为&nbsp;<span class="cnblogs_code">std::reference_wrapper</span>&nbsp;、成员指针、其他。</p>
<p>继承自&nbsp;<span class="cnblogs_code">_Function_base::_Base_manager</span>&nbsp;或&nbsp;<span class="cnblogs_code">_Function_base::_Ref_manager</span>&nbsp;，提供了静态方法&nbsp;<span class="cnblogs_code">_M_invoke()</span>&nbsp;，用于仿函数调用。有一个覆写的&nbsp;<span class="cnblogs_code">_M_manager()</span>&nbsp;，表面上看是一个偏特化有覆写，实际上是两个，因为返回非&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span> 的成员指针偏特化版本还继承了其对应&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span> 偏特化版本。</p>
<h4><a name="mark_2_1_6"></a>2.1.6 接口定义</h4>
<p>终于回到伟大的&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;了，但是我们还得再看点别的：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Arg, typename _Result&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> unary_function
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">    typedef _Arg     argument_type;   
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    typedef _Result     result_type;  
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">  };
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> template&lt;typename _Arg1, typename _Arg2, typename _Result&gt;
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> binary_function
</span><span style="color: #008080;">11</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    typedef _Arg1     first_argument_type; 
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span> <span style="color: #000000;">    typedef _Arg2     second_argument_type;
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #000000;">    typedef _Result     result_type;
</span><span style="color: #008080;">17</span>   };</pre>
</div>
<p><span class="cnblogs_code">std::unary_function</span>&nbsp;与&nbsp;<span class="cnblogs_code">std::binary_function</span>&nbsp;，定义了一元和二元函数的参数类型与返回值类型。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _Maybe_unary_or_binary_function { };
</span><span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> template&lt;typename _Res, typename _T1&gt;
<span style="color: #008080;"> 5</span>   <span style="color: #0000ff;">struct</span> _Maybe_unary_or_binary_function&lt;_Res, _T1&gt;
<span style="color: #008080;"> 6</span>   : std::unary_function&lt;_T1, _Res&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> template&lt;typename _Res, typename _T1, typename _T2&gt;
<span style="color: #008080;"> 9</span>   <span style="color: #0000ff;">struct</span> _Maybe_unary_or_binary_function&lt;_Res, _T1, _T2&gt;
<span style="color: #008080;">10</span>   : std::binary_function&lt;_T1, _T2, _Res&gt; { };</pre>
</div>
<p><span class="cnblogs_code">_Maybe_unary_or_binary_function</span>&nbsp;类，当模板参数表示的函数为一元或二元时，分别继承 <span class="cnblogs_code">std::unary_function</span>&nbsp;与&nbsp;<span class="cnblogs_code">std::binary_function</span>&nbsp;。</p>
<p>现在可以给出&nbsp;<span class="cnblogs_code">std::function</span> 类定义与方法声明：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">  1</span> template&lt;typename _Signature&gt;
<span style="color: #008080;">  2</span>   <span style="color: #0000ff;">class</span><span style="color: #000000;"> function;
</span><span style="color: #008080;">  3</span> 
<span style="color: #008080;">  4</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">  5</span>   <span style="color: #0000ff;">class</span> function&lt;_Res(_ArgTypes...)&gt;
<span style="color: #008080;">  6</span>   : <span style="color: #0000ff;">public</span> _Maybe_unary_or_binary_function&lt;_Res, _ArgTypes...&gt;<span style="color: #000000;">,
</span><span style="color: #008080;">  7</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> _Function_base
</span><span style="color: #008080;">  8</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">  9</span> <span style="color: #000000;">    typedef _Res _Signature_type(_ArgTypes...);
</span><span style="color: #008080;"> 10</span> 
<span style="color: #008080;"> 11</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;"> 12</span>       <span style="color: #0000ff;">using</span> _Invoke = decltype(__callable_functor(std::declval&lt;_Functor&amp;&gt;<span style="color: #000000;">())
</span><span style="color: #008080;"> 13</span>                                (std::declval&lt;_ArgTypes&gt;<span style="color: #000000;">()...) );
</span><span style="color: #008080;"> 14</span> 
<span style="color: #008080;"> 15</span>     template&lt;typename _CallRes, typename _Res1&gt;
<span style="color: #008080;"> 16</span>       <span style="color: #0000ff;">struct</span><span style="color: #000000;"> _CheckResult
</span><span style="color: #008080;"> 17</span>       : is_convertible&lt;_CallRes, _Res1&gt;<span style="color: #000000;"> { };
</span><span style="color: #008080;"> 18</span> 
<span style="color: #008080;"> 19</span>     template&lt;typename _CallRes&gt;
<span style="color: #008080;"> 20</span>       <span style="color: #0000ff;">struct</span> _CheckResult&lt;_CallRes, <span style="color: #0000ff;">void</span>&gt;
<span style="color: #008080;"> 21</span> <span style="color: #000000;">      : true_type { };
</span><span style="color: #008080;"> 22</span> 
<span style="color: #008080;"> 23</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;"> 24</span>       <span style="color: #0000ff;">using</span> _Callable = _CheckResult&lt;_Invoke&lt;_Functor&gt;, _Res&gt;<span style="color: #000000;">;
</span><span style="color: #008080;"> 25</span> 
<span style="color: #008080;"> 26</span>     template&lt;typename _Cond, typename _Tp&gt;
<span style="color: #008080;"> 27</span>       <span style="color: #0000ff;">using</span> _Requires = typename enable_if&lt;_Cond::value, _Tp&gt;<span style="color: #000000;">::type;
</span><span style="color: #008080;"> 28</span> 
<span style="color: #008080;"> 29</span>   <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 30</span> <span style="color: #000000;">    typedef _Res result_type;
</span><span style="color: #008080;"> 31</span> 
<span style="color: #008080;"> 32</span> <span style="color: #000000;">    function() noexcept;
</span><span style="color: #008080;"> 33</span> 
<span style="color: #008080;"> 34</span> <span style="color: #000000;">    function(nullptr_t) noexcept;
</span><span style="color: #008080;"> 35</span> 
<span style="color: #008080;"> 36</span>     function(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;"> 37</span> 
<span style="color: #008080;"> 38</span>     function(function&amp;&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;"> 39</span> 
<span style="color: #008080;"> 40</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> TODO: needs allocator_arg_t</span>
<span style="color: #008080;"> 41</span> 
<span style="color: #008080;"> 42</span>     template&lt;<span style="color: #000000;">typename _Functor,
</span><span style="color: #008080;"> 43</span>              typename = _Requires&lt;_Callable&lt;_Functor&gt;, <span style="color: #0000ff;">void</span>&gt;&gt;
<span style="color: #008080;"> 44</span> <span style="color: #000000;">      function(_Functor);
</span><span style="color: #008080;"> 45</span> 
<span style="color: #008080;"> 46</span>     function&amp;
<span style="color: #008080;"> 47</span>     <span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;"> 48</span> 
<span style="color: #008080;"> 49</span>     function&amp;
<span style="color: #008080;"> 50</span>     <span style="color: #0000ff;">operator</span>=(function&amp;&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;"> 51</span> 
<span style="color: #008080;"> 52</span>     function&amp;
<span style="color: #008080;"> 53</span>     <span style="color: #0000ff;">operator</span>=<span style="color: #000000;">(nullptr_t);
</span><span style="color: #008080;"> 54</span> 
<span style="color: #008080;"> 55</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;"> 56</span>       _Requires&lt;_Callable&lt;_Functor&gt;, function&amp;&gt;
<span style="color: #008080;"> 57</span>       <span style="color: #0000ff;">operator</span>=(_Functor&amp;&amp;<span style="color: #000000;"> __f);
</span><span style="color: #008080;"> 58</span> 
<span style="color: #008080;"> 59</span>     template&lt;typename _Functor&gt;
<span style="color: #008080;"> 60</span>       function&amp;
<span style="color: #008080;"> 61</span>       <span style="color: #0000ff;">operator</span>=(reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f) noexcept;
</span><span style="color: #008080;"> 62</span>     <span style="color: #0000ff;">void</span> swap(function&amp;<span style="color: #000000;"> __x);
</span><span style="color: #008080;"> 63</span> 
<span style="color: #008080;"> 64</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> TODO: needs allocator_arg_t</span>
<span style="color: #008080;"> 65</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 66</span> <span style="color: #008000;">    template&lt;typename _Functor, typename _Alloc&gt;
</span><span style="color: #008080;"> 67</span> <span style="color: #008000;">      void
</span><span style="color: #008080;"> 68</span> <span style="color: #008000;">      assign(_Functor&amp;&amp; __f, const _Alloc&amp; __a);
</span><span style="color: #008080;"> 69</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 70</span> 
<span style="color: #008080;"> 71</span>     <span style="color: #0000ff;">explicit</span> <span style="color: #0000ff;">operator</span> <span style="color: #0000ff;">bool</span>() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;"> 72</span> 
<span style="color: #008080;"> 73</span>     _Res <span style="color: #0000ff;">operator</span>()(_ArgTypes... __args) <span style="color: #0000ff;">const</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 74</span> 
<span style="color: #008080;"> 75</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;"> 76</span>     <span style="color: #0000ff;">const</span> type_info&amp; target_type() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;"> 77</span> 
<span style="color: #008080;"> 78</span>     template&lt;typename _Functor&gt;       _Functor*<span style="color: #000000;"> target() noexcept;
</span><span style="color: #008080;"> 79</span> 
<span style="color: #008080;"> 80</span>     template&lt;typename _Functor&gt; <span style="color: #0000ff;">const</span> _Functor* target() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept;
</span><span style="color: #008080;"> 81</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;"> 82</span> 
<span style="color: #008080;"> 83</span>   <span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 84</span>     typedef _Res (*_Invoker_type)(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;">, _ArgTypes...);
</span><span style="color: #008080;"> 85</span> <span style="color: #000000;">    _Invoker_type _M_invoker;
</span><span style="color: #008080;"> 86</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 87</span> 
<span style="color: #008080;"> 88</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;"> 89</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 90</span>   <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept;
</span><span style="color: #008080;"> 91</span> 
<span style="color: #008080;"> 92</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;"> 93</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 94</span>   <span style="color: #0000ff;">operator</span>==(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept;
</span><span style="color: #008080;"> 95</span> 
<span style="color: #008080;"> 96</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;"> 97</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 98</span>   <span style="color: #0000ff;">operator</span>!=(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept;
</span><span style="color: #008080;"> 99</span> 
<span style="color: #008080;">100</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">101</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">102</span>   <span style="color: #0000ff;">operator</span>!=(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept;
</span><span style="color: #008080;">103</span> 
<span style="color: #008080;">104</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">105</span>   inline <span style="color: #0000ff;">void</span>
<span style="color: #008080;">106</span>   swap(function&lt;_Res(_Args...)&gt;&amp; __x, function&lt;_Res(_Args...)&gt;&amp; __y);</pre>
</div>
<p>前面说过，<span class="cnblogs_code">std::function</span>&nbsp;类的模板参数是一个函数类型。一个函数类型也是一个类型；<span class="cnblogs_code">std::function</span>&nbsp;只在模板参数是函数类型时才有意义；因此，有用的&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;是一个特化的模板，需要一个声明。标准库规定没有特化的声明是没有定义的。</p>
<p><span class="cnblogs_code">std::function</span>&nbsp;继承自两个类：公有继承模板类&nbsp;<span class="cnblogs_code">_Maybe_unary_or_binary_function</span>&nbsp;，私有继承非模板类&nbsp;<span class="cnblogs_code">_Function_base</span>&nbsp;。</p>
<p>前者是公有继承，但实际上没有继承虚函数，不属于接口继承，而是实现继承，继承的是基类定义的类型别名。因为这些类型别名是面向客户的，所以必须公有继承。这个继承使&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;在不同数量的模板参数的实例化下定义不同的类型别名。继承是实现这种功能的唯一方法，SFINAE不行。（这是本文第一次出现SFINAE这个词，我默认你看得懂。这是泛型编程中的常用技巧，如果不会请参考<a title="C++奇淫巧技之SFINAE" href="https://www.jianshu.com/p/45a2410d4085" target="_blank">这篇文章</a>或Google。）</p>
<p>后者是私有继承，也属于实现继承，继承了基类的两个数据域与几个静态方法。</p>
<p><span class="cnblogs_code">_Signature_type</span>&nbsp;是一个类型别名，就是模板参数，是一个函数类型。</p>
<p><span class="cnblogs_code">_Invoke</span>&nbsp;是一个别名模板，就是仿函数被按参数类型调用的返回类型。如果不能调用，根据SFINAE，S错误不会E，但这个别名只有一个定义，在使用的地方所有S都E了，编译器还是会给E。</p>
<p><span class="cnblogs_code">_CheckResult</span>&nbsp;是一个trait类，检测第一个模板参数能否转换为第二个。另有第二个参数为&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;的偏特化，在类型检测上使返回类型为&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span>&nbsp;的&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象能支持任何返回值的函数对象。</p>
<p><span class="cnblogs_code">_Callable</span>&nbsp;也是一个trait类，利用上面两个定义检测仿函数类型与&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;模板参数是否匹配。</p>
<p><span class="cnblogs_code">_Requires</span>&nbsp;是一个有趣的别名模板，如果模板参数中第一个value trait为&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">true</span></span>&nbsp;，则定义为第二个模板参数，否则未定义（是没有，不是&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;），使用时将交给SFINAE处理。它大致上实现了C++20中&nbsp;<span class="cnblogs_code" style="color: #0000ff;">require</span>&nbsp;关键字的功能。实际上concept在2005年就有proposal了，一路从C++0x拖到C++20。我计划在C++20标准正式发布之前写一篇文章完整介绍concept。</p>
<p><span class="cnblogs_code">result_type</span>&nbsp;是模板参数函数类型的返回值类型，与基类中定义的相同。</p>
<p>在类定义最后的私有段，还定义了一个函数指针类型以及该类型的一个对象，这是第二个函数指针。</p>
<p>其余的各种函数，在<a href="#mark_1_4" target="_blank">1.4</a>节都介绍过了。</p>
<h4><a name="mark_2_1_7"></a>2.1.7 类型关系</h4>
<p>讲了这么多类型，你记住它们之间的关系了吗？我们再来自顶向下地梳理一遍。</p>
<p>一个&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象中包含一个函数指针，它会被初始化为&nbsp;<span class="cnblogs_code">_Function_handler</span>&nbsp;类中的静态函数的指针。<span class="cnblogs_code">std::function</span>&nbsp;与&nbsp;<span class="cnblogs_code">_Function_handler</span>&nbsp;类之间，可以认为是组合关系。</p>
<p><span class="cnblogs_code">std::function</span>&nbsp;继承自&nbsp;<span class="cnblogs_code">_Maybe_unary_or_binary_function</span>&nbsp;与&nbsp;<span class="cnblogs_code">_Function_base</span>&nbsp;，两者都是实现继承。</p>
<p><span class="cnblogs_code">_Function_base</span>&nbsp;中有&nbsp;<span class="cnblogs_code">_Base_manager</span>&nbsp;与&nbsp;<span class="cnblogs_code">_Ref_manager</span>&nbsp;两个嵌套类型，其中后者还继承了前者，并覆写了几个方法。两个类定义了一系列静态方法，继承只是为了避免代码重复。</p>
<p><span class="cnblogs_code">_Function_base</span>&nbsp;含有两个数据域，一个是函数指针，<span class="cnblogs_code">_Function_base</span>&nbsp;与两个嵌套类型之间既是嵌套又是组合；另一个是&nbsp;<span class="cnblogs_code">_Any_data</span>&nbsp;类型对象，<span class="cnblogs_code">_Function_base</span>&nbsp;与&nbsp;<span class="cnblogs_code">_Any_data</span>&nbsp;之间是组合关系。</p>
<p>而&nbsp;<span class="cnblogs_code">_Any_data</span>&nbsp;是一个联合体，是两部分相同大小数据的联合，分别是&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">char</span></span>&nbsp;数组和&nbsp;<span class="cnblogs_code">_Nocopy_types</span>&nbsp;类型对象，后者又是4种基本类型的联合。</p>
<p>其余的一些类与函数，都是起辅助作用的。至此，对&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;定义的分析就结束了。</p>
<p>&nbsp;</p>
<h3><a name="mark_2_2"></a>2.2 方法的功能与实现</h3>
<h4><a name="mark_2_2_1"></a>2.2.1 多态性的体现</h4>
<p>之前一直讲，<span class="cnblogs_code">std::function</span>&nbsp;是一个多态的函数对象包装器，其中的难点就在于多态。什么是多态？你能看到这里，水平肯定不低，不知道多态是不可能的。Wikipedia对<a title="Polymorphism (computer science)" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank">polymorphism</a>的定义是：In programming languages and type theory, polymorphism is the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types.</p>
<p>可以说，我们要在&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;中处理好多态，就是要处理好类型。类型当然不能一个个枚举，但可以分类。这里可以分类的有两处：接口类型，即组成模板参数的类型，以及实现类型，即绑定的仿函数的类型。下面，我们就从这两个角度入手，分析&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;是如何实现的。</p>
<h4><a name="mark_2_2_2"></a>2.2.2 本地函数对象</h4>
<p>先根据仿函数类型分类，可以在&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象内部存储的，无需heap空间的，在这一节讨论。相关的方法有以下3个：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, true_type)
</span><span style="color: #008080;"> 5</span>   { <span style="color: #0000ff;">new</span><span style="color: #000000;"> (__functor._M_access()) _Functor(std::move(__f)); }
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 9</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">10</span>   _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, true_type)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">12</span>     <span style="color: #0000ff;">new</span> (__dest._M_access()) _Functor(__source._M_access&lt;_Functor&gt;<span style="color: #000000;">());
</span><span style="color: #008080;">13</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> template&lt;typename _Functor&gt;
<span style="color: #008080;">16</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">17</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">18</span>   _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, true_type)
</span><span style="color: #008080;">19</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">20</span>     __victim._M_access&lt;_Functor&gt;().~<span style="color: #000000;">_Functor();
</span><span style="color: #008080;">21</span>   }</pre>
</div>
<p><span class="cnblogs_code">_M_init_functor</span>&nbsp;用于初始化对象，在空白区域上用placement&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">new</span></span>&nbsp;移动构造了函数对象。</p>
<p><span class="cnblogs_code">_M_clone</span>&nbsp;用于复制对象，在目标的空白区域上用placement&nbsp;<span class="cnblogs_code" style="color: #0000ff;">new</span>&nbsp;拷贝构造和函数对象。</p>
<p><span class="cnblogs_code">_M_destroy</span>&nbsp;用于销毁对象，对函数对象显式调用了析构函数。</p>
<h4><a name="mark_2_2_3"></a>2.2.3 heap函数对象</h4>
<p>然后来看函数对象存储在heap上的情况：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f, false_type)
</span><span style="color: #008080;"> 5</span>   { __functor._M_access&lt;_Functor*&gt;() = <span style="color: #0000ff;">new</span><span style="color: #000000;"> _Functor(std::move(__f)); }
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 9</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">10</span>   _M_clone(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source, false_type)
</span><span style="color: #008080;">11</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">12</span>     __dest._M_access&lt;_Functor*&gt;() =
<span style="color: #008080;">13</span>       <span style="color: #0000ff;">new</span> _Functor(*__source._M_access&lt;_Functor*&gt;<span style="color: #000000;">());
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> template&lt;typename _Functor&gt;
<span style="color: #008080;">17</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">18</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">19</span>   _M_destroy(_Any_data&amp;<span style="color: #000000;"> __victim, false_type)
</span><span style="color: #008080;">20</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">21</span>     <span style="color: #0000ff;">delete</span> __victim._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">22</span>   }</pre>
</div>
<p><span class="cnblogs_code">_M_access&lt;_Functor*&gt;()</span>&nbsp;将空白区域解释为仿函数的指针，并返回其引用，实现了这片区域的分时复用。前两个方法都比前一种情况多一层间接，而销毁方法则直接调用了&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">delete</span></span>&nbsp;。</p>
<h4><a name="mark_2_2_4"></a>2.2.4 两种存储结构如何统一</h4>
<p>尽管我们不得不分类讨论，但为了方便使用，还需要一个统一的接口。不知你有没有注意到，上面每一个方法都有一个未命名的参数放在最后，在方法中也没有用到。前一种情况，这个参数都是&nbsp;<span class="cnblogs_code">true_type</span>&nbsp;类型，而后一种都是&nbsp;<span class="cnblogs_code">false_type</span>&nbsp;类型。这个技巧称为tag dispatching，在调用时根据类型特征确定这个位置的参数类型，从而通过重载决定调用哪一个。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_init_functor(_Any_data&amp; __functor, _Functor&amp;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  { _M_init_functor(__functor, std::move(__f), _Local_storage()); }
</span><span style="color: #008080;"> 6</span> 
<span style="color: #008080;"> 7</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 8</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 9</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">10</span>   _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">11</span> <span style="color: #000000;">             _Manager_operation __op)
</span><span style="color: #008080;">12</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">15</span> <span style="color: #000000;">  #ifdef __GXX_RTTI
</span><span style="color: #008080;">16</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">17</span>         __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">19</span>   <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">20</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">21</span>         __dest._M_access&lt;_Functor*&gt;() =<span style="color: #000000;"> _M_get_pointer(__source);
</span><span style="color: #008080;">22</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">23</span> 
<span style="color: #008080;">24</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __clone_functor:
</span><span style="color: #008080;">25</span> <span style="color: #000000;">        _M_clone(__dest, __source, _Local_storage());
</span><span style="color: #008080;">26</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __destroy_functor:
</span><span style="color: #008080;">29</span> <span style="color: #000000;">        _M_destroy(__dest, _Local_storage());
</span><span style="color: #008080;">30</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">31</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">32</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">33</span>   }</pre>
</div>
<p>这个版本的&nbsp;<span class="cnblogs_code">_M_init_functor()</span>&nbsp;只有两个参数，加上第三个参数委托给重载版本处理，这第三个参数是一个&nbsp;<span class="cnblogs_code">_Local_storage</span>&nbsp;类的对象，它根据&nbsp;<span class="cnblogs_code">__stored_locally</span>&nbsp;而成为&nbsp;<span class="cnblogs_code">true_type</span>&nbsp;与&nbsp;<span class="cnblogs_code">false_type</span>&nbsp;，从而区分开两个重载。</p>
<p><span class="cnblogs_code">_M_manager()</span>&nbsp;方法，同样地，利用tag dispatching把另两组方法统一起来。它通过第三个枚举类型参数来确定需要的操作。</p>
<p>但是，这个方法的返回值是&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">bool</span></span>&nbsp;，怎么传出&nbsp;<span class="cnblogs_code">type_info</span>&nbsp;与函数对象指针呢？它们将返回值写入第一个参数所指向的空间中。说起利用参数来传递返回值，我就想起C中的指针、C++中的引用、RVO、Java中的包裹类型、C#中的&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">out</span></span>&nbsp;关键字&hellip;&hellip;这里的处理方法不仅解决了返回值的问题，同时也使各个操作的参数统一起来。</p>
<p>一个值得思考的问题是为什么不把&nbsp;<span class="cnblogs_code">_M_init_functor()</span>&nbsp;也放到&nbsp;<span class="cnblogs_code">_M_manager()</span>&nbsp;中去？答案是，调用&nbsp;<span class="cnblogs_code">_M_init_functor()</span>&nbsp;的地方在&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的模板构造或模板赋值函数中，此时是知道仿函数类型的；而其他操作被调用时，主调函数是不知道仿函数类型的，就必须用函数指针存储起来；为了节省空间，就引入一个枚举类&nbsp;<span class="cnblogs_code">_Manager_operation</span>&nbsp;，把几种操作合并到一个函数中。</p>
<p>实际上这一层可以先不统一，就是写两种情况的&nbsp;<span class="cnblogs_code">_M_manager</span>&nbsp;，然后到上一层再统一，但是会增加代码量。</p>
<p>除此以外，还有一种简单的方法将两者统一：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> _Functor*
<span style="color: #008080;"> 3</span>   _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_get_pointer(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">const</span> _Functor* __ptr =
<span style="color: #008080;"> 7</span>       __stored_locally? std::__addressof(__source._M_access&lt;_Functor&gt;<span style="color: #000000;">())
</span><span style="color: #008080;"> 8</span>                       : __source._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">return</span> const_cast&lt;_Functor*&gt;<span style="color: #000000;">(__ptr);
</span><span style="color: #008080;">10</span>   }</pre>
</div>
<p>三目运算符的条件是一个静态常量，编译器会优化，不浪费程序空间，也不需要在运行时判断，效果与前一种方法相同。至于另外两个方法（指函数）为什么不用这种方法（指将两种情况统一的方法），可能是为了可读性吧。</p>
<h4><a name="mark_2_2_5"></a>2.2.5 根据形式区分仿函数类型</h4>
<p>在下面一层解决了不同存储结构的问题后，我们还要考虑几种特殊情况。</p>
<p><span class="cnblogs_code">_M_not_empty_function()</span>&nbsp;用于判断参数是否非空，而不同类型的判定方法是不同的。这里的解决方案很简单，模板方法重载即可。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   template&lt;typename _Signature&gt;
<span style="color: #008080;"> 3</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 4</span>     _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 5</span>     _M_not_empty_function(<span style="color: #0000ff;">const</span> function&lt;_Signature&gt;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;"> 6</span>     { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 9</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">11</span>     _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">12</span>     _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp*&amp;<span style="color: #000000;"> __fp)
</span><span style="color: #008080;">13</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __fp; }
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span> template&lt;typename _Functor&gt;
<span style="color: #008080;">16</span>   template&lt;typename _Class, typename _Tp&gt;
<span style="color: #008080;">17</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">18</span>     _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">19</span>     _M_not_empty_function(_Tp _Class::* <span style="color: #0000ff;">const</span>&amp;<span style="color: #000000;"> __mp)
</span><span style="color: #008080;">20</span>     { <span style="color: #0000ff;">return</span><span style="color: #000000;"> __mp; }
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> template&lt;typename _Functor&gt;
<span style="color: #008080;">23</span>   template&lt;typename _Tp&gt;
<span style="color: #008080;">24</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">25</span>     _Function_base::_Base_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">26</span>     _M_not_empty_function(<span style="color: #0000ff;">const</span> _Tp&amp;<span style="color: #000000;">)
</span><span style="color: #008080;">27</span>     { <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>; }</pre>
</div>
<p>在调用时，普通函数对象、<span class="cnblogs_code">std::reference_wrapper</span>&nbsp;对象与成员指针的调用方法是不同的，也需要分类讨论。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">2</span>   <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">3</span>   _Function_handler&lt;_Res(_ArgTypes...), _Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">4</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">5</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">6</span>     <span style="color: #0000ff;">return</span> (*<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">7</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">8</span>   }</pre>
</div>
<p>对于普通函数对象，函数调用没什么特殊的。注意自定义&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">operator</span>()</span>&nbsp;必须是&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">const</span></span>&nbsp;的。</p>
<p>对于&nbsp;<span class="cnblogs_code">std::reference_wrapper</span>&nbsp;对象，由于包装的对象存储为指针，因此存储结构与普通函数对象有所不同，相应地调用也不同。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span>   _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_init_functor(_Any_data&amp; __functor, reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 6</span>     _Base::_M_init_functor(__functor, std::__addressof(__f.<span style="color: #0000ff;">get</span><span style="color: #000000;">()));
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> template&lt;typename _Functor&gt;
<span style="color: #008080;">10</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">11</span>   _Function_base::_Ref_manager&lt;_Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">12</span>   _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;">13</span> <span style="color: #000000;">             _Manager_operation __op)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;">16</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  #ifdef __GXX_RTTI
</span><span style="color: #008080;">18</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">19</span>         __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">20</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">21</span>   <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">22</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">23</span>         __dest._M_access&lt;_Functor*&gt;() = *<span style="color: #000000;">_Base::_M_get_pointer(__source);
</span><span style="color: #008080;">24</span>         <span style="color: #0000ff;">return</span> is_const&lt;_Functor&gt;<span style="color: #000000;">::value;
</span><span style="color: #008080;">25</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span>       <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;">28</span> <span style="color: #000000;">        _Base::_M_manager(__dest, __source, __op);
</span><span style="color: #008080;">29</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">30</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">31</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span> template&lt;typename _Res, typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">34</span>   <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">35</span>   _Function_handler&lt;_Res(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;<span style="color: #000000;">::
</span><span style="color: #008080;">36</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">37</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">38</span>     <span style="color: #0000ff;">return</span> __callable_functor(**<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">39</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">40</span>   }</pre>
</div>
<p>碰到两个星号是不是有点晕？其实只要想，一般情况下存储函数对象的地方现在存储指针，所以要获得原始对象，只需要比一般情况多一次解引用，这样就容易理解了。</p>
<p>对于成员指针，情况又有一点不一样：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Class, typename _Member, typename... _ArgTypes&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span>
<span style="color: #008080;"> 3</span>   _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_manager(_Any_data&amp; __dest, <span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __source,
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">             _Manager_operation __op)
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (__op)
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">      {
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">#ifdef __GXX_RTTI
</span><span style="color: #008080;">10</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_type_info:
</span><span style="color: #008080;">11</span>         __dest._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;() = &amp;<span style="color: #000000;">typeid(_Functor);
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">14</span>       <span style="color: #0000ff;">case</span><span style="color: #000000;"> __get_functor_ptr:
</span><span style="color: #008080;">15</span>         __dest._M_access&lt;_Functor*&gt;() =
<span style="color: #008080;">16</span>           &amp;_Base::_M_get_pointer(__source)-&gt;<span style="color: #000000;">__value;
</span><span style="color: #008080;">17</span>         <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>       <span style="color: #0000ff;">default</span><span style="color: #000000;">:
</span><span style="color: #008080;">20</span> <span style="color: #000000;">        _Base::_M_manager(__dest, __source, __op);
</span><span style="color: #008080;">21</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">22</span>     <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">24</span> 
<span style="color: #008080;">25</span> template&lt;<span style="color: #000000;">typename _Class, typename _Member, typename _Res,
</span><span style="color: #008080;">26</span>          typename... _ArgTypes&gt;
<span style="color: #008080;">27</span>   <span style="color: #0000ff;">static</span><span style="color: #000000;"> _Res
</span><span style="color: #008080;">28</span>   _Function_handler&lt;_Res(_ArgTypes...), _Member _Class::*&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">29</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">30</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">31</span>     <span style="color: #0000ff;">return</span> std::mem_fn(_Base::_M_get_pointer(__functor)-&gt;<span style="color: #000000;">__value)(
</span><span style="color: #008080;">32</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">33</span>   }</pre>
</div>
<p>我一直说&ldquo;成员指针&rdquo;，而不是&ldquo;成员函数指针&rdquo;，是因为数据成员指针也是可以绑定的，这种情况在&nbsp;<span class="cnblogs_code">std::mem_fn()</span>&nbsp;中已经处理好了。</p>
<p><span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;返回类型的偏特化本应接下来讨论，但之前讲过，这个函数被通过继承复用了。实际上，如果把这里的&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span>&nbsp;改为模板类型，然后交换两个&nbsp;<span class="cnblogs_code">_Function_handler</span>&nbsp;偏特化的继承关系，效果还是一样的，所以就在这里先讨论了。</p>
<p>最后一个需要区分的类型，是返回值类型，属于接口类型。之前都是非&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;版本，下面还有几个&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span>&nbsp;的偏特化：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 3</span>   _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Functor&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 4</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 6</span>     (*<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;"> 7</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> template&lt;typename _Functor, typename... _ArgTypes&gt;
<span style="color: #008080;">11</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">12</span>   _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), reference_wrapper&lt;_Functor&gt; &gt;<span style="color: #000000;">::
</span><span style="color: #008080;">13</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">14</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">15</span>     __callable_functor(**<span style="color: #000000;">_Base::_M_get_pointer(__functor))(
</span><span style="color: #008080;">16</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">17</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span> template&lt;typename _Class, typename _Member, typename... _ArgTypes&gt;
<span style="color: #008080;">20</span>   <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span>
<span style="color: #008080;">21</span>   _Function_handler&lt;<span style="color: #0000ff;">void</span>(_ArgTypes...), _Member _Class::*&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">22</span>   _M_invoke(<span style="color: #0000ff;">const</span> _Any_data&amp;<span style="color: #000000;"> __functor, _ArgTypes... __args)
</span><span style="color: #008080;">23</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">24</span>     std::mem_fn(_Base::_M_get_pointer(__functor)-&gt;<span style="color: #000000;">__value)(
</span><span style="color: #008080;">25</span>         std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">26</span>   }</pre>
</div>
<p><span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;只是删除了&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">return</span></span>&nbsp;关键字的非&nbsp;<span class="cnblogs_code" style="color: #0000ff;">void</span>&nbsp;版本，因此&nbsp;<span class="cnblogs_code"><span style="color: #0000ff;">void</span></span>&nbsp;返回类型的&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;对象可以绑定任何返回值的函数对象。</p>
<h4><a name="mark_2_2_6"></a>2.2.6 实现组装成接口</h4>
<p>我们终于讨论完了各种情况，接下来让我们来见证&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;的大和谐：如何用这些方法组装成&nbsp;<span class="cnblogs_code">std::function</span> 。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">  1</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">  2</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">  3</span> <span style="color: #000000;">  function() noexcept
</span><span style="color: #008080;">  4</span> <span style="color: #000000;">  : _Function_base() { }
</span><span style="color: #008080;">  5</span> 
<span style="color: #008080;">  6</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">  7</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">  8</span> <span style="color: #000000;">  function(nullptr_t) noexcept
</span><span style="color: #008080;">  9</span> <span style="color: #000000;">  : _Function_base() { }
</span><span style="color: #008080;"> 10</span> 
<span style="color: #008080;"> 11</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 12</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 13</span>   function(function&amp;&amp;<span style="color: #000000;"> __x) : _Function_base()
</span><span style="color: #008080;"> 14</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 15</span>     __x.swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 16</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 17</span> 
<span style="color: #008080;"> 18</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 19</span> <span style="color: #000000;">  auto
</span><span style="color: #008080;"> 20</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 21</span>   <span style="color: #0000ff;">operator</span>=(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;"> 22</span>   -&gt; function&amp;
<span style="color: #008080;"> 23</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 24</span>     function(__x).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 25</span>     <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 26</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 27</span> 
<span style="color: #008080;"> 28</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 29</span> <span style="color: #000000;">  auto
</span><span style="color: #008080;"> 30</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 31</span>   <span style="color: #0000ff;">operator</span>=(function&amp;&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;"> 32</span>   -&gt; function&amp;
<span style="color: #008080;"> 33</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 34</span>     function(std::move(__x)).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 35</span>     <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 36</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 37</span> 
<span style="color: #008080;"> 38</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 39</span> <span style="color: #000000;">  auto
</span><span style="color: #008080;"> 40</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 41</span>   <span style="color: #0000ff;">operator</span>=<span style="color: #000000;">(nullptr_t)
</span><span style="color: #008080;"> 42</span>   -&gt; function&amp;
<span style="color: #008080;"> 43</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 44</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;"> 45</span> <span style="color: #000000;">      {
</span><span style="color: #008080;"> 46</span> <span style="color: #000000;">        _M_manager(_M_functor, _M_functor, __destroy_functor);
</span><span style="color: #008080;"> 47</span>         _M_manager = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 48</span>         _M_invoker = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 49</span> <span style="color: #000000;">      }
</span><span style="color: #008080;"> 50</span>     <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 51</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 52</span> 
<span style="color: #008080;"> 53</span> template&lt;typename _Functor&gt;
<span style="color: #008080;"> 54</span> <span style="color: #000000;">  auto
</span><span style="color: #008080;"> 55</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 56</span>   <span style="color: #0000ff;">operator</span>=(_Functor&amp;&amp;<span style="color: #000000;"> __f)
</span><span style="color: #008080;"> 57</span>   -&gt; _Requires&lt;_Callable&lt;_Functor&gt;, function&amp;&gt;
<span style="color: #008080;"> 58</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 59</span>     function(std::forward&lt;_Functor&gt;(__f)).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 60</span>     <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 61</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 62</span> 
<span style="color: #008080;"> 63</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 64</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;"> 65</span> <span style="color: #000000;">    auto
</span><span style="color: #008080;"> 66</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 67</span>     -&gt; function&amp;
<span style="color: #008080;"> 68</span>     <span style="color: #0000ff;">operator</span>=(reference_wrapper&lt;_Functor&gt;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;"> 69</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 70</span>       function(__f).swap(*<span style="color: #0000ff;">this</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 71</span>       <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 72</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 73</span> 
<span style="color: #008080;"> 74</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 75</span>   <span style="color: #0000ff;">void</span>
<span style="color: #008080;"> 76</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 77</span>   swap(function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;"> 78</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 79</span> <span style="color: #000000;">    std::swap(_M_functor, __x._M_functor);
</span><span style="color: #008080;"> 80</span> <span style="color: #000000;">    std::swap(_M_manager, __x._M_manager);
</span><span style="color: #008080;"> 81</span> <span style="color: #000000;">    std::swap(_M_invoker, __x._M_invoker);
</span><span style="color: #008080;"> 82</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 83</span> 
<span style="color: #008080;"> 84</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 85</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 86</span>   <span style="color: #0000ff;">operator</span> <span style="color: #0000ff;">bool</span>() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;"> 87</span>   { <span style="color: #0000ff;">return</span> !<span style="color: #000000;">_M_empty(); }
</span><span style="color: #008080;"> 88</span> 
<span style="color: #008080;"> 89</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;"> 90</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;"> 91</span>   function(<span style="color: #0000ff;">const</span> function&amp;<span style="color: #000000;"> __x)
</span><span style="color: #008080;"> 92</span> <span style="color: #000000;">  : _Function_base()
</span><span style="color: #008080;"> 93</span> <span style="color: #000000;">  {
</span><span style="color: #008080;"> 94</span>     <span style="color: #0000ff;">if</span> (static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__x))
</span><span style="color: #008080;"> 95</span> <span style="color: #000000;">      {
</span><span style="color: #008080;"> 96</span>         _M_invoker =<span style="color: #000000;"> __x._M_invoker;
</span><span style="color: #008080;"> 97</span>         _M_manager =<span style="color: #000000;"> __x._M_manager;
</span><span style="color: #008080;"> 98</span> <span style="color: #000000;">        __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
</span><span style="color: #008080;"> 99</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">100</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">101</span> 
<span style="color: #008080;">102</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">103</span>   template&lt;typename _Functor, typename&gt;
<span style="color: #008080;">104</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">105</span> <span style="color: #000000;">    function(_Functor __f)
</span><span style="color: #008080;">106</span> <span style="color: #000000;">    : _Function_base()
</span><span style="color: #008080;">107</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">108</span>       typedef _Function_handler&lt;_Signature_type, _Functor&gt;<span style="color: #000000;"> _My_handler;
</span><span style="color: #008080;">109</span> 
<span style="color: #008080;">110</span>       <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_My_handler::_M_not_empty_function(__f))
</span><span style="color: #008080;">111</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">112</span> <span style="color: #000000;">          _My_handler::_M_init_functor(_M_functor, std::move(__f));
</span><span style="color: #008080;">113</span>           _M_invoker = &amp;<span style="color: #000000;">_My_handler::_M_invoke;
</span><span style="color: #008080;">114</span>           _M_manager = &amp;<span style="color: #000000;">_My_handler::_M_manager;
</span><span style="color: #008080;">115</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">116</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">117</span> 
<span style="color: #008080;">118</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">119</span> <span style="color: #000000;">  _Res
</span><span style="color: #008080;">120</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">121</span>   <span style="color: #0000ff;">operator</span>()(_ArgTypes... __args) <span style="color: #0000ff;">const</span>
<span style="color: #008080;">122</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">123</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_empty())
</span><span style="color: #008080;">124</span> <span style="color: #000000;">      __throw_bad_function_call();
</span><span style="color: #008080;">125</span>     <span style="color: #0000ff;">return</span> _M_invoker(_M_functor, std::forward&lt;_ArgTypes&gt;<span style="color: #000000;">(__args)...);
</span><span style="color: #008080;">126</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">127</span> 
<span style="color: #008080;">128</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">129</span>   <span style="color: #0000ff;">const</span> type_info&amp;
<span style="color: #008080;">130</span>   function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">131</span>   target_type() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;">132</span> <span style="color: #000000;">  {
</span><span style="color: #008080;">133</span>     <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager)
</span><span style="color: #008080;">134</span> <span style="color: #000000;">      {
</span><span style="color: #008080;">135</span> <span style="color: #000000;">        _Any_data __typeinfo_result;
</span><span style="color: #008080;">136</span> <span style="color: #000000;">        _M_manager(__typeinfo_result, _M_functor, __get_type_info);
</span><span style="color: #008080;">137</span>         <span style="color: #0000ff;">return</span> *__typeinfo_result._M_access&lt;<span style="color: #0000ff;">const</span> type_info*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">138</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">139</span>     <span style="color: #0000ff;">else</span>
<span style="color: #008080;">140</span>       <span style="color: #0000ff;">return</span> typeid(<span style="color: #0000ff;">void</span><span style="color: #000000;">);
</span><span style="color: #008080;">141</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">142</span> 
<span style="color: #008080;">143</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">144</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">145</span>     _Functor*
<span style="color: #008080;">146</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">147</span> <span style="color: #000000;">    target() noexcept
</span><span style="color: #008080;">148</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">149</span>       <span style="color: #0000ff;">if</span> (typeid(_Functor) == target_type() &amp;&amp;<span style="color: #000000;"> _M_manager)
</span><span style="color: #008080;">150</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">151</span> <span style="color: #000000;">          _Any_data __ptr;
</span><span style="color: #008080;">152</span>           <span style="color: #0000ff;">if</span><span style="color: #000000;"> (_M_manager(__ptr, _M_functor, __get_functor_ptr)
</span><span style="color: #008080;">153</span>               &amp;&amp; !is_const&lt;_Functor&gt;<span style="color: #000000;">::value)
</span><span style="color: #008080;">154</span>             <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">155</span>           <span style="color: #0000ff;">else</span>
<span style="color: #008080;">156</span>             <span style="color: #0000ff;">return</span> __ptr._M_access&lt;_Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">157</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">158</span>       <span style="color: #0000ff;">else</span>
<span style="color: #008080;">159</span>         <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">160</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">161</span> 
<span style="color: #008080;">162</span> template&lt;typename _Res, typename... _ArgTypes&gt;
<span style="color: #008080;">163</span>   template&lt;typename _Functor&gt;
<span style="color: #008080;">164</span>     <span style="color: #0000ff;">const</span> _Functor*
<span style="color: #008080;">165</span>     function&lt;_Res(_ArgTypes...)&gt;<span style="color: #000000;">::
</span><span style="color: #008080;">166</span>     target() <span style="color: #0000ff;">const</span><span style="color: #000000;"> noexcept
</span><span style="color: #008080;">167</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">168</span>       <span style="color: #0000ff;">if</span> (typeid(_Functor) == target_type() &amp;&amp;<span style="color: #000000;"> _M_manager)
</span><span style="color: #008080;">169</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">170</span> <span style="color: #000000;">          _Any_data __ptr;
</span><span style="color: #008080;">171</span> <span style="color: #000000;">          _M_manager(__ptr, _M_functor, __get_functor_ptr);
</span><span style="color: #008080;">172</span>           <span style="color: #0000ff;">return</span> __ptr._M_access&lt;<span style="color: #0000ff;">const</span> _Functor*&gt;<span style="color: #000000;">();
</span><span style="color: #008080;">173</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">174</span>       <span style="color: #0000ff;">else</span>
<span style="color: #008080;">175</span>         <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">176</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">177</span> 
<span style="color: #008080;">178</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">179</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">180</span>   <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept
</span><span style="color: #008080;">181</span>   { <span style="color: #0000ff;">return</span> !static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">182</span> 
<span style="color: #008080;">183</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">184</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">185</span>   <span style="color: #0000ff;">operator</span>==(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;">186</span>   { <span style="color: #0000ff;">return</span> !static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">187</span> 
<span style="color: #008080;">188</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">189</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">190</span>   <span style="color: #0000ff;">operator</span>!=(<span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f, nullptr_t) noexcept
</span><span style="color: #008080;">191</span>   { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">192</span> 
<span style="color: #008080;">193</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">194</span>   inline <span style="color: #0000ff;">bool</span>
<span style="color: #008080;">195</span>   <span style="color: #0000ff;">operator</span>!=(nullptr_t, <span style="color: #0000ff;">const</span> function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __f) noexcept
</span><span style="color: #008080;">196</span>   { <span style="color: #0000ff;">return</span> static_cast&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;">(__f); }
</span><span style="color: #008080;">197</span> 
<span style="color: #008080;">198</span> template&lt;typename _Res, typename... _Args&gt;
<span style="color: #008080;">199</span>   inline <span style="color: #0000ff;">void</span>
<span style="color: #008080;">200</span>   swap(function&lt;_Res(_Args...)&gt;&amp; __x, function&lt;_Res(_Args...)&gt;&amp;<span style="color: #000000;"> __y)
</span><span style="color: #008080;">201</span>   { __x.swap(__y); }</pre>
</div>
<p>我们从&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;开始入手。<span class="cnblogs_code">swap()</span>&nbsp;方法只是简单地将三个数据成员交换了一下，这是正确的，因为它们存储的都是POD类型。我认为，这个实现对函数对象存储在本地的条件的限制太过严格，大小合适的可trivial复制的函数对象也应该可以存储在本地。</p>
<p>在&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;的基础上，拷贝构造、移动构造、拷贝赋值、移动赋值函数很自然地构建起来了，而且只用到了&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;方法。这种技巧称为<a title="What is the copy-and-swap idiom?" href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom" target="_blank">copy-and-swap</a>。这也就解释了为什么&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;需要那么多延迟调用的操作而表示操作的枚举类只需要定义4种操作。</p>
<p><span class="cnblogs_code">swap()</span>&nbsp;还可以成为异常安全的基础。由于以上方法只涉及到&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;，而&nbsp;<span class="cnblogs_code">swap()</span>&nbsp;方法是不抛异常的，因此两个移动函数是&nbsp;<span class="cnblogs_code">noexcept</span>&nbsp;的，两个拷贝函数也能保证在栈空间足够时不抛异常，在抛异常时不会出现内存泄漏。</p>
<p>其余的方法，有了前面的基础，看代码就能读懂了。</p>
<p>&nbsp;</p>
<h3><a name="mark_epilogue"></a><span style="font-size: 20px;">后记</span></h3>
<p>写这篇文章花了好久呀。这是我第一次写这么长的博客，希望你能有所收获。如果有不懂的地方，可以在评论区留言。如果有任何错误，烦请指正。</p>
<p>我是从实现的角度来写的这篇文章，如果你对其中的一些技巧（SFINAE、tag dispatching）不太熟悉的话，理解起来可能有点困难。<a title="std::function 基本实现" href="http://blog.bitfoc.us/p/525" target="_blank">相关资料[8]</a>介绍了&nbsp;<span class="cnblogs_code">function</span>&nbsp;类的设计思路，从无到有的构建过程比较容易理解。<a title="std::function 源码分析" href="https://my.oschina.net/u/1866819/blog/614382" target="_blank">相关资料[9]</a>分析了另一个版本的&nbsp;<span class="cnblogs_code">std::function</span>&nbsp;实现，可供参考。</p>
<p>文章内容已经很充实了，但是没有图片，不太直观。有空我会加上图片的，这样更容易理解。</p>
<p>另外，在我实现完自己的&nbsp;<span class="cnblogs_code">function</span>&nbsp;类以后，还会对这篇文章作一点补充。自己造一遍轮子，总会有更深刻的感受吧。</p>
<p>&nbsp;</p>
<h3><a name="mark_appendix"></a><span style="font-size: 20px;">附录</span></h3>
<p>相关资料：</p>
<p>[1]&nbsp;<a title="Naive std::function implementation" href="https://shaharmike.com/cpp/naive-std-function/" target="_blank">Naive std::function implementation</a></p>
<p>[2]&nbsp;<a title="How is std::function implemented?" href="https://stackoverflow.com/questions/18453145/how-is-stdfunction-implemented" target="_blank">How is std::function implemented?<br /></a></p>
<p>[3]&nbsp;<a title="std::function - cppreference.com" href="https://en.cppreference.com/w/cpp/utility/functional/function" target="_blank">std::function - cppreference.com</a></p>
<p>[4]&nbsp;<a title="The space of design choices for std::function" href="https://quuxplusone.github.io/blog/2019/03/27/design-space-for-std-function/" target="_blank">The space of design choices for std::function</a></p>
<p>[5]&nbsp;<a title="How true is &ldquo;Want Speed? Pass by value&rdquo;" href="https://stackoverflow.com/questions/21605579/how-true-is-want-speed-pass-by-value" target="_blank">How true is &ldquo;Want Speed? Pass by value&rdquo;</a></p>
<p>[6]&nbsp;<a title="C++奇淫巧技之SFINAE" href="https://www.jianshu.com/p/45a2410d4085" target="_blank">C++奇淫巧技之SFINAE</a></p>
<p>[7]&nbsp;<a title="What is the copy-and-swap idiom?" href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom" target="_blank">What is the copy-and-swap idiom?</a></p>
<p>[8]&nbsp;<a title="std::function 基本实现" href="http://blog.bitfoc.us/p/525" target="_blank">std::function 基本实现</a></p>
<p>[9]&nbsp;<a title="std::function 源码分析" href="https://my.oschina.net/u/1866819/blog/614382" target="_blank">std::function 源码分析</a></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>