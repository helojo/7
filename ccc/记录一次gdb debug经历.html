<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修记录一次gdb debug经历' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>记录一次gdb debug经历</center></div><div class='banquan'>原文出处:本文由博客园博主gatsby123提供。<br/>
原文连接:https://www.cnblogs.com/gatsby123/p/11755320.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#问题描述">问题描述</a></li>
        <li><a href="#查看core文件">查看core文件</a></li>
        <li><a href="#使用gdb查看core文件">使用gdb查看core文件</a></li>
        <li><a href="#总结">总结</a></li>
        </ul>
    </div>
</div>
<h2 id="问题描述">问题描述</h2>
<p>今天在写代码时，运行时奔溃了。segment fault，而且是在程序退出main()函数后，才报的。<br />
唯一的信息是：<code>Segmentation fault (core dumped)</code><br />
简直是一头雾水。</p>
<h2 id="查看core文件">查看core文件</h2>
<p>系统默认是不会生成core文件的，<code>ulimit -c unlimited</code>把core文件设为无限大。</p>
<h2 id="使用gdb查看core文件">使用gdb查看core文件</h2>
<p><code>gdb ./example/sudoku_batch_test core</code><br />
提示如下：</p>
<pre><code>Program terminated with signal SIGSEGV, Segmentation fault.
#0  __GI___libc_free (mem=0x313030303030300a) at malloc.c:2951
2951    malloc.c: No such file or directory.
(gdb) </code></pre>
<p>可以确定崩溃发生在malloc.c中。但是提示没有malloc.c的源码。</p>
<p>首先安装glibc的符号表，命令如下：<br />
<code>sudo apt-get install libc6-dbg</code></p>
<p>再来是安装glibc的源文件，命令如下：<br />
<code>sudo apt-get source libc6-dev</code><br />
安装完毕后在当前目录下会多出一个glibc-2.23文件夹，该文件夹包含了glibc的源码。</p>
<p>源码准备就绪后，接着上面，在gdb命令提示符下输入：<br />
<code>directory glibc-2.23/malloc/</code>将glibc-2.23/malloc/设为gdb源码搜索目录。结果如下：</p>
<pre><code>warning: core file may not match specified executable file.
[New LWP 24491]
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
Core was generated by `./example/sudoku_batch_test ../example/test1000 127.0.0.1 1&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __GI___libc_free (mem=0x313030303030300a) at malloc.c:2951
2951    malloc.c: No such file or directory.
(gdb) directory glibc-2.23/malloc/
Source directories searched: /root/work/melon/build/glibc-2.23/malloc:$cdir:$cwd
(gdb) </code></pre>
<p>现在我们就可以在gdb中查看崩溃处的源码了，执行<code>list</code>：</p>
<pre><code>(gdb) l
warning: Source file is more recent than executable.
2946      if (mem == 0)                              /* free(0) has no effect */
2947        return;
2948    
2949      p = mem2chunk (mem);
2950    
2951      if (chunk_is_mmapped (p))                       /* release mmapped memory. */
2952        {
2953          /* see if the dynamic brk/mmap threshold needs adjusting */
2954          if (!mp_.no_dyn_threshold
2955              &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold
(gdb) </code></pre>
<p>虽然知道了崩溃发生在2951行，但是貌似没有更多有效的信息。这时我想到了是不是可以看下函数的调用栈，或许会有信息。<br />
接着执行backtrace(或者bt)：</p>
<pre><code>(gdb) bt
#0  __GI___libc_free (mem=0x313030303030300a) at malloc.c:2951
#1  0x000000000048bc9d in melon::Coroutine::~Coroutine (this=0x1fc9120, __in_chrg=&lt;optimized out&gt;)
    at /root/work/melon/src/Coroutine.cpp:56
#2  0x000000000048d099 in std::_Sp_counted_ptr&lt;melon::Coroutine*, (__gnu_cxx::_Lock_policy)2&gt;::_M_dispose (
    this=0x1fc8190) at /usr/include/c++/5/bits/shared_ptr_base.h:374
#3  0x00000000004630f1 in std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_release (this=0x1fc8190)
    at /usr/include/c++/5/bits/shared_ptr_base.h:150
#4  0x0000000000461f32 in std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt;::~__shared_count (this=0x7f07f4ff1770, 
    __in_chrg=&lt;optimized out&gt;) at /usr/include/c++/5/bits/shared_ptr_base.h:659
#5  0x00000000004749ed in std::__shared_ptr&lt;melon::Coroutine, (__gnu_cxx::_Lock_policy)2&gt;::~__shared_ptr (
    this=0x7f07f4ff1768, __in_chrg=&lt;optimized out&gt;) at /usr/include/c++/5/bits/shared_ptr_base.h:925
#6  0x0000000000474a39 in std::shared_ptr&lt;melon::Coroutine&gt;::~shared_ptr (this=0x7f07f4ff1768, 
    __in_chrg=&lt;optimized out&gt;) at /usr/include/c++/5/bits/shared_ptr.h:93
#7  0x00007f07f40915ff in __GI___call_tls_dtors () at cxa_thread_atexit_impl.c:155
#8  0x00007f07f4090f27 in __run_exit_handlers (status=0, listp=0x7f07f441b5f8 &lt;__exit_funcs&gt;, 
    run_list_atexit=run_list_atexit@entry=true) at exit.c:40
#9  0x00007f07f4091045 in __GI_exit (status=&lt;optimized out&gt;) at exit.c:104
#10 0x00007f07f4077837 in __libc_start_main (main=0x45f1c4 &lt;main(int, char**)&gt;, argc=4, argv=0x7ffcfb2ab218, 
    init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffcfb2ab208)
    at ../csu/libc-start.c:325
#11 0x000000000045ec89 in _start ()</code></pre>
<p>这下问题找到了，首先在线程结束或者程序运行结束会调用__GI___call_tls_dtors函数来析构线程本地存储。我确实用了thread_local关键字修饰Coroutine::Ptr变量。<br />
从<code>#1  0x000000000048bc9d in melon::Coroutine::~Coroutine</code>可知在melon::Coroutine类的析构函数中调用了free()导致奔溃。<br />
这下问题基本明确了，我在Coroutine析构函数中会释放stack_这个指针，</p>
<pre class="cpp"><code> 53 Coroutine::~Coroutine() {
 54     LOG_DEBUG &lt;&lt; &quot;destroy coroutine:&quot; &lt;&lt; name_;
 55     if (stack_) {
 56         free(stack_);
 57     }
 58 }</code></pre>
<p>有两个构造函数，其中一个如下：</p>
<pre class="cpp"><code> 39 Coroutine::Coroutine()
 40     :c_id_(++t_coroutine_id),
 41     name_(&quot;Main-&quot; + std::to_string(c_id_)),
 42     cb_(nullptr),
 43     state_(CoroutineState::INIT) {
 44 
 45     if (getcontext(&amp;context_)) {
 46         LOG_ERROR &lt;&lt; &quot;getcontext: errno=&quot; &lt;&lt; errno
 47                 &lt;&lt; &quot; error string:&quot; &lt;&lt; strerror(errno);
 58     }
 59 }</code></pre>
<p>因为大意犯了个非常低级的错误，这个构造函数没有正确初始化statck_指针，将statck_初始化为nullptr后，问题就解决了。</p>
<p><strong>update：2019-10-31</strong><br />
其实不用这么麻烦，gdb有个where命令，能直接打印出函数栈信息。</p>
<h2 id="总结">总结</h2>
<p>遇到这类问题，一般用gdb查看core文件都能定位到崩溃的位置，如果不是直接引发的，可以查看函数调用栈，一般都能找到问题原因。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>