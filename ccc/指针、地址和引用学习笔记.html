<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修指针、地址和引用学习笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>指针、地址和引用学习笔记</center></div><div class='banquan'>原文出处:本文由博客园博主还没有女朋友的执念提供。<br/>
原文连接:https://www.cnblogs.com/lxy764139720/p/10810232.html</div><br>
    <p><span style="color: #ff0000; font-size: 18px;"><strong>一、指针</strong></span><br /><strong>&nbsp;1、指针是一种存放内存地址的数据类型</strong><br />&nbsp;<strong>2、指针的创建</strong> <br />&nbsp;&nbsp;typename * p;//空格可有可无<br />&nbsp;&nbsp;此时p的类型为（typename *）<br />&nbsp;&nbsp;（*p）的类型为typename<br />&nbsp;&nbsp;初始化一个指针后，该指针变量会被存放在内存中的某个地址<br />&nbsp;&nbsp;指针创建时可以不初始化</p>
<div class="cnblogs_code">
<pre>  如：<span style="color: #0000ff;">int</span> * p1;<span style="color: #008000;">//</span><span style="color: #008000;">p1的类型为（int *），（*p1）的类型为int</span>
   <span style="color: #0000ff;">float</span> * p2;<span style="color: #008000;">//</span><span style="color: #008000;">p2的类型为（float *），（*p2）的类型为float</span>
   <span style="color: #0000ff;">char</span> * p3;<span style="color: #008000;">//</span><span style="color: #008000;">p3的类型为（char *），（*p3）的类型为char</span></pre>
</div>
<p><strong>3、对其赋值后，其对应内存位置存放的值被解释为一个地址，称该地址为其所指向的地址或内存空间</strong></p>
<div class="cnblogs_code">
<pre>  如：p1=（<span style="color: #0000ff;">int</span> *）<span style="color: #800080;">50000</span>；<span style="color: #008000;">//</span><span style="color: #008000;">p1在内存中的地址为xxxxx，p所指向的地址为50000</span>
   <span style="color: #0000ff;">float</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
   p2</span>= &amp;a; <span style="color: #008000;">//</span><span style="color: #008000;">p1在内存中的地址为yyyyy，p所指向的地址为a所在的地址</span></pre>
</div>
<p><strong>4、间接引用运算符*</strong></p>
<p>&nbsp;&nbsp;①类型名执行*运算得到一个指向该类型的指针类型，即地址<br />&nbsp;&nbsp;即（typename *）表示一个指向typename类型的指针类型<br />&nbsp;&nbsp;②变量名执行*运算得到该变量指向的内容，即去地址<br />&nbsp;&nbsp;即当p为一个（typename *）类型的指针变量时，（*p）代表从p所指向的地址处起始的大小为sizeof（typename）个字节的内容，这些内容的数据类型被解释为typename<br />&nbsp;&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> 如：p = （<span style="color: #0000ff;">int</span>*）a;<span style="color: #008000;">//</span><span style="color: #008000;">将a转换为指向int的指针类型，赋值给p</span>
<span style="color: #008080;">2</span>    <span style="color: #0000ff;">int</span> length = <span style="color: #0000ff;">sizeof</span>（typename *）;<span style="color: #008000;">//</span><span style="color: #008000;">length为该环境下地址变量的长度</span>
<span style="color: #008080;">3</span>    *p = <span style="color: #800080;">4000</span>;<span style="color: #008000;">//</span><span style="color: #008000;">向地址从50000处开始的sizeof（int）个字节的内存空间里写入4000</span>
<span style="color: #008080;">4</span>    <span style="color: #0000ff;">int</span> n = *p;<span style="color: #008000;">//</span><span style="color: #008000;">将地址从50000处开始的sizeof（int）个字节的内存空间里表示的int型数据，即4000，赋值给n</span></pre>
</div>
<p><strong>5、指针常量、常（量）指针和常（量）指针常量</strong></p>
<p>&nbsp;&nbsp;①指针常量：typename * const p = &amp;a;<br />&nbsp;&nbsp;&nbsp;指针是常量<br />&nbsp;&nbsp;&nbsp;指针p的指向不能改变，但指针p指向的内容，即a的值，可以改变<br />&nbsp;&nbsp;&nbsp;相当于一个引用，创建时必须初始化<br />&nbsp;&nbsp;②常（量）指针：const typename * p;<br />&nbsp;&nbsp;&nbsp;常量的指针<br />&nbsp;&nbsp;&nbsp;指针p的指向可以改变，但指针p指向的内容必须是常量<br />&nbsp;&nbsp;&nbsp;创建时可以不初始化<br />&nbsp;&nbsp;③常（量）指针常量：const typename * const p = &amp;a;<br />&nbsp;&nbsp;&nbsp;既是常量指针又是指针常量<br />&nbsp;&nbsp;&nbsp;指针p的指向和指针p指向的内容都不能改变<br />&nbsp;&nbsp;&nbsp;相当于一个指向常量的引用，创建时必须初始化<br /><strong>&nbsp;6、空指针</strong><br />&nbsp;&nbsp;空指针是指向地址0的指针，其值为NULL或0<br />&nbsp;&nbsp;创建后未经初始化的指针都是空指针<br /><strong>&nbsp;7、指针传递</strong><br />&nbsp;&nbsp;传递指针时，形参在栈中新开辟一块内存空间，并将实参的值，即地址，赋值给形参<br />&nbsp;&nbsp;形参的值是实参的值的拷贝或副本</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #000000;">例1：
</span><span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 3</span>    <span style="color: #0000ff;">int</span> a=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>    <span style="color: #0000ff;">int</span> * p = &amp;<span style="color: #000000;"> a;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">   f(p);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">void</span> f(<span style="color: #0000ff;">int</span> * pr){<span style="color: #008000;">//</span><span style="color: #008000;">此时pr的地址和p不同，但存放的值是同一个地址</span>
<span style="color: #008080;"> 8</span>    (*pr)++<span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span>   }<span style="color: #008000;">//</span><span style="color: #008000;">运行结果为a的值变为了2</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">  例2：
</span><span style="color: #008080;">11</span>   <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">12</span>    <span style="color: #0000ff;">int</span> a=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">13</span>    <span style="color: #0000ff;">int</span> * p = &amp;<span style="color: #000000;"> a;
</span><span style="color: #008080;">14</span>    f(&amp;<span style="color: #000000;">p);
</span><span style="color: #008080;">15</span> <span style="color: #000000;">  }
</span><span style="color: #008080;">16</span>   <span style="color: #0000ff;">void</span> f(<span style="color: #0000ff;">int</span> ** pr){<span style="color: #008000;">//</span><span style="color: #008000;">此时pr的地址和p不同，但存放的值是同一个地址</span>
<span style="color: #008080;">17</span>    (*pr)++;<span style="color: #008000;">//</span><span style="color: #008000;">此时pr存放的值发生了改变</span>
<span style="color: #008080;">18</span>   }<span style="color: #008000;">//</span><span style="color: #008000;">运行结果为p指向了下一个地址</span></pre>
</div>
<p><strong>8、一些特性</strong></p>
<p>&nbsp;&nbsp;①sizeof（typename *）和sizeof（p）表达式的结果为该环境下指针类型，即地址，所占的字节<br />&nbsp;&nbsp;②支持多级指针，即（typename **）<br />&nbsp;&nbsp;③指针变量，即p，执行++、--运算的含义是指针p指向下一个地址<br />&nbsp;&nbsp;&nbsp; 指针变量执行*运算符后，即（*p），执行++、--运算的含义是（*p）表示的值的加减<br />&nbsp;&nbsp;④由于指针变量可以为空，所以使用指针变量之前必须进行判空操作<br />&nbsp;<br /><span style="color: #ff0000; font-size: 18px;"><strong>二、引用</strong></span><br /><strong>&nbsp;1、引用是一个对象的别名，本质上还是一个指针常量或地址</strong><br /><strong>&nbsp;2、引用的初始化</strong><br />&nbsp;&nbsp;typename &amp; q = a;//空格可有可无<br />&nbsp;&nbsp;引用对象创建时必须初始化，且引用的值一经初始化即不得改变</p>
<div class="cnblogs_code">
<pre>  如：<span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
   </span><span style="color: #0000ff;">int</span> &amp; q1 = a;<span style="color: #008000;">//</span><span style="color: #008000;">q1始终为a的引用</span></pre>
</div>
<p><strong>3、取地址运算符&amp;</strong></p>
<p>&nbsp;&nbsp;①类型名执行&amp;运算，即（typename &amp;），得到一个引用类型<br />&nbsp;&nbsp;②变量名执行&amp;运算得到一个地址，即取地址<br />&nbsp;&nbsp;即当a为一个变量名时，（&amp; a）表示a在内存中的地址<br /><strong>&nbsp;4、常（量）引用</strong><br />&nbsp;&nbsp;const typename &amp; q = a;<br />&nbsp;&nbsp;&nbsp;常量的引用<br />&nbsp;&nbsp;&nbsp;引用q的内容，即a，是一个常量<br />&nbsp;&nbsp;&nbsp;相当于一个常量指针，创建时必须初始化<br />&nbsp;&nbsp;没有引用常量和常（量）引用常量，因为引用本身就具有其指向不能改变的特性<br /><strong>&nbsp;5、引用传递</strong><br />&nbsp;&nbsp;传递引用时，形参不会在内存中开辟一块存储空间，而是形参和实参共用相同的地址，形参的值和实参的值是同一个</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #000000;">  例：
</span><span style="color: #008080;"> 2</span>   <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;"> 3</span>    <span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>    <span style="color: #0000ff;">int</span> &amp; q =<span style="color: #000000;"> a;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">   f(q);
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">  }
</span><span style="color: #008080;"> 7</span>   <span style="color: #0000ff;">void</span> f(<span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;"> qr){
</span><span style="color: #008080;"> 8</span>    qr++;<span style="color: #008000;">//</span><span style="color: #008000;">运行结果为a的值变为了2
</span><span style="color: #008080;"> 9</span>    <span style="color: #008000;">//</span><span style="color: #008000;">(*qr)++;错误，编译器不认为qr是一个地址，而认为是一个int型的变量，即a的类型</span>
<span style="color: #008080;">10</span>   }</pre>
</div>
<p><strong>6、一些特性</strong></p>
<p>&nbsp;&nbsp;①sizeof（typename &amp;）表达式的结果为typename类型所占的字节<br />&nbsp;&nbsp;&nbsp; sizeof（q）表达式的结果为引用q的对象所占的字节<br />&nbsp;&nbsp;②不支持多级引用<br />&nbsp;&nbsp;③引用q执行++、--运算的含义是引用q的对象的值的加减<br />&nbsp;&nbsp;④由于引用不会为空，所以使用引用之前不必进行判空操作</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>