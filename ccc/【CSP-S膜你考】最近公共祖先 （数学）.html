<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修【CSP-S膜你考】最近公共祖先 （数学）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>【CSP-S膜你考】最近公共祖先 （数学）</center></div><div class='banquan'>原文出处:本文由博客园博主yu__xuan提供。<br/>
原文连接:https://www.cnblogs.com/poi-bolg-poi/p/11661517.html</div><br>
    <h2 id="problem-a.-最近公共祖先-commonants.ccpppas">Problem A. 最近公共祖先 (commonants.c/cpp/pas)</h2>
<h3 id="注意">注意</h3>
<p>Input file: commonants.in<br />
Output file: commonants.out<br />
Time Limit : 0.5 seconds<br />
Memory Limit: 512 megabytes</p>
<h3 id="题面">题面</h3>
<p>最近公共祖先<span class="math inline">\(\text{(Lowest Common Ancestor,LCA)}\)</span>是指在一个树中同时拥有给定的两个点作为后<br />
代的最深的节点。<br />
为了学习最近公共祖先，你得到了一个层数为<span class="math inline">\(n+1\)</span>的满二叉树，其中根节点的深度为<span class="math inline">\(0\)</span>，其他节点的深度为父节点的深度<span class="math inline">\(+1\)</span>。你需要求出二叉树上所有点对 <span class="math inline">\(\texttt{(i,j)}\)</span>,（<span class="math inline">\(i\)</span>,<span class="math inline">\(j\)</span>可以相等，也可以<span class="math inline">\(i &gt; j\)</span>）的最近公共祖先的深度之和对<span class="math inline">\(10^9+7\)</span>取模后的结果。</p>
<h3 id="输入格式">输入格式</h3>
<p>一行一个整数<span class="math inline">\(n\)</span>。</p>
<h3 id="输出格式">输出格式</h3>
<p>一行一个整数表示所有点对 <span class="math inline">\(\texttt{(i,j)}\)</span>,（<span class="math inline">\(i\)</span>,<span class="math inline">\(j\)</span>可以相等，也可以<span class="math inline">\(i &gt; j\)</span>）的最近公共祖先的深度之和对<span class="math inline">\(10^9+7\)</span>取模后的结果。</p>
<h3 id="样例">样例</h3>
<p><span class="math inline">\(\texttt{input\#1}\)</span><br />
2</p>
<p><span class="math inline">\(\texttt{input\#2}\)</span><br />
19260817</p>
<p><span class="math inline">\(\texttt{output\#1}\)</span><br />
22</p>
<p><span class="math inline">\(\texttt{output\#2}\)</span><br />
108973412</p>
<h3 id="数据范围与提示">数据范围与提示</h3>
<p>样例<span class="math inline">\(1\)</span>解释：<br />
<img src="./images/【CSP-S膜你考】最近公共祖先 （数学）0.png" /></p>
<p>树一共有<span class="math inline">\(7\)</span>个节点（一个根节点和两个子节点），其中 <span class="math inline">\(\texttt{(4,4),(5,5),(6,6),(7,7)}\)</span> 共<span class="math inline">\(4\)</span>对的最近公共祖先深度为<span class="math inline">\(2\)</span>，<span class="math inline">\(\texttt{(4,2),(2,4),(5,2),(2,5),(5,4),(4,5),(2,2),(6,3),(3,6),(3,7),(7,3),(6,7),}\)</span><span class="math inline">\(\texttt{(7,6),(3,3)}\)</span>共<span class="math inline">\(14\)</span>对最近公共祖先深度是<span class="math inline">\(1\)</span>，其他的点对最近公共祖先深度为<span class="math inline">\(0\)</span>，所以答案为<span class="math inline">\(22\)</span>。</p>
<p>对于<span class="math inline">\(20%\)</span>的数据，<span class="math inline">\(n \le 10\)</span>。<br />
对于<span class="math inline">\(50%\)</span>的数据，<span class="math inline">\(n \le 10^6\)</span> 。<br />
对于<span class="math inline">\(100%\)</span>的数据，<span class="math inline">\(1 \le n \le 10^9\)</span> 。</p>
<hr />
<h3 id="题解">题解</h3>
<p>对于一颗有<span class="math inline">\(n\)</span>层的满二叉树很显然符合以下几点<br />
1.第<span class="math inline">\(i\)</span>层的点的个数为<span class="math inline">\(2^i\)</span>。<br />
2.以第<span class="math inline">\(i\)</span>层的点为根节点的子树大小为<span class="math inline">\(2^{n-i+1}-1\)</span>。<br />
3.以第<span class="math inline">\(i\)</span>层的点为<span class="math inline">\(\text{LCA}\)</span>的点对个数为<span class="math inline">\(2^{2n-i+1}-2^i\)</span><br />
<img src="./images/【CSP-S膜你考】最近公共祖先 （数学）1.png" /><br />
观察上面的图（好丑）,很明显<span class="math inline">\(1,2\)</span>都是对的。<br />
对于一颗以第<span class="math inline">\(i\)</span>层的节点为根的子树：<br />
①它的左子树与右子树上的点的<span class="math inline">\(\text{LCA}\)</span>都为根节点。所以点对个数为<br />
<span class="math display">\[\LARGE\frac{2^{n-i+1}-2}{2} \times \frac{2^{n-i+1}-2}{2}\]</span><br />
<span class="math display">\[\LARGE= (2^{n-i}-1) \times (2^{n-i}-1)\]</span><br />
<span class="math display">\[\LARGE= 2^{2n-2i}-2^{n-i+1}+1\]</span><br />
②这棵子树的左子树与根节点的<span class="math inline">\(\text{LCA}\)</span>都为根节点。右子树也是。所以有<span class="math inline">\(2^{n-i+1}-2\)</span>对点。<br />
③根节点与根节点的<span class="math inline">\(\text{LCA}\)</span>也是根节点，点对个数为1。<br />
点对<span class="math inline">\(\texttt{(u,v)}\)</span>与点对<span class="math inline">\(\texttt{(v,u)}\)</span>在<span class="math inline">\(u \neq v\)</span>时是两个不同的点对。<br />
所以将上述①②相加乘二再加③就是以子树根节点为<span class="math inline">\(\text{LCA}\)</span>的点对的数量为：<br />
<span class="math display">\[\LARGE 2^{2n-2i+1}-1\]</span><br />
因为第<span class="math inline">\(i\)</span>层的点的个数为<span class="math inline">\(2^i\)</span>。所以以第<span class="math inline">\(i\)</span>层的点为<span class="math inline">\(\text{LCA}\)</span>的点对个数为：<br />
<span class="math display">\[\LARGE 2^{2n-i+1}-2^i\]</span><br />
因为一共有<span class="math inline">\(n+1\)</span>层，从<span class="math inline">\(0-n\)</span>层，所以答案为：<br />
<span class="math display">\[\LARGE \sum_{i=0}^{n} (2^{2n-i+1}-2^i) \times i\]</span><br />
<span class="math display">\[\LARGE =\sum_{i=0}^{n} i \times 2^{2n-i+1}-i \times 2^i\]</span><br />
但这样复杂度为<span class="math inline">\(\Theta (nlog_n)\)</span>过不了。。将上面的式子展开：<br />
<span class="math display">\[\LARGE \sum_{i=0}^{n} i \times 2^{2n-i+1} - \sum_{i=0}^{n} i \times 2^i\]</span><br />
<span class="math display">\[\LARGE T_n=\sum_{i=0}^{n} i \times 2^{2n-i+1}\]</span><br />
<span class="math display">\[\LARGE =2^{2n} + 2 \times 2^{2n-1} + 3 \times 2^{2n-2}+...+n \times 2^{n+1}\]</span><br />
<span class="math display">\[\LARGE 2T_n=2^{2n+1} + 2 \times 2^{2n} + 3 \times 2^{2n-1}+...+n \times 2^{n+2}\]</span><br />
<span class="math display">\[\Large 2T_n-T_n=2^{2n+1} + 2^{2n} + 2^{2n-1}+...+2^{n+2} - n \times 2^{n+1}\]</span><br />
<span class="math display">\[\LARGE T_n=2^{2n+1} + 2^{2n} + 2^{2n-1}+...+2^{n+2} - n \times 2^{n+1}\]</span><br />
很明显前<span class="math inline">\(n\)</span>项为等比数列，利用等比数列求和公式可以很快求出。<br />
<span class="math display">\[\LARGE T_n=\sum_{i=0}^{n} i \times 2^i\]</span><br />
<span class="math display">\[\LARGE =2 + 2 \times 2^2 + 3 \times 2^3 +...+ n \times 2^n\]</span><br />
<span class="math display">\[\LARGE 2T_n=2^2 + 2 \times 2^3 + 3 \times 2^4 + ... + n \times 2^{n+1}\]</span><br />
<span class="math display">\[\LARGE T_n-2T_n=2 + 2^2 + 2^3 +...+2^n- n \times 2^{n+1}\]</span><br />
很明显也是等比数列。将这两个相加就是答案了。<br />
快速幂是<span class="math inline">\(log\)</span>。所以复杂度是<span class="math inline">\(\Theta(log_n)\)</span></p>
<hr />
<h3 id="code"><span class="math inline">\(Code\)</span></h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
typedef long long ll;
ll n;
const ll mod=1000000007;

inline void read(ll &amp;T) {
    ll x=0;bool f=0;char c=getchar();
    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;){if(c==&#39;-&#39;)f=!f;c=getchar();}
    while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;;c=getchar();}
    T=f?-x:x;
}

inline ll qpow(ll a,ll b) {
    ll ans=1,base=a;
    while(b) {
        if(b&amp;1) ans=(ans*base)%mod;
        base=(base*base)%mod;
        b&gt;&gt;=1;
    }
    return ans%mod;
}

int main() {
    read(n);
    ll qwq=(((2*qpow(2,2*n+1))%mod-qpow(2,n+2)+5*mod)%mod-n*qpow(2,n+1)+5*mod)%mod;
    ll qaq=((((2*qpow(2,n))%mod)-2+5*mod)%mod-n*qpow(2,n+1)+5*mod)%mod;
    //std::cout&lt;&lt;qwq&lt;&lt;&#39;\n&#39;&lt;&lt;qaq&lt;&lt;&#39;\n&#39;;
    std::cout&lt;&lt;(qwq+qaq+5*mod)%mod;//加上一个模数再取模是为了处理负数的情况
    return 0;
}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>