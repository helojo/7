<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修题解 Luogu P3959 【宝藏】' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>题解 Luogu P3959 【宝藏】</center></div><div class='banquan'>原文出处:本文由博客园博主一叶知秋`提供。<br/>
原文连接:https://www.cnblogs.com/wyzwyz/p/11542904.html</div><br>
    <p data-line="0">来一篇不那么慢的状压？？？</p>
<p data-line="2"><s>话说这题根本没有紫题难度吧，数据还那么水</s></p>
<p data-line="2"><span style="text-decoration: line-through;">我是不会告诉你我被hack了</span></p>
<hr />
<p data-line="6">一看数据规模，<span class="katex"><span class="katex-mathml">n&le;12<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit"><span class="mord rule"><span class="mrel"><span class="mord rule"><span class="mord"><span class="mord">，果断状压。</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="8">然后起点要枚举，就设<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">d<span class="mord mathit">p状态：</span></span></span></span></span></span></span></span></p>
<div class="cnblogs_Highlighter">
<pre>f[i][j]=以i为起点到j状态的最小花费</pre>
</div>
<p data-line="16">其中<span class="katex"><span class="katex-mathml">j<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">是一个二进制数（用十进制来表示）第<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">i位的<span class="katex"><span class="katex-mathml">1<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord">、<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord">0分别表示是否已经到达第<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">i点（<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord">1表示已经到达，<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord">0表示还未到达）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="18">（因为<span class="katex"><span class="katex-mathml">m<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">很大，<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">n很小，会有重边，所以用邻接矩阵（<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">e<span class="mopen">[<span class="mord mathit">u<span class="mclose">]<span class="mopen">[<span class="mord mathit">v<span class="mclose">]））</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="20">由此可以列出状态转移方程：</p>
<div class="cnblogs_Highlighter">
<pre>f[i][j]=min{f[i][k]+diss[i][k][u]*e[u][v]}

(j&amp;(1&lt;&lt;(u-1))!=0,j&amp;(1&lt;&lt;(v-1))!=0,i!=v,k=j^(1&lt;&lt;(v-1)),e[u][v]!=1e9)</pre>
</div>
<p data-line="30">（<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">e<span class="mopen">[<span class="mord mathit">u<span class="mclose">]<span class="mopen">[<span class="mord mathit">v<span class="mclose">]<span class="mclose">!<span class="mord rule"><span class="mrel">=<span class="mord rule"><span class="mord">1<span class="mord mathit">e<span class="mord">9说的就是<span class="katex"><span class="katex-mathml">u<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">、<span class="katex"><span class="katex-mathml">v<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">之间有边）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="32">什么意思？就是说我们再找一个状态（<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">k）比当前状态（<span class="katex"><span class="katex-mathml">j<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">）只少一个点（显然不能是起点），然后从<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">k向<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">j拓展，在所有的<span class="katex"><span class="katex-mathml">k<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">中取花费最少的那种。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="34">但是还有一个问题，该边的花费怎么算？</p>
<p data-line="36">根据题目描述，就将该边长度乘上起点到<span class="katex"><span class="katex-mathml">u<span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">u经过的点数（<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">d<span class="mord mathit">i<span class="mord mathit">s<span class="mopen">[<span class="mord mathit">i<span class="mclose">]<span class="mopen">[<span class="mord mathit">j<span class="mclose">]<span class="mopen">[<span class="mord mathit">u<span class="mclose">]）即可。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="38">问题又来了，<span class="katex"><span class="katex-mathml"><span class="katex-html"><span class="strut"><span class="strut bottom"><span class="base"><span class="mord mathit">d<span class="mord mathit">i<span class="mord mathit">s<span class="mopen">[<span class="mord mathit">i<span class="mclose">]<span class="mopen">[<span class="mord mathit">j<span class="mclose">]<span class="mopen">[<span class="mord mathit">u<span class="mclose">]怎么算？</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p data-line="40">每次状态转移的时候顺便转移一下即可</p>
<p data-line="42">代码如下：</p>
<div class="cnblogs_Highlighter">
<pre>#include&lt;cstdio&gt;

inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c&lt;'0'||c&gt;'9'){if(c=='-')f=-1;c=getchar();}
	while(c&gt;='0'&amp;&amp;c&lt;='9')r=(r&lt;&lt;1)+(r&lt;&lt;3)+c-'0',c=getchar();
	return r*f;
}

int n,ans=1e9,m,f[15][5005],e[15][15],dis[15][5005][15];

inline int min(int a,int b){
	return a&lt;b?a:b;
}

int main(){
	freopen("treasure.in","r",stdin);
	freopen("treasure.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			e[i][j]=1e9;
	for(int i=1;i&lt;=m;i++){
		int u=read(),v=read();
		if(u-v)e[u][v]=e[v][u]=min(e[u][v],read());
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;1&lt;&lt;n;j++)
			f[i][j]=1e9;
	for(int i=1;i&lt;=n;i++){
		f[i][1&lt;&lt;(i-1)]=0;
		dis[i][1&lt;&lt;(i-1)][i]=1;
		for(int j=(1&lt;&lt;(i-1))+1;j&lt;1&lt;&lt;n;j++){
			if(!(j&amp;(1&lt;&lt;(i-1))))continue;
			int x=j,u=1;
			while(x){
				if(x&amp;1){
					for(int v=1;v&lt;=n;v++){
						if(i==v||e[u][v]==1e9||!(j&amp;(1&lt;&lt;(v-1))))continue;
						int k=j^(1&lt;&lt;(v-1));
						if(f[i][j]&gt;f[i][k]+dis[i][k][u]*e[u][v]){
							f[i][j]=f[i][k]+dis[i][k][u]*e[u][v];
							for(int y=1;y&lt;=n;y++)dis[i][j][y]=dis[i][k][y];
							dis[i][j][v]=dis[i][k][u]+1;
						}
					}
				}
				u++;
				x&gt;&gt;=1;
			}
		}
		ans=min(ans,f[i][(1&lt;&lt;n)-1]);
	}
	printf("%d",ans);
	return 0;
}
</pre>
</div>
<p>　　</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>