<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++ 基础语法 快速复习笔记---面对对象编程（2）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++ 基础语法 快速复习笔记---面对对象编程（2）</center></div><div class='banquan'>原文出处:本文由博客园博主Parachute黑喵提供。<br/>
原文连接:https://www.cnblogs.com/cptCarlvon/p/11951076.html</div><br>
    <h3>1.C++面对对象编程:</h3>
<p>&nbsp;</p>
<h3>a.定义：</h3>
<p><span style="font-family: 黑体; font-size: 15px;">类定义是以关键字&nbsp;class&nbsp;开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">关键字&nbsp;public&nbsp;确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为&nbsp;private&nbsp;或&nbsp;protected，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样：</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-family: 黑体; font-size: 15px;">Box Box1;</span></strong></p>
<p><strong><span style="font-family: 黑体; font-size: 15px;">Box Box2; //定义了两个box类的对象</span></strong></p>
<p>&nbsp;</p>
<h3>b.类成员函数：</h3>
<p><a href="https://www.runoob.com/cplusplus/cpp-class-member-functions.html">https://www.runoob.com/cplusplus/cpp-class-member-functions.html</a></p>
<p>注意C++的namespace概念</p>
<p>&nbsp;</p>
<h3><strong>c.类访问修饰符：</strong></h3>
<p><span style="font-family: 黑体; font-size: 15px;">数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记&nbsp;<span class="marked">public、private、protected&nbsp;来指定的。</span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="marked">成员和类的默认访问修饰符是 private。</span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">(1).&nbsp;公有（public）成员：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 :&nbsp;</span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><strong><span class="hl-identifier">line<span class="hl-code">.<span class="hl-identifier">length<span class="hl-code"> = <span class="hl-number">10<span class="hl-number">.0<span class="hl-code">;&nbsp;</span></span></span></span></span></span></span></strong><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-number"><span class="hl-number"><span class="hl-code"> //line是对象，length是public的成员变量，直接赋值不用成员函数。</span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">(2).&nbsp;私有（private）成员：</span></p>
<p><strong>私有</strong>成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p>
<p>默认情况下，类的所有成员都是私有的。私有成员只能通过成员函数访问：</p>
<p><strong><span class="hl-identifier">box<span class="hl-code">.<span class="hl-identifier">setWidth<span class="hl-brackets">(<span class="hl-number">10<span class="hl-number">.0<span class="hl-brackets">)<span class="hl-code">; </span></span></span></span></span></span></span></span></strong></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">(3).&nbsp;保护（protected）成员:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><strong>保护</strong>成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">(4) 继承中的特点：</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private。&nbsp; &nbsp;（protected 成员可以被派生类访问。）</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private。&nbsp; （private&nbsp;成员只能被本类成员（类内）和友元访问，不能被派生类访问）</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><span style="font-family: 黑体;"><strong>&nbsp;d.继承：</strong></span></h3>
<p><span style="font-family: 黑体; font-size: 15px;">面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">例子：</span></p>
<p><strong><span style="font-family: 黑体; font-size: 15px;"><span class="hl-types">class<span class="hl-code"> <span class="hl-identifier">Rectangle<span class="hl-code">: <span class="hl-reserved">public<span class="hl-code"> <span class="hl-identifier">Shape&nbsp; &nbsp; </span></span></span></span></span></span></span></span></strong><span style="font-family: 黑体; font-size: 15px;"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-reserved"><span class="hl-code"><span class="hl-identifier">// Shape是基类（父）。Rectangle是派生类（子类）</span></span></span></span></span></span></span></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-reserved"><span class="hl-code"><span class="hl-identifier">关于成员函数的继承见上一项。</span></span></span></span></span></span></span></span></p>
<p><span style="font-family: 黑体;"><span style="font-size: 15px;">显而易见，子类定义的成员函数和成员变量不能被父类使用，但是父类和成员函数和成员变量都根据情况可以被子类使用。</span></span></p>
<p><span style="font-family: 黑体;"><span style="font-size: 15px;">注：可以多重继承（一个子类可以有好几个父类，嘿嘿）</span></span></p>
<p>&nbsp;</p>
<h3><span style="font-family: 黑体;">e.类构造函数：</span></h3>
<p>&nbsp;</p>
<p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。</p>
<p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值.</p>
<p>&nbsp;</p>
<p><strong><span class="hl-identifier">Line<span class="hl-code">::<span class="hl-identifier">Line<span class="hl-brackets">(<span class="hl-code">&nbsp;<span class="hl-types">double<span class="hl-code">&nbsp;<span class="hl-identifier">len<span class="hl-brackets">)</span></span></span></span></span></span></span></span></span></strong></p>
<p><strong>{</strong></p>
<p><strong><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier">cout<span class="hl-code">&nbsp;&lt;&lt;&nbsp;<span class="hl-quotes">"<span class="hl-string">Object is being created, length =&nbsp;<span class="hl-quotes">"<span class="hl-code">&nbsp;&lt;&lt;&nbsp;<span class="hl-identifier">len<span class="hl-code">&nbsp;&lt;&lt;&nbsp;<span class="hl-identifier">endl<span class="hl-code">;&nbsp; &nbsp; &nbsp; &nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-quotes"><span class="hl-string"><span class="hl-quotes"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code">//一般就是设定个初始值，比如 a = len;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-quotes"><span class="hl-string"><span class="hl-quotes"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier">length<span class="hl-code">&nbsp;=&nbsp;<span class="hl-identifier">len<span class="hl-code">;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
<p><strong><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-types"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-quotes"><span class="hl-string"><span class="hl-quotes"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-brackets">}&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000; font-size: 15px; font-family: 黑体;">Sub:C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。所以说最好按照顺序声明。</span></p>
<p>&nbsp;</p>
<h3><span>f. 析构函数:</span></h3>
<p><span style="font-family: 黑体; font-size: 15px;">类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体;"><strong><span style="font-size: 15px;"><span class="hl-identifier">Line<span class="hl-code">::~<span class="hl-identifier">Line<span class="hl-brackets">(<span class="hl-types">void<span class="hl-brackets">)</span></span></span></span></span></span></span></strong></span></p>
<p><span style="font-family: 黑体;"><strong><span style="font-size: 15px;"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-types"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets">{</span></span></span></span></span></span></span></span></span></strong></span></p>
<p><span style="font-family: 黑体;"><strong><span style="font-size: 15px;"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-types"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier">cout<span class="hl-code"> &lt;&lt; <span class="hl-quotes">"<span class="hl-string">Object is being deleted<span class="hl-quotes">"<span class="hl-code"> &lt;&lt; <span class="hl-identifier">endl<span class="hl-code">;&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong><span style="font-size: 15px;"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-types"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-quotes"><span class="hl-string"><span class="hl-quotes"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"> //一般不是这种，一般都是释放内存或者关闭文件之类的指令（delete 或者 close）</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-family: 黑体;"><strong><span style="font-size: 15px;"><span class="hl-identifier"><span class="hl-code"><span class="hl-identifier"><span class="hl-brackets"><span class="hl-types"><span class="hl-brackets"><span class="hl-code"><span class="hl-brackets"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-quotes"><span class="hl-string"><span class="hl-quotes"><span class="hl-code"><span class="hl-identifier"><span class="hl-code"><span class="hl-brackets">}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></strong></span></p>
<p><strong><span style="font-family: 黑体;"><span class="hl-identifier">&nbsp;</span></span></strong></p>
<p>&nbsp;</p>
<h3>g.拷贝构造函数:</h3>
<p><span style="font-family: 黑体; font-size: 15px;">拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;"><a href="https://www.runoob.com/cplusplus/cpp-copy-constructor.html">https://www.runoob.com/cplusplus/cpp-copy-constructor.html</a></span></p>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>h.友元函数：</h3>
<p><span style="font-family: 黑体; font-size: 15px;">类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字&nbsp;friend。</span></p>
<p>&nbsp;</p>
<h3><strong>i.</strong><span class="color_h1">静态成员:</span></h3>
<p><span style="font-family: 黑体; font-size: 15px;">我们可以使用&nbsp;static&nbsp;关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符&nbsp;::&nbsp;来重新声明静态变量从而对它进行初始化.</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">静态成员函数:</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符&nbsp;<strong>::</strong>&nbsp;就可以访问。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</span></p>
<p><span style="font-family: 黑体; font-size: 15px;">静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 黑体; font-size: 15px;">引用：<a href="https://www.runoob.com/cplusplus/cpp-classes-objects.html">https://www.runoob.com/cplusplus/cpp-classes-objects.html</a></span></p>
<p><span style="font-family: 黑体; font-size: 15px;"><a href="http://c.biancheng.net/view/2201.html">http://c.biancheng.net/view/2201.html</a></span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>