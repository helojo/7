<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修关于拼写小助手的开发日记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>关于拼写小助手的开发日记</center></div><div class='banquan'>原文出处:本文由博客园博主大白白熊白白提供。<br/>
原文连接:https://www.cnblogs.com/wtptorres/p/11084174.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#我的spellcorrect-开发文档"><strong><u>我的Spellcorrect 开发文档</strong></a><ul>
        <li><a href="#相关配置文件及准备工作"><strong>相关配置文件及准备工作：</strong></a></li>
        <li><a href="#演示效果中文"><strong>演示效果（中文）：</strong></a></li>
        <li><a href="#演示效果英语"><strong>演示效果（英语）：</strong></a></li>
        <li><a href="#代码部分"><strong>代码部分：</strong></a></li>
        <li><a href="#相关配置文件及准备工作-1"><strong>相关配置文件及准备工作：</strong></a></li>
        <li><a href="#演示效果中文-1"><strong>演示效果（中文）：</strong></a></li>
        <li><a href="#演示效果英语-1"><strong>演示效果（英语）：</strong></a></li>
        <li><a href="#代码部分-1"><strong>代码部分：</strong></a></li>
        </ul></li>
        </ul>
    </div>
</div>
<p>---恢复内容开始---</p>
<h1 id="我的spellcorrect-开发文档"><strong><u>我的Spellcorrect 开发文档</strong></h1>
<hr />
<p><strong></u></strong></p>
<hr />
<h3 id="相关配置文件及准备工作"><strong>相关配置文件及准备工作：</strong></h3>
<p><strong>我的主要文件夹分为三个：<u>分别为客户端，cppjieba分词库，离线部分及服务器部分</u></strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560856582308.png" alt="1560856582308" /></p>
<h6 id="客户端部分内部为客户端源码及运行程序">客户端部分：<u>内部为客户端源码及运行程序</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560856552431.png" alt="1560856552431" /></p>
<h6 id="cppjieba分词库部分就不赘述请自行安装">cppjieba分词库部分，就不赘述，请自行安装</h6>
<h6 id="离线部分内部有中英文件夹放置索引及词典文件还有配置文件及分词库其余为代码">离线部分：<u>内部有中英文件夹放置索引及词典文件，还有配置文件及分词库，其余为代码</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857073864.png" alt="1560857073864" /></p>
<h6 id="服务器部分最为重要的配置文件及数据部分头文件在include实现文件在src里面">服务器部分：<u>最为重要的配置文件及数据部分，头文件在include，实现文件在src里面</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857034230.png" alt="1560857034230" /></p>
<hr />
<h3 id="演示效果中文"><strong>演示效果（中文）：</strong></h3>
<p>==启动时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857677039.png" alt="1560857677039" /></p>
<p>==客户端连入时时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857739202.png" alt="1560857739202" /></p>
<p>==输入“赵”==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858117388.png" alt="1560858117388" /></p>
<p>==输入“周杰伦”==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858201376.png" alt="1560858201376" /></p>
<p>==输入清华大学==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858560147.png" alt="1560858560147" /></p>
<hr />
<h3 id="演示效果英语"><strong>演示效果（英语）：</strong></h3>
<p>==启动时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857677039.png" alt="1560857677039" /></p>
<p>==客户端连入时时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857739202.png" alt="1560857739202" /></p>
<p>==输入student：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858008297.png" alt="1560858008297" /></p>
<p>==输入spell：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858872540.png" alt="1560858872540" /></p>
<p>==输入computer：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560859162357.png" alt="1560859162357" /></p>
<hr />
<h3 id="代码部分"><strong>代码部分：</strong></h3>
<h6 id="离线部分">离线部分：</h6>
<p><img src="file:///C:\Users\dell\AppData\Local\Temp\ksohtml13180\wps1.jpg" alt="img" /></p>
<p>==Makefile:==</p>
<pre><code>SRCS:=$(wildcard *.cc)
OBJS:= $(patsubst %.cc, %.o, $(SRCS))

CXX:=g++

CXXFLAGS:= -w -g -std=c++11 $(addprefix -I, $(INC_DIR)) $(LIBS) -Wno-deprecated -I ../cppjieba/include/ -I ../cppjieba/deps

EXE:=./main

$(EXE):$(OBJS)
        $(CXX) -o $(EXE) $(OBJS) $(CXXFLAGS)

clean:
        rm -rf $(EXE)
            rm -rf $(OBJS)

</code></pre>
<p>==Configuration:==</p>
<pre><code>///=======================================
/// File:    Configuration.h
/// Author:  wtptorres(1584292712@qq.com)
/// Date:    2019-06-12 00:30:39
/// Dream:   Don&#39;t forget your dreams!
/// ======================================

#ifndef __CONFIGURATION_H__
#define __CONFIGURATION_H__
#include &quot;Nocopyable.h&quot;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;

class Configuration
:public Noncopyable
{
public:
    Configuration(const string &amp;filePath);
    string getEnglishDir() const {return _englishDir;}
    string getChineseDir() const {return _chineseDir;}
private:
    string _filePath;
    string _englishDir;
    string _chineseDir;
};
template&lt;typename T&gt;
class Singleton
{
public:
    template&lt;typename ...Args&gt;
    static T* getInstance(Args ...args)
    {
        if(!_pInstance)
            _pInstance = new T(args...);
        return _pInstance;
    }
    static void destroy()
    {
        if(_pInstance)
            delete _pInstance;
    }
private:
    Singleton();
    ~Singleton();
    static T *_pInstance;                    
};
template&lt;typename T&gt;
T * Singleton&lt;T&gt;::_pInstance = NULL;
#endif
</code></pre>
<pre><code>  1  ///=======================================
  2  /// File:    Configuration.cc
  3  /// Author:  wtptorres(1584292712@qq.com)
  4  /// Date:    2019-06-12 00:30:04
  5  /// Dream:   Don&#39;t forget your dreams!
  6  /// ======================================
  7 
  8                                     
  9 #include &quot;Configuration.h&quot;
 10 #include &lt;utility&gt;
 11 #include &lt;fstream&gt;
 12 #include &lt;iostream&gt;
 13 using namespace std;
 14 
 15 Configuration::Configuration(const string &amp;filePath)
 16 :_filePath(std::move(filePath))
 17 {
 18     ifstream ifs(_filePath);
 19     if(!ifs)
 20         cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
 21     ifs&gt;&gt;_englishDir;
 22     ifs&gt;&gt;_chineseDir;
 23     ifs.close();
 24 }
</code></pre>
<pre><code> ///=======================================
 /// File:    Nocopyable.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 00:24:36
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __NOCOPYABLE_H__
#define __NOCOPYABLE_H__
class Noncopyable
{
public:
    Noncopyable()=default;
    ~Noncopyable()=default;
private:
    Noncopyable(const Noncopyable &amp;rhs);
    Noncopyable &amp;operator =(const Noncopyable &amp;rhs);
};
#endif
</code></pre>
<p>==DictProducer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    DictProducer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 16:40:25
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __DICTPRODUCER_H__
#define __DICTPRODUCER_H__
#include &quot;SplitTool.h&quot;
using namespace std;
#include &quot;Nocopyable.h&quot;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;utility&gt;


class DictProducer
:public Noncopyable
{
public:
    DictProducer(const string,const string,const string &amp;,SplitToolJieba *);
    ~DictProducer(){}
    void build_dict();
    void build_cn_dict();
    void store_dict();
    vector&lt;pair&lt;string,int&gt;&gt;&amp; getIndict(){return _indict;}
private:
    void processEnglishWord(string &amp;word);
    void processChineseWord(string &amp;word);//除去中文的数字
    void construct_indict();
    string _englishDir;
    string _chineseDir;
    string _goleFilePath;
    vector&lt;string&gt; _englishFiles;
    vector&lt;string&gt; _chineseFiles;
    map&lt;string,int&gt; _dict;
    vector&lt;pair&lt;string,int&gt;&gt; _indict;
    shared_ptr&lt;SplitToolJieba&gt; _splitTool;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    DictProducer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 16:50:46
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;DictProducer.h&quot;
#include &lt;cctype&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#define FIRSTSIZE 10000
using namespace std;

DictProducer::DictProducer(const string englishDir,const string chineseDir,const string &amp;goleFilePath,SplitToolJieba *splitToolPtr)
    :_englishDir(englishDir)
    ,_chineseDir(chineseDir)
    ,_goleFilePath(goleFilePath)
{
    _splitTool.reset(splitToolPtr);
    std::ifstream ifsEnglish(_englishDir);
    std::ifstream ifsChinese(_chineseDir);
    string filePath;
    if(!ifsEnglish || !ifsChinese){
        cout&lt;&lt;&quot;Dict file open error!&quot;&lt;&lt;endl;
    }
    while(ifsEnglish&gt;&gt;filePath)
    {
        _englishFiles.push_back(filePath);
    }
    while(ifsChinese&gt;&gt;filePath)
    {
        _chineseFiles.push_back(filePath);
    }
    _indict.reserve(FIRSTSIZE);
}

void DictProducer::processEnglishWord(string &amp;word)
{
    auto cit =word.begin();
    for(;cit!=word.end();++cit)
    {   //去除标点符号或数字
        if(!isalpha(*cit)){
            word.erase(cit);
            --cit;//迭代器位置发生改变
        }else if(isupper(*cit)){//将大写字母改为小写
            *cit =tolower(*cit);
        }
    }
}

void DictProducer::processChineseWord(string &amp;word)
{
    auto cit =word.begin();
    for(;cit!=word.end();++cit)
    {   //去除数字
        if(!isalnum(*cit)){
            word.erase(cit);
            --cit;
        }
    }
}

void DictProducer::build_dict()//建立英文词典
{
    for(auto &amp;filePath:_englishFiles)
    {
        ifstream ifs(filePath);
        if(!ifs){
            cout&lt;&lt;&quot;English File open error!&quot;&lt;&lt;endl;
        }
        string word;
        while(ifs&gt;&gt;word)
        {
            processEnglishWord(word);
            auto cit =_dict.find(word);
            if(word.size()&gt;0 &amp;&amp; cit ==_dict.end()){
                _dict.insert(std::make_pair(word,1));
            }else if(cit!=_dict.end()){
                ++ cit -&gt;second;
            }
        }
    }
}


void DictProducer::build_cn_dict()
{
    vector&lt;string&gt;words;
    for(auto filePath:_chineseFiles)
    {
        ifstream ifs(filePath);
        if(!ifs){
            cout&lt;&lt;&quot;Chinese file open error!&quot;&lt;&lt;endl;
        }
        string sentence;
        while(std::getline(ifs,sentence))
        {
            _splitTool-&gt;Cut(sentence);
        }
    }
    vector&lt;string&gt;&amp; results =_splitTool-&gt;getResult();
    for(auto &amp;res:results)
    {
        processChineseWord(res);
        auto cit =_dict.find(res);
        if(cit ==_dict.end()){
            _dict.insert(std::make_pair(res,1));
        }else{
            ++ cit -&gt;second;
        }
    }
}

void DictProducer::store_dict()
{
    construct_indict();
    ofstream ofs(_goleFilePath);
    if(!ofs)
        cout&lt;&lt;&quot;Store_dict open file error!&quot;&lt;&lt;endl;
    for(auto &amp;mypair:_indict)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;&lt;&lt;mypair.second&lt;&lt;endl;
    }
    ofs.close();
}

void DictProducer::construct_indict()
{
    for(auto dictpair:_dict){
        _indict.push_back(dictpair);
    }
}
</code></pre>
<p>==GetIndex:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    GetIndex.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 08:52:04
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __GETINDEX_H__
#define __GETINDEX_H__
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;unordered_set&gt;
using namespace std;

class GetIndex
{
public:
    GetIndex(const string &amp;,const string &amp;,const string &amp;);
    ~GetIndex(){}
    void construct_index();
    void store_index();
private:
    bool isEnglish(const string &amp;rhs) const;
    vector&lt;string&gt;getOneCharacter(const string &amp; word);
    string _sourceFilePath;
    string _goleFilePath;
    string _stopWordsFilePath;
    vector&lt;pair&lt;string,int&gt;&gt;_dict;
    unordered_set&lt;string&gt;_stopWords;
    unordered_map&lt;string,set&lt;int&gt;&gt;_index;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    GetIndex.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 09:00:11
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;GetIndex.h&quot;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
using namespace std;

GetIndex::GetIndex(const string &amp; sourceFilePath,const string &amp;goleFilePath,const string &amp;stopWordsFilePath)
:_sourceFilePath(std::move(sourceFilePath))
,_goleFilePath(std::move(goleFilePath))
,_stopWordsFilePath(std::move(stopWordsFilePath))
{
    ifstream ifs(_sourceFilePath);
    if(!ifs){
        cout&lt;&lt;&quot;GetIndex file open error!&quot;&lt;&lt;endl;
    }
    string line;
    while(getline(ifs,line))
    {
        istringstream iss(line);
        string key;
        int value;
        iss&gt;&gt;key&gt;&gt;value;
        _dict.push_back(std::make_pair(key,value));
    }
    ifstream ifs1(_stopWordsFilePath);
    if(!ifs1){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
    }
    string stopWord;
    while(ifs1&gt;&gt;stopWord,!ifs1.eof())
    {
        _stopWords.insert(stopWord);
    }
}

vector&lt;string&gt; GetIndex::getOneCharacter(const string &amp;word)
{
    vector&lt;string&gt;tmp;
    auto cit =word.begin();
    while(cit&lt;word.end())
    {
        if(224==(*cit &amp;224))
        {
            string oneCharacter;
            oneCharacter.append(cit,cit+3);
            tmp.push_back(oneCharacter);
            cit +=3;
        }else if(240==(*cit &amp;240)){
            string oneCharacter;
            oneCharacter.append(cit,cit+4);
            tmp.push_back(oneCharacter);
            cit +=4;
        }else
            break;
    }
    return tmp;
}
             
bool GetIndex::isEnglish(const string &amp;rhs) const
{
    char ch =*(rhs.begin());
    if(ch&lt;0)
        return false;
    return true;
}
#if 0
bool GetIndex::isEnglish(const string &amp;rhs) const
{
    char ch =*(rhs.begin());
    if(ch&lt;0){
        return false;
    }
    return true;
}
#endif
void GetIndex::construct_index()
{
    for(size_t i=0;i!=_dict.size();++i)
    {
        string tmp=_dict[i].first;
        if(isEnglish(tmp))
        {
            for(auto ch:tmp)
            {
                string charactor(1,ch);
                if(isalpha(ch))
                {
                    auto cit =_index.find(charactor);
                    if(cit ==_index.end())
                    {
                        set&lt;int&gt; smp;
                        smp.insert(i);
                        _index.insert(std::make_pair(charactor,smp));
                    }else{//已经存在了该字母的索引
                        cit-&gt;second.insert(i);
                    }
                }
            }
        }else{//中文处理部分
            vector&lt;string&gt; oneCharacterRally =getOneCharacter(tmp);
            for(auto oneCharacter:oneCharacterRally)
            {//stop_words中不存在该单词，则加入索引中
                if(_stopWords.find(oneCharacter)==_stopWords.end()){
                    auto it =_index.find(oneCharacter);
                    if(it == _index.end()){
                        set&lt;int&gt;tmp;
                        tmp.insert(i);
                        _index.insert(std::make_pair(oneCharacter,tmp));
                    }else{
                        it-&gt;second.insert(i);
                    }
                }
            }
        }
    }
}

void GetIndex::store_index()
{   
    //ofs存储索引的内容
    std::ofstream ofs(_goleFilePath);
    if(!ofs){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
        return;
    }
    for(auto data:_index)
    {
        ofs&lt;&lt;data.first&lt;&lt;&quot; &quot;;
        for(auto linenum:data.second)
        {
            ofs&lt;&lt;linenum&lt;&lt;&quot; &quot;;
        }
        ofs&lt;&lt;endl;
    }
    ofs.close();
}
</code></pre>
<p>==SplitTool:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SplitTool.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 17:12:01
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#ifndef __SPLITTOOL_H__
#define __SPLITTOOL_H__
#include &quot;../cppjieba/include/cppjieba/Jieba.hpp&quot;//需要自己将cppjieba安装在项目目录下
#include &quot;Configuration.h&quot;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
using namespace cppjieba;
class SplitToolJieba
{
public:
    SplitToolJieba(const string&amp; dict_path,const string &amp;model_path,const string &amp;user_dict_path,const string &amp; idfPath, const string &amp;stopWordPath)
    :_jieba(dict_path,model_path,user_dict_path,idfPath,stopWordPath)
    {}
    ~SplitToolJieba(){}
    void Cut(const string &amp; sentence)
    {
        vector&lt;string&gt;tmp;
        _jieba.Cut(sentence,tmp);
        _result.insert(_result.end(),tmp.begin(),tmp.end());
    }
    vector&lt;string&gt; &amp; getResult(){return _result;}
private:
    vector&lt;string&gt; _result;
    cppjieba::Jieba _jieba;
};
#endif
</code></pre>
<p>==main:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    main.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 20:38:50
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;Configuration.h&quot;
#include &quot;SplitTool.h&quot;
using namespace std;
#include &quot;DictProducer.h&quot;
#include &quot;GetIndex.h&quot;
#include &lt;iostream&gt;
#include &lt;memory&gt;
const char * const DICT_PATH =&quot;../cppjieba/dict/jieba.dict.utf8&quot;;
const char * const HMM_PATH =&quot;../cppjieba/dict/hmm_model.utf8&quot;;
const char * const USER_DICT_PATH =&quot;../cppjieba/dict/user.dict.utf8&quot;;
const char * const IDF_PATH =&quot;../cppjieba/dict/idf.utf8&quot;;
const char * const STOP_WORD_PATH =&quot;../cppjieba/dict/stop_words.utf8&quot;;
const string GOLE_DICT_PATH=&quot;../server/data/dict.txt&quot;;
const string GOLE_INDEX_PATH=&quot;../server/data/index.txt&quot;;

class SplitTool;
int main(void)
{
    Configuration *pconfig =Singleton&lt;Configuration&gt;::getInstance(&quot;configure.txt&quot;);
    SplitToolJieba *ptool =new SplitToolJieba(DICT_PATH,HMM_PATH,USER_DICT_PATH,IDF_PATH,STOP_WORD_PATH);
    DictProducer mydictProducer(pconfig-&gt;getEnglishDir(),pconfig-&gt;getChineseDir(),GOLE_DICT_PATH,ptool);
    mydictProducer.build_dict();//建立英语词典
    mydictProducer.build_cn_dict();//建立中文词典
    mydictProducer.store_dict();//储存词典
    GetIndex myindex(GOLE_DICT_PATH,GOLE_INDEX_PATH,&quot;stop_words_zh.txt&quot;);
    myindex.construct_index();//建立索引
    myindex.store_index();//存储索引
    Singleton&lt;Configuration&gt;::destroy();
    return 0;
}
</code></pre>
<hr />
<h6 id="在线部分">在线部分：</h6>
<p><img src="file:///C:\Users\dell\AppData\Local\Temp\ksohtml13180\wps2.jpg" alt="img" /></p>
<p>==ConFiguration:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    ConFiguration.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 10:32:43
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __CONFIGURATION_H__
#define __CONFIGURATION_H__
#include &quot;Noncopyable.h&quot;
#include &lt;string&gt;
#include &lt;map&gt;
#define CONFPATH &quot;/home/wtp/spell/server/conf/configure.txt&quot;
using namespace std;

namespace wd
{
    class Configuration
    :public Noncopyable
    {
    public:
        Configuration(const string &amp;filePath);
        ~Configuration()=default;
        string getDictDir() const;
        string getIndexDir() const;
        string getIp()const;
        string getCache() const;
        unsigned short getPort() const;

    private:
        string _filePath;
        map&lt;string,string&gt; _conf;
    };
};

template&lt;typename T&gt;
class Singleton
{
public:
    template&lt;typename ...Args&gt;
    static T *getInstance(Args ...args)
    {
        if(!_pInstance)
            _pInstance=new T(args ...);
        return _pInstance;
    }

    static void destroy()
    {
        if(_pInstance)
            delete _pInstance;
    }
private:
    Singleton();
    ~Singleton();
    static T *_pInstance;
};

template&lt;typename T&gt;
T *Singleton&lt;T&gt;::_pInstance =NULL;
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    ConFiguration.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 15:24:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;ConFiguration.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

wd::Configuration::Configuration(const string &amp; filePath)
:_filePath(std::move(filePath))
{
    ifstream ifs(_filePath);
    if(!ifs){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
    }
    string key,value;
    while(ifs&gt;&gt;key)
    {
        ifs&gt;&gt;value;
        _conf.insert(std::make_pair(key,value));
    }
    ifs.close();
}

string wd::Configuration::getDictDir() const
{
    auto cit=_conf.find(&quot;mydict&quot;);
    if(cit== _conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}

string wd::Configuration::getIndexDir() const
{
    auto cit =_conf.find(&quot;myindex&quot;);
    if(cit== _conf.end())
        return &quot;&quot;;
    else 
        return cit-&gt;second;
}

string wd::Configuration::getIp() const
{
    auto cit =_conf.find(&quot;myip&quot;);
    if(cit ==_conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}

unsigned short wd::Configuration::getPort() const
{
    auto cit =_conf.find(&quot;myport&quot;);
    if(cit==_conf.end())
        return 0;
    else
        return atoi(cit-&gt;second.c_str());
}

string wd::Configuration::getCache() const
{
    auto cit =_conf.find(&quot;mycache&quot;);
    if(cit ==_conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}
             
 
</code></pre>
<p>==Acceptor:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Acceptor.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 23:47:05
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef  __WD_ACCEPTOR_H__
#define  __WD_ACCEPTOR_H__

#include &quot;Socket.h&quot;
#include &quot;InetAddress.h&quot;

namespace wd
{
    class Acceptor
    {
    public:
        Acceptor(int listenfd,const InetAddress &amp; addr);
        void ready();//服务器监听准备
        int accept();//服务器接收新连接
        int fd()const {return _listenSock.fd();}
    private:
        void setReuseAddr(bool on);//设置地址重用
        void setReusePort(bool on);//设置端口重用
        void bind();//绑定
        void listen();//监听
        Socket _listenSock;
        InetAddress _addr;
    };
}

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Acceptor.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 23:52:12
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &lt;iostream&gt;
#include &quot;Acceptor.h&quot;
#include &quot;SocketUtil.h&quot;

namespace wd
{
Acceptor::Acceptor(int listenfd,const InetAddress &amp; addr)
:_listenSock(listenfd)
,_addr(addr)
{}

void Acceptor::ready()
{
    setReuseAddr(true);
    setReusePort(true);
    bind();
    listen();
}
int Acceptor::accept()
{
    int peerfd=::accept(_listenSock.fd(),NULL,NULL);
    if(-1==peerfd)
    {
        perror(&quot;accept error!&quot;);
    }
    return peerfd;
}
void Acceptor::setReuseAddr(bool flag)
{
    int on=(flag?1:0);
    if(::setsockopt(_listenSock.fd()
                    ,SOL_SOCKET
                    ,SO_REUSEADDR
                    ,&amp;on
                    ,static_cast&lt;socklen_t&gt;(size_t(on)))==-1)
    {
        perror(&quot;setsockopt reuseaddr error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}

void Acceptor::setReusePort(bool flag)
{
#ifndef SO_REUSEPORT
    int on=(flag?1:0);
    if(::setsockopt(_listenSock.fd()
                    ,SOL_SOCKET
                    ,SO_REUSEADDR
                    ,&amp;on
                    ,static_cast&lt;socklen_t&gt;(size_t(on)))==-1)
    {
        perror(&quot;setsockopt reuseport error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
#else
    if(flag)
    {
        fprintf(stderr,&quot;SO_REUSEPORT is not supported!\n&quot;);
    }
#endif
}

void Acceptor::bind()
{
    if(-1==::bind(_listenSock.fd()
                  ,(const struct sockaddr*)_addr.getSockAddrPtr()
                  ,sizeof(InetAddress)))
    {
        perror(&quot;bind error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}
void Acceptor::listen()
{
    if(-1==::listen(_listenSock.fd(),10))
    {
        perror(&quot;listen error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}

}
#if 0
int main()
{
    std::cout&lt;&lt;&quot;Acceptor is correct!&quot;&lt;&lt;std::endl;
}
#endif
</code></pre>
<p>==Condition.h:==</p>
<pre class="cpp"><code>#ifndef __WD_CONDITION_H__
#define __WD_CONDITION_H__

#include &quot;Noncopyable.h&quot;
#include &quot;MutexLock.h&quot;
#include &lt;pthread.h&gt;

namespace wd
{
    class Condition
    :Noncopyable
    {
    public:
        Condition(MutexLock &amp;mutex)
        :_mutex(mutex)
        {pthread_cond_init(&amp;_cond,NULL);}
    
        ~Condition()
        {pthread_cond_destroy(&amp;_cond);}
    
        void wait()
        {pthread_cond_wait(&amp;_cond,_mutex.getMutexLockPtr());}
    
        void notify()
        {pthread_cond_signal(&amp;_cond);}
    
        void notifyAll()
        {pthread_cond_broadcast(&amp;_cond);}
    private:
        pthread_cond_t _cond;
        MutexLock &amp; _mutex;
    };
}
#endif
</code></pre>
<p>==Cache:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Cache.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 19:52:40
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __CACHE_H__
#define __CACHE_H__
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;
namespace wd
{
    class Cache
    {
    public:
        void addElement(string,string);//增加缓存信息
        void readFromFile(string);//从文件中读取信息
        void writeToFile(string);//将信息写入文件中
        void update(const Cache&amp;);//更新缓存消息
        bool find(string querry);//从数据库中找寻信息
        string &amp;operator[](string key);
    private:
        unordered_map&lt;string,string&gt;_hashTable;//采用hashTable进行缓存
    };
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Cache.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:01:25
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;Cache.h&quot;
#include &lt;fstream&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

void Cache::addElement(string querry,string result)
{
    _hashTable[querry]=result;
}

void Cache::readFromFile(string filePath)
{
    ifstream ifs(filePath);
    if(!ifs){
        cout&lt;&lt;&quot;Cache::read readFromFile file open error!&quot;&lt;&lt;endl;
        return;
    }
    string querry,result;
    while(ifs&gt;&gt;querry,!ifs.eof())
    {
        ifs&gt;&gt;result;
        _hashTable[querry]=result;
    }
}
#if 0
void Cache::writeToFile(string filePath)
{
    ofstream ofs(filePath);
    if(!ofs){
        cout&lt;&lt;&quot;&quot;&lt;&lt;endl;
        return;
    }
    for(auto &amp;mypair:_hashTable)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;;
        ofs&lt;&lt;mypair.second&lt;&lt;endl;
    }
}

void Cache::update(const Cache &amp; cache)
{   
    for(auto &amp;mypair:cache._hashTable)
    {
        auto cit =_hashTable.find(mypair.first);
        if(cit==_hashTable.end())
        {
            _hashTable.insert(std::move(mypair));
        }
    }
}
#endif

void Cache::writeToFile(string filePath)
{
    ofstream ofs(filePath);
    if(!ofs){
        cout&lt;&lt;&quot;file write error!&quot;&lt;&lt;endl;
        return;
    }
    for(auto &amp;mypair:_hashTable)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;;
        ofs&lt;&lt;mypair.second&lt;&lt;endl;
    }
}

void Cache::update(const Cache &amp; cache)
{
    for(auto &amp;mypair:cache._hashTable)
    {
        auto cit =_hashTable.find(mypair.first);
        if(cit==_hashTable.end())
        {
            _hashTable.insert(std::move(mypair));
        }
    }
}

bool Cache::find(string querry)
{
    auto cit =_hashTable.find(querry);
    if(cit==_hashTable.end())
        return false;
    return true;
}

string &amp;Cache::operator[](string key)
{
    return _hashTable[key];
}

#if 0
int main()
{
    cout&lt;&lt;&quot;cache is correct!&quot;&lt;&lt;endl;
}
#endif
</code></pre>
<p>==CacheManger:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    CacheManger.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:51:09
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __CACHEMANGER_H__
#define __CACHEMANGER_H__
#include &quot;Cache.h&quot;
#include &lt;vector&gt;
#define THREADNUM 4//线程数目设置为4个，可自定义

using std::vector;
namespace wd
{
    class CacheManger
    {
    public:
        CacheManger(string filePath);
        void init(string);//创建缓存
        Cache &amp; getCache(size_t);//获取某个缓存
        void periodicUpdate();//定时更新所有缓存
    private:
        string _cacheFilePath;
        vector&lt;Cache&gt;_cacheList;
    };
};

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    CacheManger.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:56:50
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;CacheManger.h&quot;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

CacheManger::CacheManger(string cacheFilePath)
{
    init(cacheFilePath);
}
             
void CacheManger::init(string cacheFilePath)
{
    _cacheFilePath=cacheFilePath;
    _cacheList.reserve(THREADNUM);
    Cache tmp;
    tmp.readFromFile(_cacheFilePath);
    for(size_t i=0;i!=THREADNUM;++i)
    {
        _cacheList.push_back(std::move(tmp));
    }
}

Cache &amp; CacheManger::getCache(size_t number)
{
    return _cacheList[number];
}

void CacheManger::periodicUpdate()
{
    auto cit=_cacheList.begin();
    Cache lastWrite=*(cit ++);
    for(;cit&lt;_cacheList.end();++cit)
    {
        lastWrite.update(*cit);
    }
    for(cit=_cacheList.begin()+1;cit!=_cacheList.end();++cit)
    {
        (*cit).update(lastWrite);
    }
    lastWrite.writeToFile(_cacheFilePath);
}
</code></pre>
<p>==EpollPoller:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    EpollPoller.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 11:03:36
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_EPOLLPOLLER_H__
#define __WD_EPOLLPOLLER_H__

#include &quot;TcpConnection.h&quot;
#include &quot;Noncopyable.h&quot;
#include &quot;MutexLock.h&quot;
#include &lt;sys/epoll.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;functional&gt;

namespace wd
{
    class Acceptor;
    class EpollPoller
    :Noncopyable
    {
    public:
        typedef TcpConnection::TcpConnectionCallback EpollCallback;
        typedef  std::function&lt;void()&gt; Functor;
        EpollPoller(Acceptor &amp;acceptor);
        ~EpollPoller();
    
        void loop();
        void unloop();
        void runInLoop(const Functor &amp;&amp; cb);
        void doPendingFunctors();
        void wakeup();
    
        void setConnectionCallback(EpollCallback cb);
        void setMessageCallback(EpollCallback cb);
        void setCloseCallback(EpollCallback cb);
    private:
        void waitEpollfd();
        void handleConnection();
        void handleMessage(int peerfd);
        void handleRead();
    
        Acceptor &amp; _acceptor;
        int _epollfd;
        int _eventfd;
        int _listenfd;
        bool _isLooping;
    
        MutexLock _mutex;
        std::vector&lt;Functor&gt; _pendingFunctors;
    
        typedef std::vector&lt;struct epoll_event&gt;Eventlist;
        Eventlist _eventList;
    
        typedef std::map&lt;int,TcpConnectionPtr&gt; ConnectionMap;
        ConnectionMap _connMap;
        EpollCallback _onConnectionCb;
        EpollCallback _onMessageCb;
        EpollCallback _onCloseCb;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    EpollPoller.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 15:42:54
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;EpollPoller.h&quot;
#include &quot;SocketUtil.h&quot;
#include &quot;Acceptor.h&quot;
#include &lt;assert.h&gt;
#include &lt;iostream&gt;
using namespace std;

namespace wd
{
    EpollPoller::EpollPoller(Acceptor &amp; acceptor)
    :_acceptor(acceptor)
    ,_epollfd(createEpollFd())
    ,_eventfd(createEventFd())
    ,_listenfd(_acceptor.fd())
    ,_isLooping(false)
    ,_eventList(1024)
    {
        addEpollFdRead(_epollfd,_listenfd);
        addEpollFdRead(_epollfd,_eventfd);

    }
    
    EpollPoller::~EpollPoller()
    {
        ::close(_epollfd);
    }
    
    void EpollPoller::loop()
    {
        _isLooping=true;
        while(_isLooping)
        {
            waitEpollfd();
        }
    }

    void EpollPoller::unloop()
    {
        if(_isLooping)
            _isLooping=false;
    }

    void EpollPoller::setConnectionCallback(EpollCallback cb)
    {
        _onConnectionCb=cb;
    }
    
    void EpollPoller::setMessageCallback(EpollCallback cb)
    {
        _onMessageCb=cb;
    }
    
    void EpollPoller::setCloseCallback(EpollCallback cb)
    {
        _onCloseCb=cb;
    }
    void EpollPoller::waitEpollfd()
    {
        int nready;
        do
        {
            nready =::epoll_wait(_epollfd,&amp;(*_eventList.begin()),_eventList.size(),10000);
                
        }while(-1==nready &amp;&amp; errno ==EINTR);

        if(-1==nready){
            perror(&quot;epoll wait error!&quot;);
            exit(EXIT_FAILURE);
        }else if(0==nready){
            cout&lt;&lt;&quot;epoll_wait timeout!&quot;&lt;&lt;endl;
        }else{//扩容
            if(nready==static_cast&lt;int&gt;(_eventList.size())){
                _eventList.resize(_eventList.size()*2);
            }

            for(int idx=0;idx!=nready;++idx)//正宗罗老师循环体(TwT)
            {
                if(_eventList[idx].data.fd ==_listenfd)
                {
                    if(_eventList[idx].events &amp; EPOLLIN)
                    {
                        handleConnection();
                    }
                }else if(_eventList[idx].data.fd ==_eventfd){
                    handleRead();
                    cout&lt;&lt;&quot;&gt;&gt;doPendingFunctors()&quot;&lt;&lt;endl;
                    doPendingFunctors();
                }else{
                    if(_eventList[idx].events &amp; EPOLLIN){
                        handleMessage(_eventList[idx].data.fd);
                    }
                }
            }
        }
    }

    void EpollPoller::handleConnection()
    {
        int peerfd=_acceptor.accept();
        addEpollFdRead(_epollfd,peerfd);
        TcpConnectionPtr conn(new TcpConnection(peerfd,this));
        conn-&gt;setConnectionCallback(_onConnectionCb);
        conn-&gt;setMessageCallback(_onMessageCb);
        conn-&gt;setCloseCallback(_onCloseCb);
        std::pair&lt;ConnectionMap::iterator,bool&gt;ret;
        ret=_connMap.insert(std::make_pair(peerfd,conn));
        assert(ret.second ==true);
        (void)ret;
        conn-&gt;handleConnectionCallback();
    }

    void EpollPoller::handleMessage(int peerfd)
    {
        bool isClosed=isConnectionClosed(peerfd);
        ConnectionMap::iterator it =_connMap.find(peerfd);
        assert(it!=_connMap.end());

        if(isClosed)
        {
            it-&gt;second-&gt;handleCloseCallback();
            delEpollReadFd(_epollfd,peerfd);
            _connMap.erase(it);
        }else{
            it-&gt;second-&gt;handleMessageCallback();
        }
    }
    
    void EpollPoller::runInLoop(const Functor &amp;&amp; cb)//在计算线程中执行
    {
        MutexLockGuard mlg(_mutex);
        _pendingFunctors.push_back(std::move(cb));
        wakeup();
    }

    void EpollPoller::doPendingFunctors()
    {
        std::vector&lt;Functor&gt;tmp;
        {
            MutexLockGuard mlg(_mutex);
            tmp.swap(_pendingFunctors);
        }
        for(auto &amp; functor:tmp)
        {
            functor();
        }
    }

    void EpollPoller::handleRead()
    {
        uint64_t howmany;
        int ret=::read(_eventfd,&amp;howmany,sizeof(howmany));
        if(ret !=sizeof(howmany))
        {
            perror(&quot;read error!&quot;);
        }
    }

    void EpollPoller::wakeup()
    {
        uint64_t one =1;
        int ret =::write(_eventfd,&amp;one,sizeof(one));
        if(ret!=sizeof(one))
        {
            perror(&quot;write error!&quot;);
        }
    }
}
 
</code></pre>
<p>==InetAddress:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    InetAddress.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 21:55:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#ifndef __WD_INETADDRESS_H__
#define __WD_INETADDRESS_H__
#include &lt;netinet/in.h&gt;
#include &lt;string&gt;
namespace wd
{
    class InetAddress
    {
    public:
        InetAddress(short port);
        InetAddress(const char *pIp,short port);
        InetAddress(const struct sockaddr_in &amp; addr);
        std::string ip()const;
        unsigned short port() const;
        const struct sockaddr_in *getSockAddrPtr() const;
    private:
        struct sockaddr_in _addr;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    InetAddress.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:55:18
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;InetAddress.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

namespace wd
{
InetAddress::InetAddress(short port)
{
    ::memset(&amp;_addr,0,sizeof(_addr));
    _addr.sin_family=AF_INET;
    _addr.sin_port=htons(port);
    _addr.sin_addr.s_addr=INADDR_ANY;
}

InetAddress::InetAddress(const char * pIp,short port)
{
    ::memset(&amp;_addr,0,sizeof(_addr));
    _addr.sin_family=AF_INET;
    _addr.sin_port=htons(port);
    _addr.sin_addr.s_addr=inet_addr(pIp);
}

InetAddress::InetAddress(const struct sockaddr_in &amp; addr)
:_addr(addr)
{}

const struct sockaddr_in * InetAddress::getSockAddrPtr()const
{
    return &amp; _addr;
}

std::string InetAddress::ip()const
{
    return std::string(inet_ntoa(_addr.sin_addr));
}

unsigned short InetAddress::port() const
{
    return ntohs(_addr.sin_port);
}

}
</code></pre>
<p>==MutexLock:==</p>
<pre class="cpp"><code>#ifndef  __WD_MUTEXLOCK_H__
#define  __WD_MUTEXLOCK_H__

#include &quot;Noncopyable.h&quot;
#include &lt;pthread.h&gt;

namespace wd
{
    class MutexLock
    :Noncopyable
    {
    public:
        MutexLock()
        {pthread_mutex_init(&amp;_mutex,NULL);}
        ~MutexLock()
        {pthread_mutex_destroy(&amp;_mutex);}
        void lock()
        {pthread_mutex_lock(&amp;_mutex);}
        void unlock()
        {pthread_mutex_unlock(&amp;_mutex);}
        pthread_mutex_t *getMutexLockPtr()
        {return &amp;_mutex;}
    private:
        pthread_mutex_t _mutex;
};

class MutexLockGuard//C++之父BS提出的RAII
{
public:
    MutexLockGuard(MutexLock &amp;mutex)
    :_mutex(mutex)
    {
        _mutex.lock();
    }
    ~MutexLockGuard()
    {
        _mutex.unlock();
    }
private:
    MutexLock &amp;_mutex;
};
}
#endif
</code></pre>
<p>==Mydict:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Mydict.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 11:12:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __MYDICT_H__
#define __MYDICT_H__
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;set&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;
namespace wd
{
    struct MyResult
    {
        string _word;
        int _iFreq;//词频
        int _iDist;//最小编辑距离
    };
    
    class Mydict
    {
    public:
        Mydict(const string dictDir,const string indexDir)
        {
            ifstream ifs1(dictDir),ifs2(indexDir);
            if(!ifs1||!ifs2)
                cout&lt;&lt;&quot;Mydict open file error!&quot;&lt;&lt;endl;
            string key;
            int value;
            ifs1&gt;&gt;value;
            _dict.push_back(std::make_pair(string(&quot; &quot;),value));
            ifs1&gt;&gt;value;
            _dict.push_back(std::make_pair(string(&quot; &quot;),value));
            while(ifs1&gt;&gt;key)
            {
                ifs1&gt;&gt;value;
                _dict.push_back(std::make_pair(key,value));
            }
            string line;
            while(std::getline(ifs2,line))
            {
                istringstream iss(line);
                string ikey;
                int ivalue;
                iss&gt;&gt;ikey;
                set&lt;int&gt; tmp;
                while(iss&gt;&gt;ivalue)
                {
                    tmp.insert(ivalue);
                }
                _index.insert(std::make_pair(ikey,tmp));
            }
        }

        vector&lt;pair&lt;string,int&gt;&gt; &amp; getDict(){return _dict;}

        map&lt;string ,set&lt;int&gt;&gt; &amp; getIndexTable(){return _index;}

    private:
        vector&lt;pair&lt;string,int&gt;&gt; _dict;
        map&lt;string,set&lt;int&gt;&gt; _index;
    };
}
#endif
</code></pre>
<p>==MyTask:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    MyTask.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 21:04:54
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __MYTASK_H__
#define __MYTASK_H__
#include &quot;TcpConnection.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;Mydict.h&quot;
#include &quot;Cache.h&quot;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

class MyCompare
{
public:
    bool operator()(const wd::MyResult &amp; lhs,const wd::MyResult &amp;rhs)
    {
        if(lhs._iDist !=rhs._iDist)
            return lhs._iDist&lt;rhs._iDist;
        else
            return lhs._iFreq&gt;rhs._iFreq;
    }
private:
};

using Character =string;

class MyTask
{
public:
    MyTask(const string &amp;querry,const wd::TcpConnectionPtr conn)
    :_querry(std::move(querry))
    ,_conn(conn)
    {}
    void execute();
private:
    void queryIndexTable();//查询索引（四个索引）
    void statistic(set&lt;int&gt; &amp;iset);//计算
    int distance(const string &amp; rhs);//计算最小编辑距离
    bool response(wd::Cache &amp; cache);//响应客户端的请求
    vector&lt;Character&gt;getOneCharacter(const string &amp;word);//获取字符数组
    string _querry;
    wd::TcpConnectionPtr _conn;
    priority_queue&lt;wd::MyResult,vector&lt;wd::MyResult&gt;,MyCompare&gt; _resultQue;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    MyTask.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 22:47:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;MyTask.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;Mydict.h&quot;
#include &quot;CacheManger.h&quot;
#include &quot;json/json.h&quot;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
extern __thread int t_number;

bool MyTask::response(wd::Cache &amp;cache)
{
    if(cache.find(_querry))
    {
        _conn-&gt;sendInLoop(cache[_querry]);
        return true;
    }
    return false;
}

int MyTask::distance(const string &amp;rhs)
{
    vector&lt;Character&gt;querryCharacter =getOneCharacter(_querry);
    vector&lt;Character&gt;indexCharacter =getOneCharacter(rhs);

    int len1,len2;
    len1=querryCharacter.size();
    len2=indexCharacter.size();
    int edit[len1+1][len2+1];
    int i,j;
    for(i=0;i&lt;=len1;++i){
        for(j=0;j&lt;=len2;++j){
            edit[i][j]=0;
        }
    }
    for(i=0;i&lt;len1;++i){
        edit[i][0]=i;
    }
    for(j=0;j&lt;=len2;++j){
        edit[0][j]=j;
    }
    for(i=1;i&lt;len1;++i){
        for(j=1;j&lt;=len2;++j){
            int cost =((querryCharacter[i-1]==indexCharacter[j-1])?0:1);
            int deletion =edit[i-1][j]+1;
            int insertion=edit[i][j-1]+1;
            int substitution=edit[i-1][j-1]+cost;
            edit[i][j]=std::min(deletion,std::min(insertion,substitution));
        }
    }
    return edit[len1][len2];
}

void MyTask::statistic(set&lt;int&gt; &amp;iset)
{
    vector&lt;pair&lt;string,int&gt;&gt;dict=(Singleton&lt;wd::Mydict&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getDictDir(),
                                                                     Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getIndexDir()))-&gt;getDict();

    for(auto &amp;idx:iset)
    {
        string key=dict[idx].first;
        int iDist =distance(key);
        if(iDist&lt;=3)
        {
            wd::MyResult res;
            res._word=key;
            res._iDist=iDist;
            res._iFreq=dict[idx].second;
            _resultQue.push(res);
        }
    }
}

vector&lt;Character&gt;MyTask::getOneCharacter(const string &amp; word)
{
    auto cit =word.begin();
    vector&lt;Character&gt; ret;
    while(cit&lt;word.end())
    {
        if(224==(*cit &amp;224)){
            Character oneCharacter;
            oneCharacter.append(cit,cit+3);
            ret.push_back(oneCharacter);
            cit =cit+3;
        }else if(240==(*cit &amp;240)){
            Character oneCharacter;
            oneCharacter.append(cit,cit+4);
            ret.push_back(oneCharacter);
            cit =cit+4;
        }else{
            Character oneCharacter(1,*cit);
            ret.push_back(oneCharacter);
            cit ++;
        }
    }
    return ret;
}

void MyTask::queryIndexTable()
{
    map&lt;string,set&lt;int&gt;&gt;index=(Singleton&lt;wd::Mydict&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getDictDir(),
                                                                  Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getIndexDir()))-&gt;getIndexTable();

    vector&lt;Character&gt; oneCharacter=getOneCharacter(_querry);
    set&lt;int&gt;allRally;
    for(auto myCharacter:oneCharacter)
    {
        auto cit =index.find(myCharacter);
        if(cit!=index.end())
        {
            for(auto &amp;idx:cit-&gt;second)
                allRally.insert(idx);
        }
    }
    statistic(allRally);
}

void MyTask::execute()
{
    wd::Cache &amp;mycache =(Singleton&lt;wd::CacheManger&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getCache()))-&gt;getCache(t_number);
    if(response(mycache))
        return;
    else{
        queryIndexTable();
        Json::FastWriter writerinfo;
        Json::Value arrayObj;
        while(!_resultQue.empty())
        {
            Json::Value new_item;
            new_item[&quot;&quot;]=_resultQue.top()._word;
            _resultQue.pop();
            arrayObj.append(new_item);
        }
        string strEmail=writerinfo.write(arrayObj);
        mycache.addElement(_querry,strEmail);
        _conn-&gt;sendInLoop(strEmail);
    }
}
</code></pre>
<p>==Noncopyable:==</p>
<pre class="cpp"><code>#ifndef __WD_NONCOPYABLE_H__
#define __WD_NONCOPYABLE_H__

namespace  wd
{
    class Noncopyable
    {
    protected:
        Noncopyable(){}
        ~Noncopyable(){}
    private:
        Noncopyable(const Noncopyable &amp;);
        Noncopyable &amp; operator=(const Noncopyable &amp;);
    
    };
}
#endif
</code></pre>
<p>==Socket:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Socket.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 21:46:26
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __WD_SOCKET_H__
#define __WD_SOCKET_H__
#include &quot;Noncopyable.h&quot;
namespace wd
{
    class InetAddress;
    class Socket
    :Noncopyable
    {
    public:
        Socket(int socket);
        Socket();
        ~Socket();
    
        void shutdownWrite();
        int fd()const {return _sockfd;}
        void nonblock();
        static InetAddress getLocalAddr(int socketfd);
        static InetAddress getPeerAddr(int sockfd);
    private:
        int _sockfd;
    };
}
#endif
 
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Socket.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:38:20
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;Socket.h&quot;
#include &quot;SocketUtil.h&quot;
#include &quot;InetAddress.h&quot;

namespace wd
{
Socket::Socket(int sockfd)
:_sockfd(sockfd)
{}

Socket::Socket()
:_sockfd(createSocketFd())
{}

Socket::~Socket()
{
    ::close(_sockfd);
}

void Socket::nonblock()
{
    setNonblock(_sockfd);
}

void Socket::shutdownWrite()
{
    if(-1==::shutdown(_sockfd,SHUT_WR)){
        perror(&quot;shutdown write error!&quot;);
    }
}

InetAddress Socket::getLocalAddr(int sockfd)
{
    struct sockaddr_in addr;
    socklen_t len=sizeof(sockaddr_in);
    if(-1==::getsockname(sockfd,(struct sockaddr *)&amp;addr,&amp;len)){
        perror(&quot;getsockname error!&quot;);
    }
    return InetAddress(addr);
}

InetAddress Socket::getPeerAddr(int sockfd)
{
    struct sockaddr_in addr;
    socklen_t len=sizeof(sockaddr_in);
    if(-1==::getpeername(sockfd,(struct sockaddr *)&amp;addr,&amp;len)){
        perror(&quot;getpeername error!&quot;);
    }
    return InetAddress(addr);
    
}

}
</code></pre>
<p>==SocketIO:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SocketIO.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 17:10:23
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __SOCKETIO_H__
#define __SOCKETIO_H__
#include &lt;stdio.h&gt;

namespace wd
{
    class SocketIO
    {
    public:
        SocketIO(int sockfd);
        size_t readn(char *buf,size_t count);
        size_t writen(const char *buf,size_t count);
        size_t readline(char *buf,size_t max_len);
    private:
        size_t recv_peek(char *buf,size_t count);
        int _sockfd;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    SocketIO.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:56:34
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SocketIO.h&quot;
#include &quot;SocketUtil.h&quot;
namespace wd
{
SocketIO::SocketIO(int sockfd)
:_sockfd(sockfd)
{}

size_t SocketIO::readn(char *buf,size_t count)
{
    size_t nleft =count;
    char *pbuf=buf;
    while(nleft&gt;0)
    {
        int nread =::read(_sockfd,pbuf,nleft);
        if(-1==nread)
        {
            if(errno ==EINTR)
                continue;
            return EXIT_FAILURE;
        }else if(0==nread){
            break;
        }
        pbuf =pbuf+nread;
        nleft=nleft-nread;
    }
    return (count -nleft);
}

size_t SocketIO::writen(const char * buf,size_t count)
{
    size_t nleft =count;
    const char *pbuf=buf;
    while(nleft &gt;0)
    {
        int nwrite=::write(_sockfd,pbuf,nleft);
        if(-1==nwrite)
        {
            if(errno ==EINTR)
                continue;
            return EXIT_FAILURE;
        }
        nleft =nleft -nwrite;
        pbuf =pbuf +nwrite;
    }
    return (count -nleft);
}
size_t SocketIO::recv_peek(char *buf,size_t count)
{
    int nread;
    do{
        nread=::recv(_sockfd,buf,count,MSG_PEEK);
    }while(-1==nread &amp;&amp; errno ==EINTR);
    return nread;
}

size_t SocketIO::readline(char *buf,size_t maxlen)
{
    size_t nleft =maxlen-1;
    char *pbuf=buf;
    size_t total=0;
    while(nleft&gt;0)
    {
        size_t nread =recv_peek(pbuf,nleft);
        if(nread&lt;=0)
            return nread;

        for(size_t idx =0;idx!=nread;++idx){//检查换行符/n
            if(pbuf[idx]==&#39;\n&#39;){
                size_t nsize =idx +1;
                if(readn(pbuf,nsize)!=nsize)
                    return EXIT_FAILURE;
                pbuf +=nsize;
                total +=nsize;
                *pbuf=0;
                return total;
            }
        }
        if(readn(pbuf,nread)!=nread)
            return EXIT_FAILURE;
        pbuf +=nread;
        nleft -=nread;
        total +=nread;
    }
    *pbuf=0;
    return maxlen-1;
}

}
</code></pre>
<p>==SockUtil(根据陈硕编写的LINUX书上分开头文件)==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SocktUtil.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 22:01:30
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_SOCKERUTIL_H__
#define __WD_SOCKERUTIL_H__
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/eventfd.h&gt;
#include &lt;sys/epoll.h&gt;
namespace wd
{
    inline int createSocketFd()
    {
        int fd=::socket(AF_INET,SOCK_STREAM,0);
        if(-1==fd)
        {
            perror(&quot;socket create error!&quot;);
        }
        return fd;
    }
    
    inline void setNonblock(int fd)
    {
        int flags=::fcntl(fd,F_GETFL,0);
        flags |= O_NONBLOCK;
        ::fcntl(fd,F_SETFL,flags);
    }
    
    inline int createEpollFd()
    {
        int efd=::epoll_create1(0);
        if(-1==efd)
        {
            perror(&quot;epoll create1 error!&quot;);
            exit(EXIT_FAILURE);
        }
        return efd;
    }
    
    inline int createEventFd()
    {
        int evtfd=::eventfd(0,EFD_NONBLOCK|EFD_CLOEXEC);
        if(-1==evtfd)
        {
            perror(&quot;eventfd create error!&quot;);
        }
        return evtfd;
    }
    inline void addEpollFdRead(int efd,int fd)
    {
        struct epoll_event ev;
        ev.data.fd=fd;
        ev.events=EPOLLIN;
        int ret=epoll_ctl(efd,EPOLL_CTL_ADD,fd,&amp;ev);
        if(-1==ret)
        {
            perror(&quot;epoll ctl add error!&quot;);
            exit(EXIT_FAILURE);
        }
    }
    inline void delEpollReadFd(int efd,int fd)
    {
        struct epoll_event ev;
        ev.data.fd=fd;
        int ret=epoll_ctl(efd,EPOLL_CTL_DEL,fd,&amp;ev);
        if(-1==ret)
        {
            perror(&quot;epoll ctl delete error!&quot;);
            exit(EXIT_FAILURE);
        }
    }
    
    inline size_t recvPeek(int sockfd,void *buf,size_t len)
    {
        int nread;
        do{
            nread=::recv(sockfd,buf,len,MSG_PEEK);
        }while(nread==-1 &amp;&amp; errno ==EINTR);
        return nread;
    }
    
    inline bool isConnectionClosed(int sockfd)
    {
        char buf[1024];
        int nread=recvPeek(sockfd,buf,sizeof(buf));
        if(-1==nread)
        {
            perror(&quot;recvPeek error!&quot;);
            return true;
        }
        return (0==nread);
    }
}
#endif
</code></pre>
<p>==SpellCorrrectSever:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SpellCorrectServer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:41:13
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __SPELLCORRECTSERVER_H__
#define __SPELLCORRECTSERVER_H__
#include &quot;TcpServer.h&quot;
#include &quot;Threadpool.h&quot;

using namespace wd;
namespace wd
{
    class SpellCorrectServer
    {
    public:
        SpellCorrectServer(const string &amp; ip
                           ,unsigned short port
                           ,size_t threadNUM
                           ,size_t queSize);
        void start();
    private:
        void onConnection(const TcpConnectionPtr &amp;);
        void onMessage(const TcpConnectionPtr &amp;);
        void onClose(const TcpConnectionPtr &amp;);
        TcpServer _tcpserver;
        Threadpool _threadpoll;
    };
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    SpellCorrectServer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:20:41
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SpellCorrectServer.h&quot;
#include &quot;MyTask.h&quot;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;functional&gt;
using namespace std;

void SpellCorrectServer::onConnection(const wd::TcpConnectionPtr &amp; conn)
{
    cout&lt;&lt;conn-&gt;toString()&lt;&lt;endl;
    conn-&gt;send(&quot;hello ,welcome to WTP Chat Server.\r\n&quot;);
}

void SpellCorrectServer::onMessage(const wd::TcpConnectionPtr &amp; conn)
{
    string s(conn-&gt;receive());
    MyTask task(s,conn);
    _threadpoll.addTask(std::bind(&amp;MyTask::execute,&amp;task));
    cout&lt;&lt;&quot;&gt;add task to threadpool&quot;&lt;&lt;endl;
}

void SpellCorrectServer::onClose(const wd::TcpConnectionPtr &amp;conn)
{
    ::printf(&quot;%s close\n&quot;,conn-&gt;toString().c_str());
}

SpellCorrectServer::SpellCorrectServer(const string &amp; ip
                                       ,unsigned short port
                                       ,size_t threadNUM
                                       ,size_t queSize)
:_tcpserver(ip,port)
,_threadpoll(threadNUM,queSize)
{}

void SpellCorrectServer::start()
{
    _threadpoll.start();
    _tcpserver.setConnectionCallback(std::bind(&amp;SpellCorrectServer::onConnection,this,std::placeholders::_1));
    _tcpserver.setMessageCallback(std::bind(&amp;SpellCorrectServer::onMessage,this,std::placeholders::_1));
    _tcpserver.setCloseCallback(std::bind(&amp;SpellCorrectServer::onClose,this,std::placeholders::_1));
    _tcpserver.start();
}
</code></pre>
<p>==TaskQue:==</p>
<pre class="cpp"><code>#ifndef __WD_TASKQUEUE_H__
#define __WD_TASKQUEUE_H__

#include &quot;MutexLock.h&quot;
#include &quot;Condition.h&quot;
#include &lt;queue&gt;
#include &lt;functional&gt;

namespace wd
{
    typedef std::function&lt;void()&gt;Task;
    
    class TaskQueue
    {
    public:
        TaskQueue(size_t queSize)
        :_queSize(queSize)
        ,_mutex()
        ,_notFull(_mutex)
        ,_notEmpty(_mutex)
        ,_flag(true)
        {}
    
        void push(Task &amp;&amp;task);
        Task pop();
        bool empty()const
        {
            return _que.size()==0;
        }
        bool full()const
        {return _que.size()==_queSize;}
        void wakeup()
        {   
            if(_flag)
                _flag=false;
            _notEmpty.notifyAll();
        }
    private:
        size_t _queSize;
        std::queue&lt;Task&gt; _que;
        MutexLock _mutex;
        Condition _notFull;
        Condition _notEmpty;
        bool _flag;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;TaskQueue.h&quot;

using namespace wd;
//生产者所在的线程
void TaskQueue::push(Task &amp;&amp; task)
{
    MutexLockGuard autoLock(_mutex);
    while(full())
    {
        _notFull.wait();
    }
    _que.push(std::move(task));
    _notEmpty.notify();
}

//消费者所在线程
Task TaskQueue::pop()
{
    MutexLockGuard autoLock(_mutex);
    while(_flag &amp;&amp; empty())
    {
        _notEmpty.wait();
    }
    if(_flag){
        Task task=_que.front();
        _que.pop();
        _notFull.notify();
        return task;
    }else{
        return NULL;
    }
}
#if 0
Task TaskQueue::pop()
{
    MutexLockGuard autoLock(_mutex);
    while(_flag &amp;&amp; empty())
    {
        _notEmpty.wait();
    }
    if(_flag){
        Task task =_que.front();
        _que.pop();
        _notFull.notify();
        return task;
    }else{
        return NULL;
    }
}
#endif
</code></pre>
<p>==TcpConnection:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpConnection.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 17:15:33
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_TCPCONNECTION_H__
#define __WD_TCPCONNECTION_H__

#include &quot;Noncopyable.h&quot;
#include &quot;InetAddress.h&quot;
#include &quot;Socket.h&quot;
#include &quot;SocketIO.h&quot;

#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;
namespace wd
{
    class EpollPoller;
    class TcpConnection;
    typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;

    class TcpConnection
    :Noncopyable
    ,public std::enable_shared_from_this&lt;TcpConnection&gt;
    {
    public:
        typedef std::function&lt;void(const TcpConnectionPtr &amp;)&gt;TcpConnectionCallback;
        TcpConnection(int sockfd,EpollPoller *loop);
        ~TcpConnection();

        std::string receive();
        void send(const std::string &amp;msg);
        void sendInLoop(const std::string &amp;msg);
        void shutdown();

        std::string toString();
        void setConnectionCallback(TcpConnectionCallback cb);
        void setMessageCallback(TcpConnectionCallback cb);
        void setCloseCallback(TcpConnectionCallback cb);

        void handleConnectionCallback();
        void handleMessageCallback();
        void handleCloseCallback();
    private:
        Socket _sockfd;
        SocketIO _sockIO;
        const InetAddress _localAddr;
        const InetAddress _peerAddr;
        bool _isShutdownWrite;
        EpollPoller * _loop;
        TcpConnectionCallback _onConnectionCb;
        TcpConnectionCallback _onMessageCb;
        TcpConnectionCallback _onCloseCb;

    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpConnection.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 22:22:22
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;TcpConnection.h&quot;
#include &quot;EpollPoller.h&quot;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

namespace wd
{
TcpConnection::TcpConnection(int sockfd,EpollPoller * loop)
:_sockfd(sockfd)
,_sockIO(sockfd)
,_localAddr(wd::Socket::getLocalAddr(sockfd))
,_peerAddr(wd::Socket::getPeerAddr(sockfd))
,_isShutdownWrite(false)
,_loop(loop)
{_sockfd.nonblock();}

TcpConnection::~TcpConnection()
{
    if(!_isShutdownWrite)
    {
        _isShutdownWrite=true;
        shutdown();
    }
    printf(&quot;~TcpConnection()\n&quot;);
}

std::string TcpConnection::receive()
{
    char buf[65536];
    memset(buf,0,sizeof(buf));
    size_t ret =_sockIO.readline(buf,sizeof(buf));
    if(0==ret){
        return std::string();
    }else{
        return std::string(buf);
    }
}

void TcpConnection::send(const std::string &amp;msg)
{
    size_t len=msg.size();
    _sockIO.writen((const char *)&amp;len,sizeof(int));
    _sockIO.writen(msg.c_str(),len);
}

void TcpConnection::shutdown()
{
    if(!_isShutdownWrite)
        _sockfd.shutdownWrite();
    _isShutdownWrite=true;
}

std::string TcpConnection::toString()
{
    char str[100];
    snprintf(str,sizeof(str),&quot;%s:%d-&gt;%s:%d&quot;
             ,_localAddr.ip().c_str()
             ,_localAddr.port()
             ,_peerAddr.ip().c_str()
             ,_peerAddr.port());
    return std::string(str);
}

void TcpConnection::setConnectionCallback(TcpConnectionCallback cb)
{
    _onConnectionCb =cb;
}
void TcpConnection::setMessageCallback(TcpConnectionCallback cb)
{
    _onMessageCb =cb;
}
void TcpConnection::setCloseCallback(TcpConnectionCallback cb)
{
    _onCloseCb =cb;
}

void TcpConnection::handleConnectionCallback()
{
    if(_onConnectionCb){
        _onConnectionCb(shared_from_this());
    }
}
void TcpConnection::handleMessageCallback()
{
    if(_onMessageCb){
        _onMessageCb(shared_from_this());
    }
}
void TcpConnection::handleCloseCallback()
{
    if(_onCloseCb){
        _onCloseCb(shared_from_this());
    }
}

void TcpConnection::sendInLoop(const std::string &amp; msg)
{
    _loop-&gt;runInLoop(std::bind(&amp;TcpConnection::send,this,msg));
}

}
</code></pre>
<p>==TcpServer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpServer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:15:21
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __WD_TCPSERVER_H__
#define __WD_TCPSERVER_H__

#include &quot;Acceptor.h&quot;
#include &quot;EpollPoller.h&quot;
#include &lt;string&gt;

using std::string;
namespace wd
{
    class TcpServer
    {
    public:
        typedef EpollPoller::EpollCallback TcpServerCallback;
        TcpServer(const string &amp; ip,unsigned short port);
        TcpServer(unsigned short port);

        void start();
        void stop();
        void setConnectionCallback(TcpServerCallback cb);
        void setMessageCallback(TcpServerCallback cb);
        void setCloseCallback(TcpServerCallback cb);

    private:
        Acceptor _acceptor;
        EpollPoller _poller;

        TcpServerCallback _connectionCallback;
        TcpServerCallback _messageCallback;
        TcpServerCallback _closeCallback;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpServer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 19:59:37
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;TcpServer.h&quot;
#include &quot;InetAddress.h&quot;
#include &quot;SocketUtil.h&quot;
#include &lt;iostream&gt;
using namespace std;
namespace wd
{
    TcpServer::TcpServer(const string &amp; ip,unsigned short port)
    :_acceptor(createSocketFd(),InetAddress(ip.c_str(),port))
    ,_poller(_acceptor)
    {}

    void TcpServer::start()
    {
        _acceptor.ready();
        _poller.setConnectionCallback(_connectionCallback);
        _poller.setMessageCallback(_messageCallback);
        _poller.setCloseCallback(_closeCallback);
        _poller.loop();
    }

    void TcpServer::stop()
    {
        _poller.unloop();
    }

    void TcpServer::setConnectionCallback(TcpServerCallback cb)
    {_connectionCallback=cb;}

    void TcpServer::setMessageCallback(TcpServerCallback cb)
    {_messageCallback=cb;}

    void TcpServer::setCloseCallback(TcpServerCallback cb)
    {_closeCallback=cb;}
}
</code></pre>
<p>==Thread:==</p>
<pre class="cpp"><code>#ifndef  __WD_THREAD_H__
#define  __WD_THREAD_H__

#include &quot;Noncopyable.h&quot;
#include &lt;pthread.h&gt;
#include &lt;functional&gt;
using std::function;
namespace wd
{
    class Thread;
    struct ThreadPtr
    {
        int _number;
        Thread *_pthread;
    };
    class Thread
    :Noncopyable
    {
        using ThreadCallback =function&lt;void()&gt;;
    public:
        Thread(ThreadCallback &amp;&amp;cb);
        ~Thread();
    
        void start(int number);
        void join();
    
        bool isRunning()const {return _isRunning;}
    
    private:
        static void * threadFunc(void *);
        pthread_t _pthid;
        bool _isRunning;
        ThreadCallback _cb;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;Thread.h&quot;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

__thread int t_number;//将线程编号作为线程存储的标记

Thread::Thread(ThreadCallback &amp;&amp; cb)//这里的右值引用本身取决于是否有名字
:_pthid(0)
,_isRunning(false)
,_cb(std::move(cb))
{
    cout&lt;&lt;&quot;Thread(cb)&quot;&lt;&lt;endl;
}

void Thread::start(int number)
{
    ThreadPtr *threadPtr=new ThreadPtr();
    threadPtr-&gt;_number=number;
    threadPtr-&gt;_pthread=this;
    pthread_create(&amp;_pthid,NULL,threadFunc,threadPtr);
    _isRunning=true;
}

void *Thread::threadFunc(void *arg)
{//应用了线程存储
    ThreadPtr *threadPtr=static_cast&lt;ThreadPtr*&gt;(arg);
    Thread * pthread=threadPtr-&gt;_pthread;
    t_number=threadPtr-&gt;_number;
    if(pthread)
        pthread-&gt;_cb();//线程开始工作！
    delete threadPtr;
    //Thread * pthread =threadPtr-&gt;_pthread;
    return NULL;
}
#if 0
void *Thread::threadFunc(void *arg)
{
    ThreadPtr *threadPtr =static_cast&lt;ThreadPtr*&gt;(arg);
    Thread * pthread =threadPtr-&gt;_pthread;
    t_number =threadPtr-&gt;_number;
    if(pthread)
        pthread-&gt;_cb();
    delete threadPtr;
    return NULL;
}
#endif
void Thread::join()
{
    pthread_join(_pthid,NULL);
    _isRunning=false;
}

Thread::~Thread()
{
    if(_isRunning)
    {
        pthread_detach(_pthid);
        _isRunning=false;
    }
    cout&lt;&lt;&quot;~Thread()&quot;&lt;&lt;endl;
}
</code></pre>
<p>==Threadpool:==</p>
<pre class="cpp"><code>#ifndef __WD_THREADPOLL_H__
#define __WD_THREADPOLL_H__
#include &quot;TaskQueue.h&quot;
#include &quot;Thread.h&quot;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;
using std::shared_ptr;
using std::vector;
namespace  wd
{
    class Threadpool
    {
    public:
        using Task=std::function&lt;void()&gt;;
    
        Threadpool(size_t threadNum,size_t queSize)
        :_threadNum(threadNum)
        ,_queSize(queSize)
        ,_taskQue(_queSize)
        ,_isExit(false)
        {
            _threads.reserve(_threadNum);
        }
        
        ~Threadpool();
    
        void start();
        void stop();
        void addTask(Task &amp;&amp; task);
    
    private:
        void threadFunc();
        Task getTask();
        size_t _threadNum;
        size_t _queSize;
        vector&lt;shared_ptr&lt;Thread&gt;&gt; _threads;
        TaskQueue _taskQue;
        bool _isExit;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;Threadpool.h&quot;
#include &quot;Thread.h&quot;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace wd;

void Threadpool::start()
{
    for(size_t idx=0;idx&lt;_threadNum;++idx)
    {
        shared_ptr&lt;Thread&gt;pThread(new Thread(std::bind(&amp;Threadpool::threadFunc,this)));
        _threads.push_back(std::move(pThread));
    }
    int number=0;
    for(auto &amp;pThread:_threads)
    {
        pThread-&gt;start(number);
        ++number;
    }
}
void Threadpool::stop()//为了线程安全，将stop方法置于主线程中
{
    if(!_isExit)
    {
        while(!_taskQue.empty()){
            ::sleep(1);
            cout&lt;&lt;&quot;Threadpool sleep 1 second!&quot;&lt;&lt;endl;
        }
        _isExit=true;
        cout&lt;&lt;&quot;Threadpool -&gt;stop:_isExit=&quot;&lt;&lt;_isExit&lt;&lt;endl;
        _taskQue.wakeup();
        for(auto &amp;pthread:_threads){
            pthread-&gt;join();
        }
    }
}

Threadpool::~Threadpool()
{
    if(!_isExit){
        stop();
    }
}
void Threadpool::addTask(Task &amp;&amp; task)
{
    _taskQue.push(std::move(task));
}

Task Threadpool::getTask()
{
    return _taskQue.pop();
}

void Threadpool::threadFunc()
{
    while(!_isExit)
    {
        Task task=getTask();
        if(task){
            task();
        }
    }
}
</code></pre>
<p>==Timer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Timer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:00:45
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_TIMER_H__
#define __WD_TIMER_H__
#include &lt;functional&gt;

namespace wd
{
    class Timer
    {
    public:
        using TimerCallback =std::function&lt;void()&gt;;
        Timer(int initailTime,int intervalTime,TimerCallback &amp;&amp; cb);
        ~Timer();
        void start();
        void stop();
    private:
        int _fd;
        int _initialTime;
        int _intervalTime;
        TimerCallback _cb;
        bool _isStarted;
        int createTimerFd();
        void setTimerfd(int initialTime, int intervalTime);
        void handleRead();  
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Timer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:09:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;Timer.h&quot;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/timerfd.h&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

Timer::Timer(int initialTime,int intervalTime,TimerCallback &amp;&amp; cb)
:_fd(createTimerFd())
,_initialTime(initialTime)
,_intervalTime(intervalTime)
,_cb(std::move(cb))
,_isStarted(false)
{}

void Timer::start()
{
    struct pollfd pfd;
    pfd.fd=_fd;
    pfd.events=POLLIN;
    setTimerfd(_initialTime,_intervalTime);//开启定时器
    _isStarted=true;
    while(_isStarted){
        int nready=::poll(&amp;pfd,1,5000);
        if(-1==nready &amp;&amp;errno ==EINTR){
            continue;
        }else if(-1==nready){
            perror(&quot;&gt;&gt;&gt;poll error!&quot;);
            exit(EXIT_FAILURE);
        }else if(0==nready){
            cout&lt;&lt;&quot;&gt;&gt;&gt;poll timeout!&quot;&lt;&lt;endl;
        }else{
            if(pfd.revents &amp; POLLIN){
                handleRead();//先对定时器进行处理
                if(_cb){
                    _cb();//再去执行回调任务
                }
            }
        }
    }
}

void Timer::stop()
{
    setTimerfd(0,0);
    if(_isStarted){
        _isStarted=false;
    }
}

Timer::~Timer()
{
    if(_isStarted){
        stop();
    }
}

int Timer::createTimerFd()
{
    int fd=::timerfd_create(CLOCK_REALTIME,0);
    if(-1==fd){
        perror(&quot;&gt;&gt;timerfd_create error!&quot;);
    }
    return fd;
}

void Timer::setTimerfd(int initialTime,int intervalTime)
{
    struct itimerspec value;
    value.it_value.tv_sec=initialTime;
    value.it_value.tv_nsec=0;
    value.it_interval.tv_sec=intervalTime;
    value.it_interval.tv_nsec=0;
    int ret=::timerfd_settime(_fd,0,&amp;value,NULL);
    if(-1==ret){
        perror(&quot;&gt;&gt;&gt;timerfd_settime error!&quot;);
    }
}
#if 0
void Timer::handleRead()
{
    uint64_t howmany;
    int ret =::read(_fd,&amp;howmany,sizeof(uint64_t));
    if(ret!=sizeof(uint64_t)){
        perror(&quot;read!&quot;);
    }
}
#endif


void Timer::handleRead()
{
    uint64_t howmany;//为一个64位
    int ret=::read(_fd,&amp;howmany,sizeof(uint64_t));
    if(ret!=sizeof(uint64_t)){
        perror(&quot;&gt;&gt;&gt;read error!&quot;);
    }
}
</code></pre>
<p>==TimerThread:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TimerThread.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 17:12:51
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#ifndef __WD_TIMERTHREAD_H__
#define __WD_TIMERTHREAD_H__

#include &quot;Timer.h&quot;
#include &quot;Thread.h&quot;

#include &lt;functional&gt;

namespace wd
{
    
class TimerThread
{
public:
    using TimerCallback = std::function&lt;void()&gt;;
    TimerThread(int, int, TimerCallback &amp;&amp; cb);
    ~TimerThread();

    void start();
    void stop();


private:
    Timer _timer;
    Thread _subThread;
    bool _isStarted;
};
}//end of namespace wd

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TimerThread.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:09:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;TimerThread.h&quot;


using namespace wd;

TimerThread::TimerThread(int initialTime, int intervalTime, TimerCallback &amp;&amp; cb)
: _timer(initialTime, intervalTime, std::move(cb))
, _subThread(std::bind(&amp;Timer::start, &amp;_timer))
, _isStarted(false)
{}

void TimerThread::start()
{
    _subThread.start(0);
    _isStarted = true;
}

void TimerThread::stop()
{
    if(_isStarted) {
        _timer.stop();
        _subThread.join();
        _isStarted = false;
    }
}

TimerThread::~TimerThread()
{
    if(_isStarted)
        stop();
}
</code></pre>
<p>==main:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    main.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:09:32
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SpellCorrectServer.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;CacheManger.h&quot;
#include &quot;TimerThread.h&quot;
#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;
using namespace wd;

int main()
{
    wd::CacheManger *mycacheManger=Singleton&lt;CacheManger&gt;::getInstance(Singleton&lt;Configuration&gt;
                                                         ::getInstance(CONFPATH)-&gt;getCache());
    TimerThread timer(5,600,std::bind(&amp;CacheManger::periodicUpdate,mycacheManger));
    timer.start();
    SpellCorrectServer myspell(Singleton&lt;Configuration&gt;::getInstance(CONFPATH)-&gt;getIp()
                               ,Singleton&lt;Configuration&gt;::getInstance(CONFPATH)-&gt;getPort()
                               ,4
                               ,10);
    myspell.start();
    return 0;
}
</code></pre>
<hr />
<p><strong>小结：（1）已经实现项目需求，中文和英文单词都能查询，经过测试，运行稳定，能输出不少候选词</strong></p>
<p>​ <strong>（2）仍然存在少量bug,例如偶尔会发生段错误</strong></p>
<p>​ <strong>（3）由于时间问题，json读出的数据key-value的key值没有打印，用户界面还未来得及优化</strong></p>
<p>​ <strong>（4）陈硕的《linux多线程服务端编程》使用linux接口（timerfd）,没用posix接口（eventfd）</strong><p>---恢复内容结束---</p># <strong><u>我的Spellcorrect 开发文档</strong></p>
<hr />
<p><strong></u></strong></p>
<p>[TOC]</p>
<hr />
<h3 id="相关配置文件及准备工作-1"><strong>相关配置文件及准备工作：</strong></h3>
<p><strong>我的主要文件夹分为三个：<u>分别为客户端，cppjieba分词库，离线部分及服务器部分</u></strong></p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560856582308.png" alt="1560856582308" /></p>
<h6 id="客户端部分内部为客户端源码及运行程序-1">客户端部分：<u>内部为客户端源码及运行程序</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560856552431.png" alt="1560856552431" /></p>
<h6 id="cppjieba分词库部分就不赘述请自行安装-1">cppjieba分词库部分，就不赘述，请自行安装</h6>
<h6 id="离线部分内部有中英文件夹放置索引及词典文件还有配置文件及分词库其余为代码-1">离线部分：<u>内部有中英文件夹放置索引及词典文件，还有配置文件及分词库，其余为代码</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857073864.png" alt="1560857073864" /></p>
<h6 id="服务器部分最为重要的配置文件及数据部分头文件在include实现文件在src里面-1">服务器部分：<u>最为重要的配置文件及数据部分，头文件在include，实现文件在src里面</u></h6>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857034230.png" alt="1560857034230" /></p>
<hr />
<h3 id="演示效果中文-1"><strong>演示效果（中文）：</strong></h3>
<p>==启动时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857677039.png" alt="1560857677039" /></p>
<p>==客户端连入时时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857739202.png" alt="1560857739202" /></p>
<p>==输入“赵”==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858117388.png" alt="1560858117388" /></p>
<p>==输入“周杰伦”==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858201376.png" alt="1560858201376" /></p>
<p>==输入清华大学==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858560147.png" alt="1560858560147" /></p>
<hr />
<h3 id="演示效果英语-1"><strong>演示效果（英语）：</strong></h3>
<p>==启动时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857677039.png" alt="1560857677039" /></p>
<p>==客户端连入时时服务器：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560857739202.png" alt="1560857739202" /></p>
<p>==输入student：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858008297.png" alt="1560858008297" /></p>
<p>==输入spell：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560858872540.png" alt="1560858872540" /></p>
<p>==输入computer：==</p>
<p><img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\1560859162357.png" alt="1560859162357" /></p>
<hr />
<h3 id="代码部分-1"><strong>代码部分：</strong></h3>
<h6 id="离线部分-1">离线部分：</h6>
<p><img src="file:///C:\Users\dell\AppData\Local\Temp\ksohtml13180\wps1.jpg" alt="img" /></p>
<p>==Makefile:==</p>
<pre><code>SRCS:=$(wildcard *.cc)
OBJS:= $(patsubst %.cc, %.o, $(SRCS))

CXX:=g++

CXXFLAGS:= -w -g -std=c++11 $(addprefix -I, $(INC_DIR)) $(LIBS) -Wno-deprecated -I ../cppjieba/include/ -I ../cppjieba/deps

EXE:=./main

$(EXE):$(OBJS)
        $(CXX) -o $(EXE) $(OBJS) $(CXXFLAGS)

clean:
        rm -rf $(EXE)
            rm -rf $(OBJS)

</code></pre>
<p>==Configuration:==</p>
<pre><code>///=======================================
/// File:    Configuration.h
/// Author:  wtptorres(1584292712@qq.com)
/// Date:    2019-06-12 00:30:39
/// Dream:   Don&#39;t forget your dreams!
/// ======================================

#ifndef __CONFIGURATION_H__
#define __CONFIGURATION_H__
#include &quot;Nocopyable.h&quot;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;

class Configuration
:public Noncopyable
{
public:
    Configuration(const string &amp;filePath);
    string getEnglishDir() const {return _englishDir;}
    string getChineseDir() const {return _chineseDir;}
private:
    string _filePath;
    string _englishDir;
    string _chineseDir;
};
template&lt;typename T&gt;
class Singleton
{
public:
    template&lt;typename ...Args&gt;
    static T* getInstance(Args ...args)
    {
        if(!_pInstance)
            _pInstance = new T(args...);
        return _pInstance;
    }
    static void destroy()
    {
        if(_pInstance)
            delete _pInstance;
    }
private:
    Singleton();
    ~Singleton();
    static T *_pInstance;                    
};
template&lt;typename T&gt;
T * Singleton&lt;T&gt;::_pInstance = NULL;
#endif
</code></pre>
<pre><code>  1  ///=======================================
  2  /// File:    Configuration.cc
  3  /// Author:  wtptorres(1584292712@qq.com)
  4  /// Date:    2019-06-12 00:30:04
  5  /// Dream:   Don&#39;t forget your dreams!
  6  /// ======================================
  7 
  8                                     
  9 #include &quot;Configuration.h&quot;
 10 #include &lt;utility&gt;
 11 #include &lt;fstream&gt;
 12 #include &lt;iostream&gt;
 13 using namespace std;
 14 
 15 Configuration::Configuration(const string &amp;filePath)
 16 :_filePath(std::move(filePath))
 17 {
 18     ifstream ifs(_filePath);
 19     if(!ifs)
 20         cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
 21     ifs&gt;&gt;_englishDir;
 22     ifs&gt;&gt;_chineseDir;
 23     ifs.close();
 24 }
</code></pre>
<pre><code> ///=======================================
 /// File:    Nocopyable.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 00:24:36
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __NOCOPYABLE_H__
#define __NOCOPYABLE_H__
class Noncopyable
{
public:
    Noncopyable()=default;
    ~Noncopyable()=default;
private:
    Noncopyable(const Noncopyable &amp;rhs);
    Noncopyable &amp;operator =(const Noncopyable &amp;rhs);
};
#endif
</code></pre>
<p>==DictProducer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    DictProducer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 16:40:25
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __DICTPRODUCER_H__
#define __DICTPRODUCER_H__
#include &quot;SplitTool.h&quot;
using namespace std;
#include &quot;Nocopyable.h&quot;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;utility&gt;


class DictProducer
:public Noncopyable
{
public:
    DictProducer(const string,const string,const string &amp;,SplitToolJieba *);
    ~DictProducer(){}
    void build_dict();
    void build_cn_dict();
    void store_dict();
    vector&lt;pair&lt;string,int&gt;&gt;&amp; getIndict(){return _indict;}
private:
    void processEnglishWord(string &amp;word);
    void processChineseWord(string &amp;word);//除去中文的数字
    void construct_indict();
    string _englishDir;
    string _chineseDir;
    string _goleFilePath;
    vector&lt;string&gt; _englishFiles;
    vector&lt;string&gt; _chineseFiles;
    map&lt;string,int&gt; _dict;
    vector&lt;pair&lt;string,int&gt;&gt; _indict;
    shared_ptr&lt;SplitToolJieba&gt; _splitTool;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    DictProducer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 16:50:46
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;DictProducer.h&quot;
#include &lt;cctype&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#define FIRSTSIZE 10000
using namespace std;

DictProducer::DictProducer(const string englishDir,const string chineseDir,const string &amp;goleFilePath,SplitToolJieba *splitToolPtr)
    :_englishDir(englishDir)
    ,_chineseDir(chineseDir)
    ,_goleFilePath(goleFilePath)
{
    _splitTool.reset(splitToolPtr);
    std::ifstream ifsEnglish(_englishDir);
    std::ifstream ifsChinese(_chineseDir);
    string filePath;
    if(!ifsEnglish || !ifsChinese){
        cout&lt;&lt;&quot;Dict file open error!&quot;&lt;&lt;endl;
    }
    while(ifsEnglish&gt;&gt;filePath)
    {
        _englishFiles.push_back(filePath);
    }
    while(ifsChinese&gt;&gt;filePath)
    {
        _chineseFiles.push_back(filePath);
    }
    _indict.reserve(FIRSTSIZE);
}

void DictProducer::processEnglishWord(string &amp;word)
{
    auto cit =word.begin();
    for(;cit!=word.end();++cit)
    {   //去除标点符号或数字
        if(!isalpha(*cit)){
            word.erase(cit);
            --cit;//迭代器位置发生改变
        }else if(isupper(*cit)){//将大写字母改为小写
            *cit =tolower(*cit);
        }
    }
}

void DictProducer::processChineseWord(string &amp;word)
{
    auto cit =word.begin();
    for(;cit!=word.end();++cit)
    {   //去除数字
        if(!isalnum(*cit)){
            word.erase(cit);
            --cit;
        }
    }
}

void DictProducer::build_dict()//建立英文词典
{
    for(auto &amp;filePath:_englishFiles)
    {
        ifstream ifs(filePath);
        if(!ifs){
            cout&lt;&lt;&quot;English File open error!&quot;&lt;&lt;endl;
        }
        string word;
        while(ifs&gt;&gt;word)
        {
            processEnglishWord(word);
            auto cit =_dict.find(word);
            if(word.size()&gt;0 &amp;&amp; cit ==_dict.end()){
                _dict.insert(std::make_pair(word,1));
            }else if(cit!=_dict.end()){
                ++ cit -&gt;second;
            }
        }
    }
}


void DictProducer::build_cn_dict()
{
    vector&lt;string&gt;words;
    for(auto filePath:_chineseFiles)
    {
        ifstream ifs(filePath);
        if(!ifs){
            cout&lt;&lt;&quot;Chinese file open error!&quot;&lt;&lt;endl;
        }
        string sentence;
        while(std::getline(ifs,sentence))
        {
            _splitTool-&gt;Cut(sentence);
        }
    }
    vector&lt;string&gt;&amp; results =_splitTool-&gt;getResult();
    for(auto &amp;res:results)
    {
        processChineseWord(res);
        auto cit =_dict.find(res);
        if(cit ==_dict.end()){
            _dict.insert(std::make_pair(res,1));
        }else{
            ++ cit -&gt;second;
        }
    }
}

void DictProducer::store_dict()
{
    construct_indict();
    ofstream ofs(_goleFilePath);
    if(!ofs)
        cout&lt;&lt;&quot;Store_dict open file error!&quot;&lt;&lt;endl;
    for(auto &amp;mypair:_indict)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;&lt;&lt;mypair.second&lt;&lt;endl;
    }
    ofs.close();
}

void DictProducer::construct_indict()
{
    for(auto dictpair:_dict){
        _indict.push_back(dictpair);
    }
}
</code></pre>
<p>==GetIndex:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    GetIndex.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 08:52:04
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __GETINDEX_H__
#define __GETINDEX_H__
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;unordered_set&gt;
using namespace std;

class GetIndex
{
public:
    GetIndex(const string &amp;,const string &amp;,const string &amp;);
    ~GetIndex(){}
    void construct_index();
    void store_index();
private:
    bool isEnglish(const string &amp;rhs) const;
    vector&lt;string&gt;getOneCharacter(const string &amp; word);
    string _sourceFilePath;
    string _goleFilePath;
    string _stopWordsFilePath;
    vector&lt;pair&lt;string,int&gt;&gt;_dict;
    unordered_set&lt;string&gt;_stopWords;
    unordered_map&lt;string,set&lt;int&gt;&gt;_index;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    GetIndex.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 09:00:11
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;GetIndex.h&quot;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
using namespace std;

GetIndex::GetIndex(const string &amp; sourceFilePath,const string &amp;goleFilePath,const string &amp;stopWordsFilePath)
:_sourceFilePath(std::move(sourceFilePath))
,_goleFilePath(std::move(goleFilePath))
,_stopWordsFilePath(std::move(stopWordsFilePath))
{
    ifstream ifs(_sourceFilePath);
    if(!ifs){
        cout&lt;&lt;&quot;GetIndex file open error!&quot;&lt;&lt;endl;
    }
    string line;
    while(getline(ifs,line))
    {
        istringstream iss(line);
        string key;
        int value;
        iss&gt;&gt;key&gt;&gt;value;
        _dict.push_back(std::make_pair(key,value));
    }
    ifstream ifs1(_stopWordsFilePath);
    if(!ifs1){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
    }
    string stopWord;
    while(ifs1&gt;&gt;stopWord,!ifs1.eof())
    {
        _stopWords.insert(stopWord);
    }
}

vector&lt;string&gt; GetIndex::getOneCharacter(const string &amp;word)
{
    vector&lt;string&gt;tmp;
    auto cit =word.begin();
    while(cit&lt;word.end())
    {
        if(224==(*cit &amp;224))
        {
            string oneCharacter;
            oneCharacter.append(cit,cit+3);
            tmp.push_back(oneCharacter);
            cit +=3;
        }else if(240==(*cit &amp;240)){
            string oneCharacter;
            oneCharacter.append(cit,cit+4);
            tmp.push_back(oneCharacter);
            cit +=4;
        }else
            break;
    }
    return tmp;
}
             
bool GetIndex::isEnglish(const string &amp;rhs) const
{
    char ch =*(rhs.begin());
    if(ch&lt;0)
        return false;
    return true;
}
#if 0
bool GetIndex::isEnglish(const string &amp;rhs) const
{
    char ch =*(rhs.begin());
    if(ch&lt;0){
        return false;
    }
    return true;
}
#endif
void GetIndex::construct_index()
{
    for(size_t i=0;i!=_dict.size();++i)
    {
        string tmp=_dict[i].first;
        if(isEnglish(tmp))
        {
            for(auto ch:tmp)
            {
                string charactor(1,ch);
                if(isalpha(ch))
                {
                    auto cit =_index.find(charactor);
                    if(cit ==_index.end())
                    {
                        set&lt;int&gt; smp;
                        smp.insert(i);
                        _index.insert(std::make_pair(charactor,smp));
                    }else{//已经存在了该字母的索引
                        cit-&gt;second.insert(i);
                    }
                }
            }
        }else{//中文处理部分
            vector&lt;string&gt; oneCharacterRally =getOneCharacter(tmp);
            for(auto oneCharacter:oneCharacterRally)
            {//stop_words中不存在该单词，则加入索引中
                if(_stopWords.find(oneCharacter)==_stopWords.end()){
                    auto it =_index.find(oneCharacter);
                    if(it == _index.end()){
                        set&lt;int&gt;tmp;
                        tmp.insert(i);
                        _index.insert(std::make_pair(oneCharacter,tmp));
                    }else{
                        it-&gt;second.insert(i);
                    }
                }
            }
        }
    }
}

void GetIndex::store_index()
{   
    //ofs存储索引的内容
    std::ofstream ofs(_goleFilePath);
    if(!ofs){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
        return;
    }
    for(auto data:_index)
    {
        ofs&lt;&lt;data.first&lt;&lt;&quot; &quot;;
        for(auto linenum:data.second)
        {
            ofs&lt;&lt;linenum&lt;&lt;&quot; &quot;;
        }
        ofs&lt;&lt;endl;
    }
    ofs.close();
}
</code></pre>
<p>==SplitTool:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SplitTool.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 17:12:01
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#ifndef __SPLITTOOL_H__
#define __SPLITTOOL_H__
#include &quot;../cppjieba/include/cppjieba/Jieba.hpp&quot;//需要自己将cppjieba安装在项目目录下
#include &quot;Configuration.h&quot;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
using namespace cppjieba;
class SplitToolJieba
{
public:
    SplitToolJieba(const string&amp; dict_path,const string &amp;model_path,const string &amp;user_dict_path,const string &amp; idfPath, const string &amp;stopWordPath)
    :_jieba(dict_path,model_path,user_dict_path,idfPath,stopWordPath)
    {}
    ~SplitToolJieba(){}
    void Cut(const string &amp; sentence)
    {
        vector&lt;string&gt;tmp;
        _jieba.Cut(sentence,tmp);
        _result.insert(_result.end(),tmp.begin(),tmp.end());
    }
    vector&lt;string&gt; &amp; getResult(){return _result;}
private:
    vector&lt;string&gt; _result;
    cppjieba::Jieba _jieba;
};
#endif
</code></pre>
<p>==main:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    main.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-12 20:38:50
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================


#include &quot;Configuration.h&quot;
#include &quot;SplitTool.h&quot;
using namespace std;
#include &quot;DictProducer.h&quot;
#include &quot;GetIndex.h&quot;
#include &lt;iostream&gt;
#include &lt;memory&gt;
const char * const DICT_PATH =&quot;../cppjieba/dict/jieba.dict.utf8&quot;;
const char * const HMM_PATH =&quot;../cppjieba/dict/hmm_model.utf8&quot;;
const char * const USER_DICT_PATH =&quot;../cppjieba/dict/user.dict.utf8&quot;;
const char * const IDF_PATH =&quot;../cppjieba/dict/idf.utf8&quot;;
const char * const STOP_WORD_PATH =&quot;../cppjieba/dict/stop_words.utf8&quot;;
const string GOLE_DICT_PATH=&quot;../server/data/dict.txt&quot;;
const string GOLE_INDEX_PATH=&quot;../server/data/index.txt&quot;;

class SplitTool;
int main(void)
{
    Configuration *pconfig =Singleton&lt;Configuration&gt;::getInstance(&quot;configure.txt&quot;);
    SplitToolJieba *ptool =new SplitToolJieba(DICT_PATH,HMM_PATH,USER_DICT_PATH,IDF_PATH,STOP_WORD_PATH);
    DictProducer mydictProducer(pconfig-&gt;getEnglishDir(),pconfig-&gt;getChineseDir(),GOLE_DICT_PATH,ptool);
    mydictProducer.build_dict();//建立英语词典
    mydictProducer.build_cn_dict();//建立中文词典
    mydictProducer.store_dict();//储存词典
    GetIndex myindex(GOLE_DICT_PATH,GOLE_INDEX_PATH,&quot;stop_words_zh.txt&quot;);
    myindex.construct_index();//建立索引
    myindex.store_index();//存储索引
    Singleton&lt;Configuration&gt;::destroy();
    return 0;
}
</code></pre>
<hr />
<h6 id="在线部分-1">在线部分：</h6>
<p><img src="file:///C:\Users\dell\AppData\Local\Temp\ksohtml13180\wps2.jpg" alt="img" /></p>
<p>==ConFiguration:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    ConFiguration.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 10:32:43
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __CONFIGURATION_H__
#define __CONFIGURATION_H__
#include &quot;Noncopyable.h&quot;
#include &lt;string&gt;
#include &lt;map&gt;
#define CONFPATH &quot;/home/wtp/spell/server/conf/configure.txt&quot;
using namespace std;

namespace wd
{
    class Configuration
    :public Noncopyable
    {
    public:
        Configuration(const string &amp;filePath);
        ~Configuration()=default;
        string getDictDir() const;
        string getIndexDir() const;
        string getIp()const;
        string getCache() const;
        unsigned short getPort() const;

    private:
        string _filePath;
        map&lt;string,string&gt; _conf;
    };
};

template&lt;typename T&gt;
class Singleton
{
public:
    template&lt;typename ...Args&gt;
    static T *getInstance(Args ...args)
    {
        if(!_pInstance)
            _pInstance=new T(args ...);
        return _pInstance;
    }

    static void destroy()
    {
        if(_pInstance)
            delete _pInstance;
    }
private:
    Singleton();
    ~Singleton();
    static T *_pInstance;
};

template&lt;typename T&gt;
T *Singleton&lt;T&gt;::_pInstance =NULL;
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    ConFiguration.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 15:24:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;ConFiguration.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

wd::Configuration::Configuration(const string &amp; filePath)
:_filePath(std::move(filePath))
{
    ifstream ifs(_filePath);
    if(!ifs){
        cout&lt;&lt;&quot;file open error!&quot;&lt;&lt;endl;
    }
    string key,value;
    while(ifs&gt;&gt;key)
    {
        ifs&gt;&gt;value;
        _conf.insert(std::make_pair(key,value));
    }
    ifs.close();
}

string wd::Configuration::getDictDir() const
{
    auto cit=_conf.find(&quot;mydict&quot;);
    if(cit== _conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}

string wd::Configuration::getIndexDir() const
{
    auto cit =_conf.find(&quot;myindex&quot;);
    if(cit== _conf.end())
        return &quot;&quot;;
    else 
        return cit-&gt;second;
}

string wd::Configuration::getIp() const
{
    auto cit =_conf.find(&quot;myip&quot;);
    if(cit ==_conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}

unsigned short wd::Configuration::getPort() const
{
    auto cit =_conf.find(&quot;myport&quot;);
    if(cit==_conf.end())
        return 0;
    else
        return atoi(cit-&gt;second.c_str());
}

string wd::Configuration::getCache() const
{
    auto cit =_conf.find(&quot;mycache&quot;);
    if(cit ==_conf.end())
        return &quot;&quot;;
    else
        return cit-&gt;second;
}
             
 
</code></pre>
<p>==Acceptor:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Acceptor.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 23:47:05
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef  __WD_ACCEPTOR_H__
#define  __WD_ACCEPTOR_H__

#include &quot;Socket.h&quot;
#include &quot;InetAddress.h&quot;

namespace wd
{
    class Acceptor
    {
    public:
        Acceptor(int listenfd,const InetAddress &amp; addr);
        void ready();//服务器监听准备
        int accept();//服务器接收新连接
        int fd()const {return _listenSock.fd();}
    private:
        void setReuseAddr(bool on);//设置地址重用
        void setReusePort(bool on);//设置端口重用
        void bind();//绑定
        void listen();//监听
        Socket _listenSock;
        InetAddress _addr;
    };
}

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Acceptor.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 23:52:12
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &lt;iostream&gt;
#include &quot;Acceptor.h&quot;
#include &quot;SocketUtil.h&quot;

namespace wd
{
Acceptor::Acceptor(int listenfd,const InetAddress &amp; addr)
:_listenSock(listenfd)
,_addr(addr)
{}

void Acceptor::ready()
{
    setReuseAddr(true);
    setReusePort(true);
    bind();
    listen();
}
int Acceptor::accept()
{
    int peerfd=::accept(_listenSock.fd(),NULL,NULL);
    if(-1==peerfd)
    {
        perror(&quot;accept error!&quot;);
    }
    return peerfd;
}
void Acceptor::setReuseAddr(bool flag)
{
    int on=(flag?1:0);
    if(::setsockopt(_listenSock.fd()
                    ,SOL_SOCKET
                    ,SO_REUSEADDR
                    ,&amp;on
                    ,static_cast&lt;socklen_t&gt;(size_t(on)))==-1)
    {
        perror(&quot;setsockopt reuseaddr error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}

void Acceptor::setReusePort(bool flag)
{
#ifndef SO_REUSEPORT
    int on=(flag?1:0);
    if(::setsockopt(_listenSock.fd()
                    ,SOL_SOCKET
                    ,SO_REUSEADDR
                    ,&amp;on
                    ,static_cast&lt;socklen_t&gt;(size_t(on)))==-1)
    {
        perror(&quot;setsockopt reuseport error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
#else
    if(flag)
    {
        fprintf(stderr,&quot;SO_REUSEPORT is not supported!\n&quot;);
    }
#endif
}

void Acceptor::bind()
{
    if(-1==::bind(_listenSock.fd()
                  ,(const struct sockaddr*)_addr.getSockAddrPtr()
                  ,sizeof(InetAddress)))
    {
        perror(&quot;bind error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}
void Acceptor::listen()
{
    if(-1==::listen(_listenSock.fd(),10))
    {
        perror(&quot;listen error!&quot;);
        ::close(_listenSock.fd());
        exit(EXIT_FAILURE);
    }
}

}
#if 0
int main()
{
    std::cout&lt;&lt;&quot;Acceptor is correct!&quot;&lt;&lt;std::endl;
}
#endif
</code></pre>
<p>==Condition.h:==</p>
<pre class="cpp"><code>#ifndef __WD_CONDITION_H__
#define __WD_CONDITION_H__

#include &quot;Noncopyable.h&quot;
#include &quot;MutexLock.h&quot;
#include &lt;pthread.h&gt;

namespace wd
{
    class Condition
    :Noncopyable
    {
    public:
        Condition(MutexLock &amp;mutex)
        :_mutex(mutex)
        {pthread_cond_init(&amp;_cond,NULL);}
    
        ~Condition()
        {pthread_cond_destroy(&amp;_cond);}
    
        void wait()
        {pthread_cond_wait(&amp;_cond,_mutex.getMutexLockPtr());}
    
        void notify()
        {pthread_cond_signal(&amp;_cond);}
    
        void notifyAll()
        {pthread_cond_broadcast(&amp;_cond);}
    private:
        pthread_cond_t _cond;
        MutexLock &amp; _mutex;
    };
}
#endif
</code></pre>
<p>==Cache:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Cache.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 19:52:40
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __CACHE_H__
#define __CACHE_H__
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;
namespace wd
{
    class Cache
    {
    public:
        void addElement(string,string);//增加缓存信息
        void readFromFile(string);//从文件中读取信息
        void writeToFile(string);//将信息写入文件中
        void update(const Cache&amp;);//更新缓存消息
        bool find(string querry);//从数据库中找寻信息
        string &amp;operator[](string key);
    private:
        unordered_map&lt;string,string&gt;_hashTable;//采用hashTable进行缓存
    };
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Cache.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:01:25
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;Cache.h&quot;
#include &lt;fstream&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

void Cache::addElement(string querry,string result)
{
    _hashTable[querry]=result;
}

void Cache::readFromFile(string filePath)
{
    ifstream ifs(filePath);
    if(!ifs){
        cout&lt;&lt;&quot;Cache::read readFromFile file open error!&quot;&lt;&lt;endl;
        return;
    }
    string querry,result;
    while(ifs&gt;&gt;querry,!ifs.eof())
    {
        ifs&gt;&gt;result;
        _hashTable[querry]=result;
    }
}
#if 0
void Cache::writeToFile(string filePath)
{
    ofstream ofs(filePath);
    if(!ofs){
        cout&lt;&lt;&quot;&quot;&lt;&lt;endl;
        return;
    }
    for(auto &amp;mypair:_hashTable)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;;
        ofs&lt;&lt;mypair.second&lt;&lt;endl;
    }
}

void Cache::update(const Cache &amp; cache)
{   
    for(auto &amp;mypair:cache._hashTable)
    {
        auto cit =_hashTable.find(mypair.first);
        if(cit==_hashTable.end())
        {
            _hashTable.insert(std::move(mypair));
        }
    }
}
#endif

void Cache::writeToFile(string filePath)
{
    ofstream ofs(filePath);
    if(!ofs){
        cout&lt;&lt;&quot;file write error!&quot;&lt;&lt;endl;
        return;
    }
    for(auto &amp;mypair:_hashTable)
    {
        ofs&lt;&lt;mypair.first&lt;&lt;&quot; &quot;;
        ofs&lt;&lt;mypair.second&lt;&lt;endl;
    }
}

void Cache::update(const Cache &amp; cache)
{
    for(auto &amp;mypair:cache._hashTable)
    {
        auto cit =_hashTable.find(mypair.first);
        if(cit==_hashTable.end())
        {
            _hashTable.insert(std::move(mypair));
        }
    }
}

bool Cache::find(string querry)
{
    auto cit =_hashTable.find(querry);
    if(cit==_hashTable.end())
        return false;
    return true;
}

string &amp;Cache::operator[](string key)
{
    return _hashTable[key];
}

#if 0
int main()
{
    cout&lt;&lt;&quot;cache is correct!&quot;&lt;&lt;endl;
}
#endif
</code></pre>
<p>==CacheManger:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    CacheManger.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:51:09
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __CACHEMANGER_H__
#define __CACHEMANGER_H__
#include &quot;Cache.h&quot;
#include &lt;vector&gt;
#define THREADNUM 4//线程数目设置为4个，可自定义

using std::vector;
namespace wd
{
    class CacheManger
    {
    public:
        CacheManger(string filePath);
        void init(string);//创建缓存
        Cache &amp; getCache(size_t);//获取某个缓存
        void periodicUpdate();//定时更新所有缓存
    private:
        string _cacheFilePath;
        vector&lt;Cache&gt;_cacheList;
    };
};

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    CacheManger.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 20:56:50
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;CacheManger.h&quot;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

CacheManger::CacheManger(string cacheFilePath)
{
    init(cacheFilePath);
}
             
void CacheManger::init(string cacheFilePath)
{
    _cacheFilePath=cacheFilePath;
    _cacheList.reserve(THREADNUM);
    Cache tmp;
    tmp.readFromFile(_cacheFilePath);
    for(size_t i=0;i!=THREADNUM;++i)
    {
        _cacheList.push_back(std::move(tmp));
    }
}

Cache &amp; CacheManger::getCache(size_t number)
{
    return _cacheList[number];
}

void CacheManger::periodicUpdate()
{
    auto cit=_cacheList.begin();
    Cache lastWrite=*(cit ++);
    for(;cit&lt;_cacheList.end();++cit)
    {
        lastWrite.update(*cit);
    }
    for(cit=_cacheList.begin()+1;cit!=_cacheList.end();++cit)
    {
        (*cit).update(lastWrite);
    }
    lastWrite.writeToFile(_cacheFilePath);
}
</code></pre>
<p>==EpollPoller:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    EpollPoller.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 11:03:36
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_EPOLLPOLLER_H__
#define __WD_EPOLLPOLLER_H__

#include &quot;TcpConnection.h&quot;
#include &quot;Noncopyable.h&quot;
#include &quot;MutexLock.h&quot;
#include &lt;sys/epoll.h&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;functional&gt;

namespace wd
{
    class Acceptor;
    class EpollPoller
    :Noncopyable
    {
    public:
        typedef TcpConnection::TcpConnectionCallback EpollCallback;
        typedef  std::function&lt;void()&gt; Functor;
        EpollPoller(Acceptor &amp;acceptor);
        ~EpollPoller();
    
        void loop();
        void unloop();
        void runInLoop(const Functor &amp;&amp; cb);
        void doPendingFunctors();
        void wakeup();
    
        void setConnectionCallback(EpollCallback cb);
        void setMessageCallback(EpollCallback cb);
        void setCloseCallback(EpollCallback cb);
    private:
        void waitEpollfd();
        void handleConnection();
        void handleMessage(int peerfd);
        void handleRead();
    
        Acceptor &amp; _acceptor;
        int _epollfd;
        int _eventfd;
        int _listenfd;
        bool _isLooping;
    
        MutexLock _mutex;
        std::vector&lt;Functor&gt; _pendingFunctors;
    
        typedef std::vector&lt;struct epoll_event&gt;Eventlist;
        Eventlist _eventList;
    
        typedef std::map&lt;int,TcpConnectionPtr&gt; ConnectionMap;
        ConnectionMap _connMap;
        EpollCallback _onConnectionCb;
        EpollCallback _onMessageCb;
        EpollCallback _onCloseCb;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    EpollPoller.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 15:42:54
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;EpollPoller.h&quot;
#include &quot;SocketUtil.h&quot;
#include &quot;Acceptor.h&quot;
#include &lt;assert.h&gt;
#include &lt;iostream&gt;
using namespace std;

namespace wd
{
    EpollPoller::EpollPoller(Acceptor &amp; acceptor)
    :_acceptor(acceptor)
    ,_epollfd(createEpollFd())
    ,_eventfd(createEventFd())
    ,_listenfd(_acceptor.fd())
    ,_isLooping(false)
    ,_eventList(1024)
    {
        addEpollFdRead(_epollfd,_listenfd);
        addEpollFdRead(_epollfd,_eventfd);

    }
    
    EpollPoller::~EpollPoller()
    {
        ::close(_epollfd);
    }
    
    void EpollPoller::loop()
    {
        _isLooping=true;
        while(_isLooping)
        {
            waitEpollfd();
        }
    }

    void EpollPoller::unloop()
    {
        if(_isLooping)
            _isLooping=false;
    }

    void EpollPoller::setConnectionCallback(EpollCallback cb)
    {
        _onConnectionCb=cb;
    }
    
    void EpollPoller::setMessageCallback(EpollCallback cb)
    {
        _onMessageCb=cb;
    }
    
    void EpollPoller::setCloseCallback(EpollCallback cb)
    {
        _onCloseCb=cb;
    }
    void EpollPoller::waitEpollfd()
    {
        int nready;
        do
        {
            nready =::epoll_wait(_epollfd,&amp;(*_eventList.begin()),_eventList.size(),10000);
                
        }while(-1==nready &amp;&amp; errno ==EINTR);

        if(-1==nready){
            perror(&quot;epoll wait error!&quot;);
            exit(EXIT_FAILURE);
        }else if(0==nready){
            cout&lt;&lt;&quot;epoll_wait timeout!&quot;&lt;&lt;endl;
        }else{//扩容
            if(nready==static_cast&lt;int&gt;(_eventList.size())){
                _eventList.resize(_eventList.size()*2);
            }

            for(int idx=0;idx!=nready;++idx)//正宗罗老师循环体(TwT)
            {
                if(_eventList[idx].data.fd ==_listenfd)
                {
                    if(_eventList[idx].events &amp; EPOLLIN)
                    {
                        handleConnection();
                    }
                }else if(_eventList[idx].data.fd ==_eventfd){
                    handleRead();
                    cout&lt;&lt;&quot;&gt;&gt;doPendingFunctors()&quot;&lt;&lt;endl;
                    doPendingFunctors();
                }else{
                    if(_eventList[idx].events &amp; EPOLLIN){
                        handleMessage(_eventList[idx].data.fd);
                    }
                }
            }
        }
    }

    void EpollPoller::handleConnection()
    {
        int peerfd=_acceptor.accept();
        addEpollFdRead(_epollfd,peerfd);
        TcpConnectionPtr conn(new TcpConnection(peerfd,this));
        conn-&gt;setConnectionCallback(_onConnectionCb);
        conn-&gt;setMessageCallback(_onMessageCb);
        conn-&gt;setCloseCallback(_onCloseCb);
        std::pair&lt;ConnectionMap::iterator,bool&gt;ret;
        ret=_connMap.insert(std::make_pair(peerfd,conn));
        assert(ret.second ==true);
        (void)ret;
        conn-&gt;handleConnectionCallback();
    }

    void EpollPoller::handleMessage(int peerfd)
    {
        bool isClosed=isConnectionClosed(peerfd);
        ConnectionMap::iterator it =_connMap.find(peerfd);
        assert(it!=_connMap.end());

        if(isClosed)
        {
            it-&gt;second-&gt;handleCloseCallback();
            delEpollReadFd(_epollfd,peerfd);
            _connMap.erase(it);
        }else{
            it-&gt;second-&gt;handleMessageCallback();
        }
    }
    
    void EpollPoller::runInLoop(const Functor &amp;&amp; cb)//在计算线程中执行
    {
        MutexLockGuard mlg(_mutex);
        _pendingFunctors.push_back(std::move(cb));
        wakeup();
    }

    void EpollPoller::doPendingFunctors()
    {
        std::vector&lt;Functor&gt;tmp;
        {
            MutexLockGuard mlg(_mutex);
            tmp.swap(_pendingFunctors);
        }
        for(auto &amp; functor:tmp)
        {
            functor();
        }
    }

    void EpollPoller::handleRead()
    {
        uint64_t howmany;
        int ret=::read(_eventfd,&amp;howmany,sizeof(howmany));
        if(ret !=sizeof(howmany))
        {
            perror(&quot;read error!&quot;);
        }
    }

    void EpollPoller::wakeup()
    {
        uint64_t one =1;
        int ret =::write(_eventfd,&amp;one,sizeof(one));
        if(ret!=sizeof(one))
        {
            perror(&quot;write error!&quot;);
        }
    }
}
 
</code></pre>
<p>==InetAddress:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    InetAddress.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 21:55:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#ifndef __WD_INETADDRESS_H__
#define __WD_INETADDRESS_H__
#include &lt;netinet/in.h&gt;
#include &lt;string&gt;
namespace wd
{
    class InetAddress
    {
    public:
        InetAddress(short port);
        InetAddress(const char *pIp,short port);
        InetAddress(const struct sockaddr_in &amp; addr);
        std::string ip()const;
        unsigned short port() const;
        const struct sockaddr_in *getSockAddrPtr() const;
    private:
        struct sockaddr_in _addr;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    InetAddress.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:55:18
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;InetAddress.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

namespace wd
{
InetAddress::InetAddress(short port)
{
    ::memset(&amp;_addr,0,sizeof(_addr));
    _addr.sin_family=AF_INET;
    _addr.sin_port=htons(port);
    _addr.sin_addr.s_addr=INADDR_ANY;
}

InetAddress::InetAddress(const char * pIp,short port)
{
    ::memset(&amp;_addr,0,sizeof(_addr));
    _addr.sin_family=AF_INET;
    _addr.sin_port=htons(port);
    _addr.sin_addr.s_addr=inet_addr(pIp);
}

InetAddress::InetAddress(const struct sockaddr_in &amp; addr)
:_addr(addr)
{}

const struct sockaddr_in * InetAddress::getSockAddrPtr()const
{
    return &amp; _addr;
}

std::string InetAddress::ip()const
{
    return std::string(inet_ntoa(_addr.sin_addr));
}

unsigned short InetAddress::port() const
{
    return ntohs(_addr.sin_port);
}

}
</code></pre>
<p>==MutexLock:==</p>
<pre class="cpp"><code>#ifndef  __WD_MUTEXLOCK_H__
#define  __WD_MUTEXLOCK_H__

#include &quot;Noncopyable.h&quot;
#include &lt;pthread.h&gt;

namespace wd
{
    class MutexLock
    :Noncopyable
    {
    public:
        MutexLock()
        {pthread_mutex_init(&amp;_mutex,NULL);}
        ~MutexLock()
        {pthread_mutex_destroy(&amp;_mutex);}
        void lock()
        {pthread_mutex_lock(&amp;_mutex);}
        void unlock()
        {pthread_mutex_unlock(&amp;_mutex);}
        pthread_mutex_t *getMutexLockPtr()
        {return &amp;_mutex;}
    private:
        pthread_mutex_t _mutex;
};

class MutexLockGuard//C++之父BS提出的RAII
{
public:
    MutexLockGuard(MutexLock &amp;mutex)
    :_mutex(mutex)
    {
        _mutex.lock();
    }
    ~MutexLockGuard()
    {
        _mutex.unlock();
    }
private:
    MutexLock &amp;_mutex;
};
}
#endif
</code></pre>
<p>==Mydict:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Mydict.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 11:12:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __MYDICT_H__
#define __MYDICT_H__
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;set&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;
namespace wd
{
    struct MyResult
    {
        string _word;
        int _iFreq;//词频
        int _iDist;//最小编辑距离
    };
    
    class Mydict
    {
    public:
        Mydict(const string dictDir,const string indexDir)
        {
            ifstream ifs1(dictDir),ifs2(indexDir);
            if(!ifs1||!ifs2)
                cout&lt;&lt;&quot;Mydict open file error!&quot;&lt;&lt;endl;
            string key;
            int value;
            ifs1&gt;&gt;value;
            _dict.push_back(std::make_pair(string(&quot; &quot;),value));
            ifs1&gt;&gt;value;
            _dict.push_back(std::make_pair(string(&quot; &quot;),value));
            while(ifs1&gt;&gt;key)
            {
                ifs1&gt;&gt;value;
                _dict.push_back(std::make_pair(key,value));
            }
            string line;
            while(std::getline(ifs2,line))
            {
                istringstream iss(line);
                string ikey;
                int ivalue;
                iss&gt;&gt;ikey;
                set&lt;int&gt; tmp;
                while(iss&gt;&gt;ivalue)
                {
                    tmp.insert(ivalue);
                }
                _index.insert(std::make_pair(ikey,tmp));
            }
        }

        vector&lt;pair&lt;string,int&gt;&gt; &amp; getDict(){return _dict;}

        map&lt;string ,set&lt;int&gt;&gt; &amp; getIndexTable(){return _index;}

    private:
        vector&lt;pair&lt;string,int&gt;&gt; _dict;
        map&lt;string,set&lt;int&gt;&gt; _index;
    };
}
#endif
</code></pre>
<p>==MyTask:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    MyTask.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 21:04:54
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __MYTASK_H__
#define __MYTASK_H__
#include &quot;TcpConnection.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;Mydict.h&quot;
#include &quot;Cache.h&quot;
#include &lt;string&gt;
#include &lt;queue&gt;

using namespace std;

class MyCompare
{
public:
    bool operator()(const wd::MyResult &amp; lhs,const wd::MyResult &amp;rhs)
    {
        if(lhs._iDist !=rhs._iDist)
            return lhs._iDist&lt;rhs._iDist;
        else
            return lhs._iFreq&gt;rhs._iFreq;
    }
private:
};

using Character =string;

class MyTask
{
public:
    MyTask(const string &amp;querry,const wd::TcpConnectionPtr conn)
    :_querry(std::move(querry))
    ,_conn(conn)
    {}
    void execute();
private:
    void queryIndexTable();//查询索引（四个索引）
    void statistic(set&lt;int&gt; &amp;iset);//计算
    int distance(const string &amp; rhs);//计算最小编辑距离
    bool response(wd::Cache &amp; cache);//响应客户端的请求
    vector&lt;Character&gt;getOneCharacter(const string &amp;word);//获取字符数组
    string _querry;
    wd::TcpConnectionPtr _conn;
    priority_queue&lt;wd::MyResult,vector&lt;wd::MyResult&gt;,MyCompare&gt; _resultQue;
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    MyTask.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 22:47:19
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;MyTask.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;Mydict.h&quot;
#include &quot;CacheManger.h&quot;
#include &quot;json/json.h&quot;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
extern __thread int t_number;

bool MyTask::response(wd::Cache &amp;cache)
{
    if(cache.find(_querry))
    {
        _conn-&gt;sendInLoop(cache[_querry]);
        return true;
    }
    return false;
}

int MyTask::distance(const string &amp;rhs)
{
    vector&lt;Character&gt;querryCharacter =getOneCharacter(_querry);
    vector&lt;Character&gt;indexCharacter =getOneCharacter(rhs);

    int len1,len2;
    len1=querryCharacter.size();
    len2=indexCharacter.size();
    int edit[len1+1][len2+1];
    int i,j;
    for(i=0;i&lt;=len1;++i){
        for(j=0;j&lt;=len2;++j){
            edit[i][j]=0;
        }
    }
    for(i=0;i&lt;len1;++i){
        edit[i][0]=i;
    }
    for(j=0;j&lt;=len2;++j){
        edit[0][j]=j;
    }
    for(i=1;i&lt;len1;++i){
        for(j=1;j&lt;=len2;++j){
            int cost =((querryCharacter[i-1]==indexCharacter[j-1])?0:1);
            int deletion =edit[i-1][j]+1;
            int insertion=edit[i][j-1]+1;
            int substitution=edit[i-1][j-1]+cost;
            edit[i][j]=std::min(deletion,std::min(insertion,substitution));
        }
    }
    return edit[len1][len2];
}

void MyTask::statistic(set&lt;int&gt; &amp;iset)
{
    vector&lt;pair&lt;string,int&gt;&gt;dict=(Singleton&lt;wd::Mydict&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getDictDir(),
                                                                     Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getIndexDir()))-&gt;getDict();

    for(auto &amp;idx:iset)
    {
        string key=dict[idx].first;
        int iDist =distance(key);
        if(iDist&lt;=3)
        {
            wd::MyResult res;
            res._word=key;
            res._iDist=iDist;
            res._iFreq=dict[idx].second;
            _resultQue.push(res);
        }
    }
}

vector&lt;Character&gt;MyTask::getOneCharacter(const string &amp; word)
{
    auto cit =word.begin();
    vector&lt;Character&gt; ret;
    while(cit&lt;word.end())
    {
        if(224==(*cit &amp;224)){
            Character oneCharacter;
            oneCharacter.append(cit,cit+3);
            ret.push_back(oneCharacter);
            cit =cit+3;
        }else if(240==(*cit &amp;240)){
            Character oneCharacter;
            oneCharacter.append(cit,cit+4);
            ret.push_back(oneCharacter);
            cit =cit+4;
        }else{
            Character oneCharacter(1,*cit);
            ret.push_back(oneCharacter);
            cit ++;
        }
    }
    return ret;
}

void MyTask::queryIndexTable()
{
    map&lt;string,set&lt;int&gt;&gt;index=(Singleton&lt;wd::Mydict&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getDictDir(),
                                                                  Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getIndexDir()))-&gt;getIndexTable();

    vector&lt;Character&gt; oneCharacter=getOneCharacter(_querry);
    set&lt;int&gt;allRally;
    for(auto myCharacter:oneCharacter)
    {
        auto cit =index.find(myCharacter);
        if(cit!=index.end())
        {
            for(auto &amp;idx:cit-&gt;second)
                allRally.insert(idx);
        }
    }
    statistic(allRally);
}

void MyTask::execute()
{
    wd::Cache &amp;mycache =(Singleton&lt;wd::CacheManger&gt;::getInstance(Singleton&lt;wd::Configuration&gt;::getInstance(CONFPATH)-&gt;getCache()))-&gt;getCache(t_number);
    if(response(mycache))
        return;
    else{
        queryIndexTable();
        Json::FastWriter writerinfo;
        Json::Value arrayObj;
        while(!_resultQue.empty())
        {
            Json::Value new_item;
            new_item[&quot;&quot;]=_resultQue.top()._word;
            _resultQue.pop();
            arrayObj.append(new_item);
        }
        string strEmail=writerinfo.write(arrayObj);
        mycache.addElement(_querry,strEmail);
        _conn-&gt;sendInLoop(strEmail);
    }
}
</code></pre>
<p>==Noncopyable:==</p>
<pre class="cpp"><code>#ifndef __WD_NONCOPYABLE_H__
#define __WD_NONCOPYABLE_H__

namespace  wd
{
    class Noncopyable
    {
    protected:
        Noncopyable(){}
        ~Noncopyable(){}
    private:
        Noncopyable(const Noncopyable &amp;);
        Noncopyable &amp; operator=(const Noncopyable &amp;);
    
    };
}
#endif
</code></pre>
<p>==Socket:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Socket.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 21:46:26
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __WD_SOCKET_H__
#define __WD_SOCKET_H__
#include &quot;Noncopyable.h&quot;
namespace wd
{
    class InetAddress;
    class Socket
    :Noncopyable
    {
    public:
        Socket(int socket);
        Socket();
        ~Socket();
    
        void shutdownWrite();
        int fd()const {return _sockfd;}
        void nonblock();
        static InetAddress getLocalAddr(int socketfd);
        static InetAddress getPeerAddr(int sockfd);
    private:
        int _sockfd;
    };
}
#endif
 
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Socket.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:38:20
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;Socket.h&quot;
#include &quot;SocketUtil.h&quot;
#include &quot;InetAddress.h&quot;

namespace wd
{
Socket::Socket(int sockfd)
:_sockfd(sockfd)
{}

Socket::Socket()
:_sockfd(createSocketFd())
{}

Socket::~Socket()
{
    ::close(_sockfd);
}

void Socket::nonblock()
{
    setNonblock(_sockfd);
}

void Socket::shutdownWrite()
{
    if(-1==::shutdown(_sockfd,SHUT_WR)){
        perror(&quot;shutdown write error!&quot;);
    }
}

InetAddress Socket::getLocalAddr(int sockfd)
{
    struct sockaddr_in addr;
    socklen_t len=sizeof(sockaddr_in);
    if(-1==::getsockname(sockfd,(struct sockaddr *)&amp;addr,&amp;len)){
        perror(&quot;getsockname error!&quot;);
    }
    return InetAddress(addr);
}

InetAddress Socket::getPeerAddr(int sockfd)
{
    struct sockaddr_in addr;
    socklen_t len=sizeof(sockaddr_in);
    if(-1==::getpeername(sockfd,(struct sockaddr *)&amp;addr,&amp;len)){
        perror(&quot;getpeername error!&quot;);
    }
    return InetAddress(addr);
    
}

}
</code></pre>
<p>==SocketIO:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SocketIO.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 17:10:23
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __SOCKETIO_H__
#define __SOCKETIO_H__
#include &lt;stdio.h&gt;

namespace wd
{
    class SocketIO
    {
    public:
        SocketIO(int sockfd);
        size_t readn(char *buf,size_t count);
        size_t writen(const char *buf,size_t count);
        size_t readline(char *buf,size_t max_len);
    private:
        size_t recv_peek(char *buf,size_t count);
        int _sockfd;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    SocketIO.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:56:34
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SocketIO.h&quot;
#include &quot;SocketUtil.h&quot;
namespace wd
{
SocketIO::SocketIO(int sockfd)
:_sockfd(sockfd)
{}

size_t SocketIO::readn(char *buf,size_t count)
{
    size_t nleft =count;
    char *pbuf=buf;
    while(nleft&gt;0)
    {
        int nread =::read(_sockfd,pbuf,nleft);
        if(-1==nread)
        {
            if(errno ==EINTR)
                continue;
            return EXIT_FAILURE;
        }else if(0==nread){
            break;
        }
        pbuf =pbuf+nread;
        nleft=nleft-nread;
    }
    return (count -nleft);
}

size_t SocketIO::writen(const char * buf,size_t count)
{
    size_t nleft =count;
    const char *pbuf=buf;
    while(nleft &gt;0)
    {
        int nwrite=::write(_sockfd,pbuf,nleft);
        if(-1==nwrite)
        {
            if(errno ==EINTR)
                continue;
            return EXIT_FAILURE;
        }
        nleft =nleft -nwrite;
        pbuf =pbuf +nwrite;
    }
    return (count -nleft);
}
size_t SocketIO::recv_peek(char *buf,size_t count)
{
    int nread;
    do{
        nread=::recv(_sockfd,buf,count,MSG_PEEK);
    }while(-1==nread &amp;&amp; errno ==EINTR);
    return nread;
}

size_t SocketIO::readline(char *buf,size_t maxlen)
{
    size_t nleft =maxlen-1;
    char *pbuf=buf;
    size_t total=0;
    while(nleft&gt;0)
    {
        size_t nread =recv_peek(pbuf,nleft);
        if(nread&lt;=0)
            return nread;

        for(size_t idx =0;idx!=nread;++idx){//检查换行符/n
            if(pbuf[idx]==&#39;\n&#39;){
                size_t nsize =idx +1;
                if(readn(pbuf,nsize)!=nsize)
                    return EXIT_FAILURE;
                pbuf +=nsize;
                total +=nsize;
                *pbuf=0;
                return total;
            }
        }
        if(readn(pbuf,nread)!=nread)
            return EXIT_FAILURE;
        pbuf +=nread;
        nleft -=nread;
        total +=nread;
    }
    *pbuf=0;
    return maxlen-1;
}

}
</code></pre>
<p>==SockUtil(根据陈硕编写的LINUX书上分开头文件)==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SocktUtil.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-05 22:01:30
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_SOCKERUTIL_H__
#define __WD_SOCKERUTIL_H__
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/eventfd.h&gt;
#include &lt;sys/epoll.h&gt;
namespace wd
{
    inline int createSocketFd()
    {
        int fd=::socket(AF_INET,SOCK_STREAM,0);
        if(-1==fd)
        {
            perror(&quot;socket create error!&quot;);
        }
        return fd;
    }
    
    inline void setNonblock(int fd)
    {
        int flags=::fcntl(fd,F_GETFL,0);
        flags |= O_NONBLOCK;
        ::fcntl(fd,F_SETFL,flags);
    }
    
    inline int createEpollFd()
    {
        int efd=::epoll_create1(0);
        if(-1==efd)
        {
            perror(&quot;epoll create1 error!&quot;);
            exit(EXIT_FAILURE);
        }
        return efd;
    }
    
    inline int createEventFd()
    {
        int evtfd=::eventfd(0,EFD_NONBLOCK|EFD_CLOEXEC);
        if(-1==evtfd)
        {
            perror(&quot;eventfd create error!&quot;);
        }
        return evtfd;
    }
    inline void addEpollFdRead(int efd,int fd)
    {
        struct epoll_event ev;
        ev.data.fd=fd;
        ev.events=EPOLLIN;
        int ret=epoll_ctl(efd,EPOLL_CTL_ADD,fd,&amp;ev);
        if(-1==ret)
        {
            perror(&quot;epoll ctl add error!&quot;);
            exit(EXIT_FAILURE);
        }
    }
    inline void delEpollReadFd(int efd,int fd)
    {
        struct epoll_event ev;
        ev.data.fd=fd;
        int ret=epoll_ctl(efd,EPOLL_CTL_DEL,fd,&amp;ev);
        if(-1==ret)
        {
            perror(&quot;epoll ctl delete error!&quot;);
            exit(EXIT_FAILURE);
        }
    }
    
    inline size_t recvPeek(int sockfd,void *buf,size_t len)
    {
        int nread;
        do{
            nread=::recv(sockfd,buf,len,MSG_PEEK);
        }while(nread==-1 &amp;&amp; errno ==EINTR);
        return nread;
    }
    
    inline bool isConnectionClosed(int sockfd)
    {
        char buf[1024];
        int nread=recvPeek(sockfd,buf,sizeof(buf));
        if(-1==nread)
        {
            perror(&quot;recvPeek error!&quot;);
            return true;
        }
        return (0==nread);
    }
}
#endif
</code></pre>
<p>==SpellCorrrectSever:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    SpellCorrectServer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:41:13
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __SPELLCORRECTSERVER_H__
#define __SPELLCORRECTSERVER_H__
#include &quot;TcpServer.h&quot;
#include &quot;Threadpool.h&quot;

using namespace wd;
namespace wd
{
    class SpellCorrectServer
    {
    public:
        SpellCorrectServer(const string &amp; ip
                           ,unsigned short port
                           ,size_t threadNUM
                           ,size_t queSize);
        void start();
    private:
        void onConnection(const TcpConnectionPtr &amp;);
        void onMessage(const TcpConnectionPtr &amp;);
        void onClose(const TcpConnectionPtr &amp;);
        TcpServer _tcpserver;
        Threadpool _threadpoll;
    };
};
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    SpellCorrectServer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:20:41
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SpellCorrectServer.h&quot;
#include &quot;MyTask.h&quot;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;functional&gt;
using namespace std;

void SpellCorrectServer::onConnection(const wd::TcpConnectionPtr &amp; conn)
{
    cout&lt;&lt;conn-&gt;toString()&lt;&lt;endl;
    conn-&gt;send(&quot;hello ,welcome to WTP Chat Server.\r\n&quot;);
}

void SpellCorrectServer::onMessage(const wd::TcpConnectionPtr &amp; conn)
{
    string s(conn-&gt;receive());
    MyTask task(s,conn);
    _threadpoll.addTask(std::bind(&amp;MyTask::execute,&amp;task));
    cout&lt;&lt;&quot;&gt;add task to threadpool&quot;&lt;&lt;endl;
}

void SpellCorrectServer::onClose(const wd::TcpConnectionPtr &amp;conn)
{
    ::printf(&quot;%s close\n&quot;,conn-&gt;toString().c_str());
}

SpellCorrectServer::SpellCorrectServer(const string &amp; ip
                                       ,unsigned short port
                                       ,size_t threadNUM
                                       ,size_t queSize)
:_tcpserver(ip,port)
,_threadpoll(threadNUM,queSize)
{}

void SpellCorrectServer::start()
{
    _threadpoll.start();
    _tcpserver.setConnectionCallback(std::bind(&amp;SpellCorrectServer::onConnection,this,std::placeholders::_1));
    _tcpserver.setMessageCallback(std::bind(&amp;SpellCorrectServer::onMessage,this,std::placeholders::_1));
    _tcpserver.setCloseCallback(std::bind(&amp;SpellCorrectServer::onClose,this,std::placeholders::_1));
    _tcpserver.start();
}
</code></pre>
<p>==TaskQue:==</p>
<pre class="cpp"><code>#ifndef __WD_TASKQUEUE_H__
#define __WD_TASKQUEUE_H__

#include &quot;MutexLock.h&quot;
#include &quot;Condition.h&quot;
#include &lt;queue&gt;
#include &lt;functional&gt;

namespace wd
{
    typedef std::function&lt;void()&gt;Task;
    
    class TaskQueue
    {
    public:
        TaskQueue(size_t queSize)
        :_queSize(queSize)
        ,_mutex()
        ,_notFull(_mutex)
        ,_notEmpty(_mutex)
        ,_flag(true)
        {}
    
        void push(Task &amp;&amp;task);
        Task pop();
        bool empty()const
        {
            return _que.size()==0;
        }
        bool full()const
        {return _que.size()==_queSize;}
        void wakeup()
        {   
            if(_flag)
                _flag=false;
            _notEmpty.notifyAll();
        }
    private:
        size_t _queSize;
        std::queue&lt;Task&gt; _que;
        MutexLock _mutex;
        Condition _notFull;
        Condition _notEmpty;
        bool _flag;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;TaskQueue.h&quot;

using namespace wd;
//生产者所在的线程
void TaskQueue::push(Task &amp;&amp; task)
{
    MutexLockGuard autoLock(_mutex);
    while(full())
    {
        _notFull.wait();
    }
    _que.push(std::move(task));
    _notEmpty.notify();
}

//消费者所在线程
Task TaskQueue::pop()
{
    MutexLockGuard autoLock(_mutex);
    while(_flag &amp;&amp; empty())
    {
        _notEmpty.wait();
    }
    if(_flag){
        Task task=_que.front();
        _que.pop();
        _notFull.notify();
        return task;
    }else{
        return NULL;
    }
}
#if 0
Task TaskQueue::pop()
{
    MutexLockGuard autoLock(_mutex);
    while(_flag &amp;&amp; empty())
    {
        _notEmpty.wait();
    }
    if(_flag){
        Task task =_que.front();
        _que.pop();
        _notFull.notify();
        return task;
    }else{
        return NULL;
    }
}
#endif
</code></pre>
<p>==TcpConnection:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpConnection.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 17:15:33
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_TCPCONNECTION_H__
#define __WD_TCPCONNECTION_H__

#include &quot;Noncopyable.h&quot;
#include &quot;InetAddress.h&quot;
#include &quot;Socket.h&quot;
#include &quot;SocketIO.h&quot;

#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;
namespace wd
{
    class EpollPoller;
    class TcpConnection;
    typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;

    class TcpConnection
    :Noncopyable
    ,public std::enable_shared_from_this&lt;TcpConnection&gt;
    {
    public:
        typedef std::function&lt;void(const TcpConnectionPtr &amp;)&gt;TcpConnectionCallback;
        TcpConnection(int sockfd,EpollPoller *loop);
        ~TcpConnection();

        std::string receive();
        void send(const std::string &amp;msg);
        void sendInLoop(const std::string &amp;msg);
        void shutdown();

        std::string toString();
        void setConnectionCallback(TcpConnectionCallback cb);
        void setMessageCallback(TcpConnectionCallback cb);
        void setCloseCallback(TcpConnectionCallback cb);

        void handleConnectionCallback();
        void handleMessageCallback();
        void handleCloseCallback();
    private:
        Socket _sockfd;
        SocketIO _sockIO;
        const InetAddress _localAddr;
        const InetAddress _peerAddr;
        bool _isShutdownWrite;
        EpollPoller * _loop;
        TcpConnectionCallback _onConnectionCb;
        TcpConnectionCallback _onMessageCb;
        TcpConnectionCallback _onCloseCb;

    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpConnection.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 22:22:22
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;TcpConnection.h&quot;
#include &quot;EpollPoller.h&quot;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

namespace wd
{
TcpConnection::TcpConnection(int sockfd,EpollPoller * loop)
:_sockfd(sockfd)
,_sockIO(sockfd)
,_localAddr(wd::Socket::getLocalAddr(sockfd))
,_peerAddr(wd::Socket::getPeerAddr(sockfd))
,_isShutdownWrite(false)
,_loop(loop)
{_sockfd.nonblock();}

TcpConnection::~TcpConnection()
{
    if(!_isShutdownWrite)
    {
        _isShutdownWrite=true;
        shutdown();
    }
    printf(&quot;~TcpConnection()\n&quot;);
}

std::string TcpConnection::receive()
{
    char buf[65536];
    memset(buf,0,sizeof(buf));
    size_t ret =_sockIO.readline(buf,sizeof(buf));
    if(0==ret){
        return std::string();
    }else{
        return std::string(buf);
    }
}

void TcpConnection::send(const std::string &amp;msg)
{
    size_t len=msg.size();
    _sockIO.writen((const char *)&amp;len,sizeof(int));
    _sockIO.writen(msg.c_str(),len);
}

void TcpConnection::shutdown()
{
    if(!_isShutdownWrite)
        _sockfd.shutdownWrite();
    _isShutdownWrite=true;
}

std::string TcpConnection::toString()
{
    char str[100];
    snprintf(str,sizeof(str),&quot;%s:%d-&gt;%s:%d&quot;
             ,_localAddr.ip().c_str()
             ,_localAddr.port()
             ,_peerAddr.ip().c_str()
             ,_peerAddr.port());
    return std::string(str);
}

void TcpConnection::setConnectionCallback(TcpConnectionCallback cb)
{
    _onConnectionCb =cb;
}
void TcpConnection::setMessageCallback(TcpConnectionCallback cb)
{
    _onMessageCb =cb;
}
void TcpConnection::setCloseCallback(TcpConnectionCallback cb)
{
    _onCloseCb =cb;
}

void TcpConnection::handleConnectionCallback()
{
    if(_onConnectionCb){
        _onConnectionCb(shared_from_this());
    }
}
void TcpConnection::handleMessageCallback()
{
    if(_onMessageCb){
        _onMessageCb(shared_from_this());
    }
}
void TcpConnection::handleCloseCallback()
{
    if(_onCloseCb){
        _onCloseCb(shared_from_this());
    }
}

void TcpConnection::sendInLoop(const std::string &amp; msg)
{
    _loop-&gt;runInLoop(std::bind(&amp;TcpConnection::send,this,msg));
}

}
</code></pre>
<p>==TcpServer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpServer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:15:21
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
 
#ifndef __WD_TCPSERVER_H__
#define __WD_TCPSERVER_H__

#include &quot;Acceptor.h&quot;
#include &quot;EpollPoller.h&quot;
#include &lt;string&gt;

using std::string;
namespace wd
{
    class TcpServer
    {
    public:
        typedef EpollPoller::EpollCallback TcpServerCallback;
        TcpServer(const string &amp; ip,unsigned short port);
        TcpServer(unsigned short port);

        void start();
        void stop();
        void setConnectionCallback(TcpServerCallback cb);
        void setMessageCallback(TcpServerCallback cb);
        void setCloseCallback(TcpServerCallback cb);

    private:
        Acceptor _acceptor;
        EpollPoller _poller;

        TcpServerCallback _connectionCallback;
        TcpServerCallback _messageCallback;
        TcpServerCallback _closeCallback;
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TcpServer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 19:59:37
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;TcpServer.h&quot;
#include &quot;InetAddress.h&quot;
#include &quot;SocketUtil.h&quot;
#include &lt;iostream&gt;
using namespace std;
namespace wd
{
    TcpServer::TcpServer(const string &amp; ip,unsigned short port)
    :_acceptor(createSocketFd(),InetAddress(ip.c_str(),port))
    ,_poller(_acceptor)
    {}

    void TcpServer::start()
    {
        _acceptor.ready();
        _poller.setConnectionCallback(_connectionCallback);
        _poller.setMessageCallback(_messageCallback);
        _poller.setCloseCallback(_closeCallback);
        _poller.loop();
    }

    void TcpServer::stop()
    {
        _poller.unloop();
    }

    void TcpServer::setConnectionCallback(TcpServerCallback cb)
    {_connectionCallback=cb;}

    void TcpServer::setMessageCallback(TcpServerCallback cb)
    {_messageCallback=cb;}

    void TcpServer::setCloseCallback(TcpServerCallback cb)
    {_closeCallback=cb;}
}
</code></pre>
<p>==Thread:==</p>
<pre class="cpp"><code>#ifndef  __WD_THREAD_H__
#define  __WD_THREAD_H__

#include &quot;Noncopyable.h&quot;
#include &lt;pthread.h&gt;
#include &lt;functional&gt;
using std::function;
namespace wd
{
    class Thread;
    struct ThreadPtr
    {
        int _number;
        Thread *_pthread;
    };
    class Thread
    :Noncopyable
    {
        using ThreadCallback =function&lt;void()&gt;;
    public:
        Thread(ThreadCallback &amp;&amp;cb);
        ~Thread();
    
        void start(int number);
        void join();
    
        bool isRunning()const {return _isRunning;}
    
    private:
        static void * threadFunc(void *);
        pthread_t _pthid;
        bool _isRunning;
        ThreadCallback _cb;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;Thread.h&quot;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

__thread int t_number;//将线程编号作为线程存储的标记

Thread::Thread(ThreadCallback &amp;&amp; cb)//这里的右值引用本身取决于是否有名字
:_pthid(0)
,_isRunning(false)
,_cb(std::move(cb))
{
    cout&lt;&lt;&quot;Thread(cb)&quot;&lt;&lt;endl;
}

void Thread::start(int number)
{
    ThreadPtr *threadPtr=new ThreadPtr();
    threadPtr-&gt;_number=number;
    threadPtr-&gt;_pthread=this;
    pthread_create(&amp;_pthid,NULL,threadFunc,threadPtr);
    _isRunning=true;
}

void *Thread::threadFunc(void *arg)
{//应用了线程存储
    ThreadPtr *threadPtr=static_cast&lt;ThreadPtr*&gt;(arg);
    Thread * pthread=threadPtr-&gt;_pthread;
    t_number=threadPtr-&gt;_number;
    if(pthread)
        pthread-&gt;_cb();//线程开始工作！
    delete threadPtr;
    //Thread * pthread =threadPtr-&gt;_pthread;
    return NULL;
}
#if 0
void *Thread::threadFunc(void *arg)
{
    ThreadPtr *threadPtr =static_cast&lt;ThreadPtr*&gt;(arg);
    Thread * pthread =threadPtr-&gt;_pthread;
    t_number =threadPtr-&gt;_number;
    if(pthread)
        pthread-&gt;_cb();
    delete threadPtr;
    return NULL;
}
#endif
void Thread::join()
{
    pthread_join(_pthid,NULL);
    _isRunning=false;
}

Thread::~Thread()
{
    if(_isRunning)
    {
        pthread_detach(_pthid);
        _isRunning=false;
    }
    cout&lt;&lt;&quot;~Thread()&quot;&lt;&lt;endl;
}
</code></pre>
<p>==Threadpool:==</p>
<pre class="cpp"><code>#ifndef __WD_THREADPOLL_H__
#define __WD_THREADPOLL_H__
#include &quot;TaskQueue.h&quot;
#include &quot;Thread.h&quot;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;
using std::shared_ptr;
using std::vector;
namespace  wd
{
    class Threadpool
    {
    public:
        using Task=std::function&lt;void()&gt;;
    
        Threadpool(size_t threadNum,size_t queSize)
        :_threadNum(threadNum)
        ,_queSize(queSize)
        ,_taskQue(_queSize)
        ,_isExit(false)
        {
            _threads.reserve(_threadNum);
        }
        
        ~Threadpool();
    
        void start();
        void stop();
        void addTask(Task &amp;&amp; task);
    
    private:
        void threadFunc();
        Task getTask();
        size_t _threadNum;
        size_t _queSize;
        vector&lt;shared_ptr&lt;Thread&gt;&gt; _threads;
        TaskQueue _taskQue;
        bool _isExit;
    };
}
#endif
</code></pre>
<pre class="cpp"><code>#include &quot;Threadpool.h&quot;
#include &quot;Thread.h&quot;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace wd;

void Threadpool::start()
{
    for(size_t idx=0;idx&lt;_threadNum;++idx)
    {
        shared_ptr&lt;Thread&gt;pThread(new Thread(std::bind(&amp;Threadpool::threadFunc,this)));
        _threads.push_back(std::move(pThread));
    }
    int number=0;
    for(auto &amp;pThread:_threads)
    {
        pThread-&gt;start(number);
        ++number;
    }
}
void Threadpool::stop()//为了线程安全，将stop方法置于主线程中
{
    if(!_isExit)
    {
        while(!_taskQue.empty()){
            ::sleep(1);
            cout&lt;&lt;&quot;Threadpool sleep 1 second!&quot;&lt;&lt;endl;
        }
        _isExit=true;
        cout&lt;&lt;&quot;Threadpool -&gt;stop:_isExit=&quot;&lt;&lt;_isExit&lt;&lt;endl;
        _taskQue.wakeup();
        for(auto &amp;pthread:_threads){
            pthread-&gt;join();
        }
    }
}

Threadpool::~Threadpool()
{
    if(!_isExit){
        stop();
    }
}
void Threadpool::addTask(Task &amp;&amp; task)
{
    _taskQue.push(std::move(task));
}

Task Threadpool::getTask()
{
    return _taskQue.pop();
}

void Threadpool::threadFunc()
{
    while(!_isExit)
    {
        Task task=getTask();
        if(task){
            task();
        }
    }
}
</code></pre>
<p>==Timer:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    Timer.h
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-06 20:00:45
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#ifndef __WD_TIMER_H__
#define __WD_TIMER_H__
#include &lt;functional&gt;

namespace wd
{
    class Timer
    {
    public:
        using TimerCallback =std::function&lt;void()&gt;;
        Timer(int initailTime,int intervalTime,TimerCallback &amp;&amp; cb);
        ~Timer();
        void start();
        void stop();
    private:
        int _fd;
        int _initialTime;
        int _intervalTime;
        TimerCallback _cb;
        bool _isStarted;
        int createTimerFd();
        void setTimerfd(int initialTime, int intervalTime);
        void handleRead();  
    };
}
#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    Timer.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:09:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;Timer.h&quot;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/timerfd.h&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace wd;

Timer::Timer(int initialTime,int intervalTime,TimerCallback &amp;&amp; cb)
:_fd(createTimerFd())
,_initialTime(initialTime)
,_intervalTime(intervalTime)
,_cb(std::move(cb))
,_isStarted(false)
{}

void Timer::start()
{
    struct pollfd pfd;
    pfd.fd=_fd;
    pfd.events=POLLIN;
    setTimerfd(_initialTime,_intervalTime);//开启定时器
    _isStarted=true;
    while(_isStarted){
        int nready=::poll(&amp;pfd,1,5000);
        if(-1==nready &amp;&amp;errno ==EINTR){
            continue;
        }else if(-1==nready){
            perror(&quot;&gt;&gt;&gt;poll error!&quot;);
            exit(EXIT_FAILURE);
        }else if(0==nready){
            cout&lt;&lt;&quot;&gt;&gt;&gt;poll timeout!&quot;&lt;&lt;endl;
        }else{
            if(pfd.revents &amp; POLLIN){
                handleRead();//先对定时器进行处理
                if(_cb){
                    _cb();//再去执行回调任务
                }
            }
        }
    }
}

void Timer::stop()
{
    setTimerfd(0,0);
    if(_isStarted){
        _isStarted=false;
    }
}

Timer::~Timer()
{
    if(_isStarted){
        stop();
    }
}

int Timer::createTimerFd()
{
    int fd=::timerfd_create(CLOCK_REALTIME,0);
    if(-1==fd){
        perror(&quot;&gt;&gt;timerfd_create error!&quot;);
    }
    return fd;
}

void Timer::setTimerfd(int initialTime,int intervalTime)
{
    struct itimerspec value;
    value.it_value.tv_sec=initialTime;
    value.it_value.tv_nsec=0;
    value.it_interval.tv_sec=intervalTime;
    value.it_interval.tv_nsec=0;
    int ret=::timerfd_settime(_fd,0,&amp;value,NULL);
    if(-1==ret){
        perror(&quot;&gt;&gt;&gt;timerfd_settime error!&quot;);
    }
}
#if 0
void Timer::handleRead()
{
    uint64_t howmany;
    int ret =::read(_fd,&amp;howmany,sizeof(uint64_t));
    if(ret!=sizeof(uint64_t)){
        perror(&quot;read!&quot;);
    }
}
#endif


void Timer::handleRead()
{
    uint64_t howmany;//为一个64位
    int ret=::read(_fd,&amp;howmany,sizeof(uint64_t));
    if(ret!=sizeof(uint64_t)){
        perror(&quot;&gt;&gt;&gt;read error!&quot;);
    }
}
</code></pre>
<p>==TimerThread:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    TimerThread.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 17:12:51
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#ifndef __WD_TIMERTHREAD_H__
#define __WD_TIMERTHREAD_H__

#include &quot;Timer.h&quot;
#include &quot;Thread.h&quot;

#include &lt;functional&gt;

namespace wd
{
    
class TimerThread
{
public:
    using TimerCallback = std::function&lt;void()&gt;;
    TimerThread(int, int, TimerCallback &amp;&amp; cb);
    ~TimerThread();

    void start();
    void stop();


private:
    Timer _timer;
    Thread _subThread;
    bool _isStarted;
};
}//end of namespace wd

#endif
</code></pre>
<pre class="cpp"><code> ///=======================================
 /// File:    TimerThread.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 20:09:14
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================
#include &quot;TimerThread.h&quot;


using namespace wd;

TimerThread::TimerThread(int initialTime, int intervalTime, TimerCallback &amp;&amp; cb)
: _timer(initialTime, intervalTime, std::move(cb))
, _subThread(std::bind(&amp;Timer::start, &amp;_timer))
, _isStarted(false)
{}

void TimerThread::start()
{
    _subThread.start(0);
    _isStarted = true;
}

void TimerThread::stop()
{
    if(_isStarted) {
        _timer.stop();
        _subThread.join();
        _isStarted = false;
    }
}

TimerThread::~TimerThread()
{
    if(_isStarted)
        stop();
}
</code></pre>
<p>==main:==</p>
<pre class="cpp"><code> ///=======================================
 /// File:    main.cc
 /// Author:  wtptorres(1584292712@qq.com)
 /// Date:    2019-06-07 21:09:32
 /// Dream:   Don&#39;t forget your dreams!
 /// ======================================

#include &quot;SpellCorrectServer.h&quot;
#include &quot;ConFiguration.h&quot;
#include &quot;CacheManger.h&quot;
#include &quot;TimerThread.h&quot;
#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;
using namespace wd;

int main()
{
    wd::CacheManger *mycacheManger=Singleton&lt;CacheManger&gt;::getInstance(Singleton&lt;Configuration&gt;
                                                         ::getInstance(CONFPATH)-&gt;getCache());
    TimerThread timer(5,600,std::bind(&amp;CacheManger::periodicUpdate,mycacheManger));
    timer.start();
    SpellCorrectServer myspell(Singleton&lt;Configuration&gt;::getInstance(CONFPATH)-&gt;getIp()
                               ,Singleton&lt;Configuration&gt;::getInstance(CONFPATH)-&gt;getPort()
                               ,4
                               ,10);
    myspell.start();
    return 0;
}
</code></pre>
<hr />
<p><strong>小结：（1）已经实现项目需求，中文和英文单词都能查询，经过测试，运行稳定，能输出不少候选词</strong></p>
<p>​ <strong>（2）仍然存在少量bug,例如偶尔会发生段错误</strong></p>
<p>​ <strong>（3）由于时间问题，json读出的数据key-value的key值没有打印，用户界面还未来得及优化</strong></p>
<p>​ <strong>（4）陈硕的《linux多线程服务端编程》使用linux接口（timerfd）,没用posix接口（eventfd）</strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>