<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修矩阵乘法（二）：利用矩阵快速幂运算完成递推' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>矩阵乘法（二）：利用矩阵快速幂运算完成递推</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11446629.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 矩阵乘法，特别是矩阵快速幂运算在实际中的应用非常广泛。例如，利用矩阵乘法可以方便快速地求解线性递推关系。</p>
<p>&nbsp; &nbsp; &nbsp; 例如，我们知道斐波拉契数列具有如下线性递推关系：</p>
<p>&nbsp; &nbsp; &nbsp; F(0)=0&nbsp; F(1)=1&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; F(n)= F(n-1) + F(n-2)&nbsp; &nbsp; (n&gt;=2)</p>
<p>&nbsp; &nbsp; &nbsp; 构造一个矩阵，可以利用矩阵乘法完成递推。如下所示。</p>
<p><img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推0.png" alt="" width="562" height="202" /></p>
<p><span style="font-size: 18px;"><strong>&nbsp;【例1】斐波拉契数列第n项。</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; 输入整数n (0 &le;&nbsp;<em>n</em>&nbsp;&le; 1,000,000,000)，求斐波拉契数列第n项的值。由于F(n)值很大，要求只输出其模10000的结果。</p>
<p>&nbsp; &nbsp; &nbsp; 例如，输入&nbsp;9 ，输出 34 ； 输入&nbsp;999999999 ，输出 626 ；</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;输入&nbsp;1000000000，输出&nbsp;&nbsp;6875。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 利用矩阵的快速幂运算完成F(n)的计算。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序1。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MODNUM 10000<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; __int64 mat[3][3];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (i = 1; i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=1 ;j&lt;=n ; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (k = 1 ;k&lt;=n ;k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][j]=(c.mat[i][j]+a.mat[i][k] * b.mat[k][j]) % MODNUM;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n ;<br />&nbsp; &nbsp; &nbsp; Matrix p ;<br />&nbsp; &nbsp; &nbsp; while(scanf("%d", &amp;n) &amp;&amp; n != -1)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n==0 )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("0\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][1]=1;  p.mat[1][2]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[2][1]=1;  p.mat[2][2]=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = quickMatPow(p,2,n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n", p.mat[2][1]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 源程序1直接采用本博客上一篇文章中的快速幂运算函数实现的。由于本题中构造矩阵为2*2，因此可以编写一个简洁的程序。</p>
<p style="margin-left: 30px;">（3）源程序2。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />struct matrix {<br />&nbsp; &nbsp; &nbsp; __int64 s11 , s12 , s21 , s22 ;<br />};<br />matrix f(matrix a,matrix b)<br />{<br />&nbsp; &nbsp; &nbsp; matrix p ;<br />&nbsp; &nbsp; &nbsp; p.s11 = (a.s11*b.s11 + a.s12*b.s21)%10000;<br />&nbsp; &nbsp; &nbsp; p.s12 = (a.s11*b.s12 + a.s12*b.s22)%10000;<br />&nbsp; &nbsp; &nbsp; p.s21 = (a.s21*b.s11 + a.s22*b.s21)%10000;<br />&nbsp; &nbsp; &nbsp; p.s22 = (a.s21*b.s12 + a.s22*b.s22)%10000;<br />&nbsp; &nbsp; &nbsp; return p ;<br />}<br />matrix quickpow(matrix p,int n)&nbsp; &nbsp; // 采用递归的方法实现矩阵快速幂运算<br />{<br />&nbsp; &nbsp; &nbsp; matrix q ;<br />&nbsp; &nbsp; &nbsp; q.s11 = q.s22 = 1 ;&nbsp; &nbsp; &nbsp;// 初始化为单位矩阵<br />&nbsp; &nbsp; &nbsp; q.s12 = q.s21 = 0 ;<br />&nbsp; &nbsp; &nbsp; if (n == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return q ;<br />&nbsp; &nbsp; &nbsp; q = quickpow(p,n/2);<br />&nbsp; &nbsp; &nbsp; q = f(q,q);<br />&nbsp; &nbsp; &nbsp; if (n%2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q = f(q,p);<br />&nbsp; &nbsp; &nbsp; return q ;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n ;<br />&nbsp; &nbsp; &nbsp; matrix p ;<br />&nbsp; &nbsp; &nbsp; while(scanf("%d", &amp;n) &amp;&amp; n != -1)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.s11 = p.s12 = p.s21 = 1 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.s22 = 0 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = quickpow(p,n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n", p.s12);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">上面两个源程序提交给POJ 3070 &ldquo;Fibonacci&rdquo;，均可以Accepted。</p>
<p><strong><span style="font-size: 16px;">&nbsp;【例2】矩阵加速（数列）。</span></strong> &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 已知a数列的定义为：&nbsp; a[1]=a[2]=a[3]=1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[x]=a[x-3]+a[x-1] (x&gt;3)</p>
<p>&nbsp; &nbsp; &nbsp; 求a数列的第n项对1000000007（10^9+7）取余的值。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 因为&nbsp; &nbsp;<img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推1.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; 所以，构造P矩阵为：p.mat[4][4]={{0,0,0},{1,0,1},{1,0,0},{0,1,0}};然后采用矩阵快速幂运算即可。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MODNUM 1000000007<br />struct Matrix<br />{<br />&nbsp; &nbsp; __int64 mat[4][4];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp;Matrix c;<br />&nbsp; &nbsp; &nbsp;memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp;int i,j,k;<br />&nbsp; &nbsp; &nbsp;for (i = 1; i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; for (j=1 ;j&lt;=n ; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (k = 1 ;k&lt;=n ;k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j]=(c.mat[i][j]+a.mat[i][k] * b.mat[k][j]) % MODNUM;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int t,n;<br />&nbsp; &nbsp; &nbsp; Matrix p ;<br />&nbsp; &nbsp; &nbsp; scanf("%d",&amp;t);<br />&nbsp; &nbsp; &nbsp; while (t--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (n&lt;4)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("1\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[1][1]=1;  p.mat[1][2]=0; p.mat[1][3]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[2][1]=1;  p.mat[2][2]=0; p.mat[2][3]=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[3][1]=0;  p.mat[3][2]=1; p.mat[3][3]=0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = quickMatPow(p,3,n-3);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%lld\n",(p.mat[1][1]+p.mat[1][2]+p.mat[1][3])%MODNUM);</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p><span style="font-size: 16px;"><strong>【例3】Firepersons （POJ 2118）。</strong></span></p>
<p>Description</p>
<p>The Association for Courtly Manners, an international organization for standardization of social interactions (Better known under the name Absurdly Clumsy Moralists, but let's not take prejudice.) has decided to create a new international standard defining ranks of firepersons (Formerly firemen, but the international standards of course must be politically correct.) - each fireperson receives an integer number describing his rank and when they arrive to a fire, they must enter the fire ground in order of increasing ranks and the low ranked firepersons must keep the fire burning long enough for the high ranked firepersons to enjoy extinguishing sufficiently. </p>
<p>The ranks are assigned according to an Arbitrary Constant Multiplier Sequence. An ACM-sequence of order k is an integer sequence defined by its first k terms a0, a1,...ak-1 and a recurrence relation an=&Sigma;1&lt;=i&lt;=kan-ibi mod 10 000 for n &gt;= k, where the bi's are integer constants. The i-th oldest fireperson then gets rank ai. </p>
<p>Your task is to calculate the rank of the i-th fireperson, given parameters of the ACM-sequence and the number i. <br />Input</p>
<p>The input consists of several instances. Each instance is described on a single line containing the following integers separated by a single space: k, a0, , ak-1, b1, , bk, i. Here 1 &lt;= k &lt;= 100 is the order of the sequence, 0 &lt;= ai &lt; 10 000 are the first k elements of the sequence, 0 &lt;= bi &lt; 10 000 are the multipliers and 0 &lt;= i &lt; 1 000 000 000 is the number of the element we ask for. </p>
<p>The input ends with a line containing a number 0. <br />Output</p>
<p>The output consists of several lines corresponding to the instances on the input. The l-th line contains a single integer ai which is the i-th element of the sequence described by the l-th input instance.<br />Sample Input</p>
<p>2 0 1 1 1 6</p>
<p>0</p>
<p>Sample Output<br />8</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 本题的意思是： 设有递推式a(n)=&Sigma;a(n-i)*b(i) mod 10000 （1&lt;=i&lt;=k），求a(i)。</p>
<p>&nbsp; &nbsp; &nbsp; 由于题目给定0&lt;=i&lt;1000000000，i值很大，因此用数组保存每个a[i]直接递推实现不现实。</p>
<p>&nbsp; 因此，本题采用矩阵乘法来完成。用矩阵乘法完成递推式的求值是一种典型的方法。</p>
<p>&nbsp; &nbsp; &nbsp; 以输入输出样例为例先进行说明。</p>
<p>&nbsp; &nbsp; &nbsp; 样例中 k=2,a0=0,a1=1,b1=1,b2=1,求a6。</p>
<p>&nbsp; &nbsp; &nbsp; 用循环递推的方法模拟计算如下：&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;a2=a1*b1+a0*b2=1*1+0*1=1&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;a3=a2*b1+a1*b2=1*1+1*1=2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;a4=a3*b1+a2*b2=2*1+1*1=3&nbsp; </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;a5=a4*b1+a3*b2=3*1+2*1=5&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;a6=a5*b1+a4*b2=5*1+3*1=8&nbsp; &nbsp; &nbsp; &nbsp;故输出 8。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;采用矩阵计算时，先定义系数矩阵P和初始运算矩阵A：</p>
<p><em><span class="sh_comment" style="font-size: 13px;"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment"><span class="sh_comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推2.png" alt="" /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></em></p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推3.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推4.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（二）：利用矩阵快速幂运算完成递推5.png" alt="" /></p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;又由于矩阵乘法满足结合律，因此 P*P*P*P*P*A=（P*P*P*P*P）*A=(P^5)*A&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;即本题转化为求一个矩阵的n次方这样一个基本问题。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MODNUM 10000<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; int mat[110][110];<br />};</p>
<p style="margin-left: 30px;">Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(a.mat[i][k])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % MODNUM;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int b ,int n) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while(b)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n);   // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n);      // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int k,n,i,sum;<br />&nbsp; &nbsp; &nbsp; int a[110] ,b[110];&nbsp;<br />&nbsp; &nbsp; &nbsp; Matrix start ,ans;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d" ,&amp;k) &amp;&amp; k!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0 ;i &lt; k ;i ++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d" ,&amp;a[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;=k ;i ++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d" ,&amp;b[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d" ,&amp;n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n&lt;k)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n" ,a[n]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(start.mat ,0 ,sizeof(start.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt; k ;i ++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start.mat[i][i+1] = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= k ;i ++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start.mat[k][i] = b[k-i+1];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = quickMatPow(start ,n-k+1,k);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(i = 1 ;i &lt;= k ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum = (sum + a[i-1] * ans.mat[k][i]) % MODNUM;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n" ,sum);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p><span style="font-size: 16px;"><strong>【例4】简单定义的函数F(x)。&nbsp;</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;设函数f(x)的定义如下：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f(x) = x&nbsp; &nbsp; (x &lt; 10)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f(x) = a0 * f(x-1) + a1 * f(x-2) + &hellip;&hellip; + a9 * f(x-10) &nbsp;&nbsp;(x &gt;= 10)&nbsp;&nbsp; </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其中，ai(0&lt;=i&lt;=9) 的值为0或1。</p>
<p>&nbsp; &nbsp; &nbsp; 输入a0 ~ a9以及两个正整数k和m，输出f(k)%m的结果。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;直接构造一个10*10的矩阵P，P矩阵中的第一行为输入的a0 ~ a9，第2~10行除P.mat[i][i-1] （2&lt;=i&lt;=10）的元素值为1外，其余全为0。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;</p>
<p style="margin-left: 30px;">#include &lt;string.h&gt;<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; __int64 mat[11][11];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n,int m)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % m;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b,int m) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n,m);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = matMul(a ,a ,n,m);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b /= 2;<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int k,m,i;<br />&nbsp; &nbsp; &nbsp; __int64 ans;<br />&nbsp; &nbsp; &nbsp; Matrix p;<br />&nbsp; &nbsp; &nbsp; while(scanf("%d%d" ,&amp;k,&amp;m)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;=10;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d" ,&amp;p.mat[1][i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=2;i&lt;=10;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[i][i-1]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (k&lt;10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",k%m);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = quickMatPow(p,10,k-9,m);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;10;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+p.mat[1][i]*(10-i))% m;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%I64d\n" ,ans);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将此源程序提交给 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757" target="_blank">HDU 1757 &ldquo;A Simple Math Problem&rdquo;</a>，可以 Accepted。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>