<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C到C++的升级' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C到C++的升级</center></div><div class='banquan'>原文出处:本文由博客园博主原野追逐提供。<br/>
原文连接:https://www.cnblogs.com/songhe364826110/p/11517145.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#c与c的关系">1. C与C++的关系</a></li>
        <li><a href="#变量声明与定义">2. 变量声明与定义</a><ul>
        <li><a href="#变量可以在使用时定义">变量可以在使用时定义</a></li>
        <li><a href="#不允许定义同名全局变量">不允许定义同名全局变量</a></li>
        <li><a href="#标识符必须显示声明类型">标识符必须显示声明类型</a></li>
        </ul></li>
        <li><a href="#struct加强为类型">3. struct加强为类型</a></li>
        <li><a href="#三目运算符功能升级">4. 三目运算符功能升级</a></li>
        <li><a href="#const功能升级">5. const功能升级</a><ul>
        <li><a href="#c语言中的const">C语言中的const</a></li>
        <li><a href="#c中的const">C++中的const</a></li>
        <li><a href="#const常量进入符号表">const常量进入符号表</a></li>
        </ul></li>
        <li><a href="#bool类型引入">6. bool类型引入</a></li>
        <li><a href="#register成为废设只为兼容c">7. register成为废设，只为兼容C</a></li>
        </ul>
    </div>
</div>
<h1 id="c与c的关系">1. C与C++的关系</h1>
<ul>
<li>C++继承了所有的C特性</li>
<li>C++在C的基础上提供了更多的新的语法和特性</li>
<li>C++的设计目标是<font color=red>运行效率与开发效率的统一，其开发效率高于C语言</font></li>
</ul>
<p><img src="./images/C到C++的升级0.png" /></p>
<h1 id="变量声明与定义">2. 变量声明与定义</h1>
<h2 id="变量可以在使用时定义">变量可以在使用时定义</h2>
<ul>
<li>C++更强调语言的实用性，<font color=magenta>所有的变量都可以在需要使用时再定义</font></li>
<li>C语言中的变量必须在作用域开始的位置定义</li>
</ul>
<h2 id="不允许定义同名全局变量">不允许定义同名全局变量</h2>
<ul>
<li><font color=blue>C++不允许定义多个同名全局变量，否则编译会报错</font></li>
<li>C语言允许重复定义多个同名全局变量，它们最终会被链接到全局数据区的同一个地址空间上</li>
</ul>
<h2 id="标识符必须显示声明类型">标识符必须显示声明类型</h2>
<ul>
<li><font color=red>C++中所有的标识符都必须显式声明类型</font></li>
<li>C语言具有默认类型</li>
</ul>
<p>面试题：int f()和int f(void)有区别吗？如果有，区别是什么？</p>
<ul>
<li><font color=magenta>在C++中，两者都表示返回值为int的无参函数</font></li>
<li><font color=blue>在C语言中，前者表示返回值为int，接受任意个数、任意类型参数的函数，后者表示返回值为int的无参函数</font></li>
</ul>
<h1 id="struct加强为类型">3. struct加强为类型</h1>
<ul>
<li>C++中的struct用于定义一种新的类型</li>
<li>C语言中的struct只是一组变量的集合，必须通过typedef重命名才可以当类型用</li>
</ul>
<h1 id="三目运算符功能升级">4. 三目运算符功能升级</h1>
<p>C++对三目运算符进行了升级：</p>
<ul>
<li>当三目运算符的<font color=red>可能返回都是变量时，</font>返回的是<font color=magenta>变量的引用，</font><font color=blue>既可以作为右值使用，也可以作为左值使用</font></li>
<li>当三目运算符的<font color=red>可能返回中有常量时，</font>返回的是<font color=magenta>值，</font><font color=blue>只能作为右值使用</font></li>
<li>在C语言中，三目运算符的返回值始终只能作为右值使用</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int a = 1;
    int b = 2;

    ((a &lt; b) ? a : b) = 3;  //正确，返回a或b的引用，可以作为左值
    ((a &lt; b) ? 1 : b) = 4;  //错误，返回1或b的值，不能作为左值

    printf(&quot;a = %d, b = %d\n&quot;, a, b);

    return 0;
}</code></pre>
<p><img src="./images/C到C++的升级1.png" /></p>
<h1 id="const功能升级">5. const功能升级</h1>
<h2 id="c语言中的const">C语言中的const</h2>
<ul>
<li><font color=red>const用于定义只读变量</font></li>
<li>const局部变量<font color=blue>在栈上分配空间，</font>通过指针可以改变它的值</li>
<li>const全局变量<font color=blue>在只读存储区分配空间，</font>通过指针改变它的值会引起程序崩溃</li>
<li><font color=magenta>C语言中可以定义常量的只有enum</font></li>
</ul>
<p><img src="./images/C到C++的升级2.png" /></p>
<h2 id="c中的const">C++中的const</h2>
<ul>
<li>用<font color=red>字面值常量或其他const常量</font>初始化的为const常量</li>
<li>用<font color=blue>其他变量</font>初始化的、<font color=blue>被volatile修饰</font>的为只读变量</li>
<li>一句话，<font color=magenta>在编译期间不能直接确定初始值的const标识符，都是只读变量</font></li>
</ul>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    /* 用字面值常量或其他const常量初始化的为const常量 */
    const int A = 1;
    const int B = 2;
    const int C = B;
    int array[A + B + C] = {0};

    for (int i = 0; i &lt; (A + B + C); i++)
    {
        printf(&quot;array[%d] = %d\n&quot;, i, array[i]);
    }

    /* 用其他变量初始化的为const只读变量 */
    int x = 1;
    const int rx = x;
    int *prx = (int *)&amp;rx;
    *prx = 5;

    printf(&quot;rx = %d\n&quot;, rx);

    /* 被volatile修饰的为const只读变量 */
    volatile const int y = 2;
    int *p = (int *)&amp;y;
    *p = 6;

    printf(&quot;y = %d\n&quot;, y);

    return 0;
}</code></pre>
<p><img src="./images/C到C++的升级3.png" /></p>
<h2 id="const常量进入符号表">const常量进入符号表</h2>
<ul>
<li><font color=magenta>const常量会进入符号表，</font>编译过程中若发现使用该常量，则<font color=magenta>直接用符号表中的值替换</font></li>
<li>符号表是编译器在编译过程中所产生的<font color=blue>内部数据结构</font></li>
</ul>
<p><img src="./images/C到C++的升级4.png" /></p>
<p><font color=red>一般情况下，C++编译器不会为const常量分配内存空间，</font>除非遇到以下两种情况：</p>
<ul>
<li><font color=blue>对const全局常量使用extern</font></li>
<li><font color=blue>对const常量使用&amp;操作符</font></li>
</ul>
<p>C++编译器虽然可能会给const常量分配内存，<font color=magenta>但这仅仅是为了兼容C语言的特性，并不会使用该存储空间中的值，使用的仍然是符号表中的值。</font></p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    const int c = 0;
    int *p = (int *)&amp;c;         //对const常量取地址，为const常量分配内存空间
    *p = 5;                     //改变的是为const常量分配的内存空间

    printf(&quot;c = %d\n&quot;, c);      //const常量仍然使用符号表中的值
    printf(&quot;*p = %d\n&quot;, *p);    //这里才使用为const常量分配的内存空间中的值

    return 0;
}</code></pre>
<p><img src="./images/C到C++的升级5.png" /></p>
<h1 id="bool类型引入">6. bool类型引入</h1>
<ul>
<li>C++在C语言的基本类型系统之上增加了bool</li>
<li>C++中bool可取的值只有true和false，在编译器内部分别用1和0来表示</li>
<li>C++编译器会将非0值转换为true，将0值转换为false</li>
<li>理论上，bool只占用一个字节</li>
</ul>
<pre class="cpp"><code>#include &lt;stdio.h&gt;

int main()
{
    bool b = false;

    printf(&quot;sizeof(b) = %d\n&quot;, sizeof(b));
    printf(&quot;b = %d\n&quot;, b);

    b = 3;
    printf(&quot;b = %d\n&quot;, b);

    b = -5;
    printf(&quot;b = %d\n&quot;, b);

    b = 0;
    printf(&quot;b = %d\n&quot;, b);

    return 0;
}</code></pre>
<p><img src="./images/C到C++的升级6.png" /></p>
<h1 id="register成为废设只为兼容c">7. register成为废设，只为兼容C</h1>
<ul>
<li>在C语言中，register关键字请求编译器将局部变量存储于寄存器中，编译器可以忽略该请求</li>
<li>C语言无法对register变量取地址，但C++可以</li>
<li>C++早期编译器发现程序对register变量取地址时，会使register对变量的声明无效，因为不可能得到寄存器地址</li>
<li>在现在的C++编译器中，register的作用除了兼容C之外，完全是个形同虚设的鸡肋</li>
</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>