<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修扫描线——POJ1151' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>扫描线——POJ1151</center></div><div class='banquan'>原文出处:本文由博客园博主~Lanly~提供。<br/>
原文连接:https://www.cnblogs.com/Lanly/p/11193743.html</div><br>
    <p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">平面上有若干个矩形，求矩形相互覆盖的面积。为方便起见，矩形的边均平行于坐标轴。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><img src="./images/扫描线——POJ11510.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">我们根据<strong>容斥原理</strong>，<strong>矩形相互覆盖的面积</strong>即为<strong>所有矩形的面积和</strong>减去<strong>所有矩形所覆盖的面积</strong>即可。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">而现在问题是<span style="color: #ff0000;">如何求得所有矩形所覆盖的面积</span>。即</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><img src="./images/扫描线——POJ11511.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">让我们人类去做，由于这是个由矩形拼接成的多边形，很难去直接求它的面积，求该图形的面积一个常规的方法就是<strong>割补法</strong>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">此处我们采用割，割成一个一个矩形出来。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><img src="./images/扫描线——POJ11512.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">这样就很方便地去求了。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">计算机无法直观地看出图形，进而去求出长宽进而求出矩形面积。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">那该如何让计算机来求？</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">我们看这些图形，<strong>一块一块</strong>的，最下面的一块，可以想象成原矩形</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><img src="./images/扫描线——POJ11510.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">下面矩形最下面的边，向上平移时&ldquo;<span style="color: #ff0000;"><strong>刷</strong></span>&rdquo;出来的紫矩形，当碰到上面矩形的底边时，两条边<span style="color: #ff0000;">合并</span>，再向上平移时&ldquo;<span style="color: #ff0000;"><strong>刷</strong></span>&rdquo;出红色矩形，然后碰到下面矩形的顶边，去掉了顶边对应的底边，因为两边重合的部分有两条边贡献，所以去掉顶边线段后，重合部分还在，继续向上平移，&ldquo;<span style="color: #ff0000;"><strong>刷</strong></span>&rdquo;出了蓝色矩形。</span></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">有序，易行，计算机可做！</span></strong></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">其实这就是扫描线在干的事，一条透明的线从下向上平移，遇到底边，则扫描线在底边所在的范围有了颜色，这样向上平移的时候就&ldquo;<span style="color: #ff0000;"><strong>刷</strong></span>&rdquo;出了颜色，遇到顶边，则扫描线在顶边的范围就没了颜色，之后该部分就没有颜色了。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">所以现在的问题是，<strong>如何维护扫描线</strong>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">即我们要维护，<strong>扫描线有底边贡献的范围</strong>，以及<strong>该范围被几条底边所贡献</strong>，且<strong>当遇到顶边时要把相应底边的贡献去掉</strong>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">很显然，当底边两端点的坐标为<strong>实数</strong>，或者坐标范围<strong>很大</strong>时，直接维护点坐标是<strong>不现实</strong>的。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">实数怎么办？范围很大怎么办？</span></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px; color: #ff0000;">离散呀！</span></strong></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">我们注意到，所有矩形顶点的横坐标，其实是把x轴分成了<span style="color: #ff0000;">若干个区间</span>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">而任意一个矩形的底边，只是会<span style="color: #ff0000;">覆盖若干个区间</span>，而<span style="color: #ff0000;">不会只覆盖某区间的一部分</span>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">那我们就可以<strong>维护区间</strong>，从而避开了实数的无穷个数和范围大造成数据冗余以及内存爆表的问题。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">当我们遇到一个矩形的底边时，只需在底边所覆盖的若干个区间<span style="color: #ff0000;">加一</span>，即贡献一个底边。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">而在遇到一个矩形的顶边的时候，在顶边所覆盖的若干个区间<span style="color: #ff0000;">减一</span>，即去除该矩形底边的贡献。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">最终，<strong>只要有底边有贡献的区间</strong>，都是扫描线&ldquo;有颜色&rdquo;的范围。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">这里涉及到了<span style="color: #ff0000;">区间加</span>，<span style="color: #ff0000;">区间减</span>以及<span style="color: #ff0000;">区间查询</span>。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">拿什么维护呢。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">当然是<span style="color: #ff0000;">线段树</span>啦。</span></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">所以，</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">根据边的x坐标划分<span style="text-decoration: line-through;">离散</span>x轴的区间，</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">拿线段树去维护区间，</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">把边按y轴从小到大排序，自1到n即自下而上扫描，</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">不断更新扫描线的有颜色的范围长度，再乘以上下两边的y轴的数值差，即为此部分扫描的面积。</span></strong></p>
<p><strong><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">重复即可。</span></strong></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">离散的写法有好多，这里运用STLl较为简便的写法。</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">注意离散后也要能映射回去。</span></p>
<p>&nbsp;</p>
<p><a href="http://poj.org/problem?id=1151" target="_blank"><span style="font-family: 'Microsoft YaHei'; font-size: 15px;">POJ1151</span></a></p>
<p class="pst">Description</p>
<div class="ptx" lang="en-US">There are several ancient Greek texts that contain descriptions of the fabled island Atlantis. Some of these texts even include maps of parts of the island. But unfortunately, these maps describe different regions of Atlantis. Your friend Bill has to know the total area for which maps exist. You (unwisely) volunteered to write a program that calculates this quantity.</div>
<p class="pst">Input</p>
<div class="ptx" lang="en-US">The input consists of several test cases. Each test case starts with a line containing a single integer n (1 &lt;= n &lt;= 100) of available maps. The n following lines describe one map each. Each of these lines contains four numbers x1;y1;x2;y2 (0 &lt;= x1 &lt; x2 &lt;= 100000;0 &lt;= y1 &lt; y2 &lt;= 100000), not necessarily integers. The values (x1; y1) and (x2;y2) are the coordinates of the top-left resp. bottom-right corner of the mapped area.&nbsp;<br />The input file is terminated by a line containing a single 0. Don't process it.</div>
<p class="pst">Output</p>
<div class="ptx" lang="en-US">For each test case, your program should output one section. The first line of each section must be "Test case #k", where k is the number of the test case (starting with 1). The second one must be "Total explored area: a", where a is the total explored area (i.e. the area of the union of all rectangles in this test case), printed exact to two digits to the right of the decimal point.&nbsp;<br />Output a blank line after each test case.</div>
<div class="ptx" lang="en-US">&nbsp;</div>
<div class="ptx" lang="en-US"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">大意就是求岛的面积<span style="text-decoration: line-through;">（还是矩形的）</span>，给出若干个矩形，以左上和右下点的坐标来表示，矩形间会有重叠，重叠部分只算一次。</span></div>
<div class="ptx" lang="en-US"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">扫一下就好了。</span></div>
<div class="ptx" lang="en-US"><span style="font-family: 'Microsoft YaHei'; font-size: 16px;">注意原题的一句话</span></div>
<div class="ptx" lang="en-US"><span style="color: #ff0000; font-size: 18pt;"><strong><span style="font-family: 'Microsoft YaHei';">Output a blank line after each test case.</span></strong></span></div>
<div class="ptx" lang="en-US"><strong><span style="color: #000000; font-size: 16px;"><span style="font-family: 'Microsoft YaHei';">否则你会Presentation Error</span></span></strong></div>
<div class="ptx" lang="en-US">&nbsp;</div>
<div class="ptx" lang="en-US">
<div class="cnblogs_code" onclick="cnblogs_code_show('42fb047e-9e10-45c2-9969-7ff3caae7315')"><img id="code_img_closed_42fb047e-9e10-45c2-9969-7ff3caae7315" class="code_img_closed" src="./images/扫描线——POJ11514.png" alt="" /><img id="code_img_opened_42fb047e-9e10-45c2-9969-7ff3caae7315" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('42fb047e-9e10-45c2-9969-7ff3caae7315',event)" src="./images/扫描线——POJ11515.png" alt="" />
<div id="cnblogs_code_open_42fb047e-9e10-45c2-9969-7ff3caae7315" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;algorithm&gt;
<span style="color: #008080;"> 2</span> #include &lt;cstring&gt;
<span style="color: #008080;"> 3</span> #include &lt;cstdlib&gt;
<span style="color: #008080;"> 4</span> #include &lt;cstdio&gt;
<span style="color: #008080;"> 5</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 6</span> #include &lt;cmath&gt;
<span style="color: #008080;"> 7</span> #include &lt;ctime&gt;
<span style="color: #008080;"> 8</span> #include &lt;queue&gt;
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">#define</span> N 200
<span style="color: #008080;">10</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;">11</span> <span style="color: #0000ff;">struct</span> seg{ <span style="color: #008000;">//</span><span style="color: #008000;">边</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">double</span><span style="color: #000000;"> l,r,h;
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> d;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    seg(){}
</span><span style="color: #008080;">15</span>     seg(<span style="color: #0000ff;">double</span> xx,<span style="color: #0000ff;">double</span> yy,<span style="color: #0000ff;">double</span> hh,<span style="color: #0000ff;">int</span> dd):l(xx),r(yy),h(hh),d(dd){}  <span style="color: #008000;">//</span><span style="color: #008000;">初始化函数</span>
<span style="color: #008080;">16</span>     <span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span> &lt; (<span style="color: #0000ff;">const</span> seg &amp;a) <span style="color: #0000ff;">const</span>{   <span style="color: #008000;">//</span><span style="color: #008000;">重载运算符，使其能够进行快排</span>
<span style="color: #008080;">17</span>         <span style="color: #0000ff;">return</span> (h&lt;<span style="color: #000000;">a.h);
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">19</span> }s[N*<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #008080;">20</span> <span style="color: #0000ff;">struct</span> tree{ <span style="color: #008000;">//</span><span style="color: #008000;">线段树</span>
<span style="color: #008080;">21</span>     <span style="color: #0000ff;">int</span> mark;   <span style="color: #008000;">//</span><span style="color: #008000;">mark记录底边对区间的贡献</span>
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">double</span> sum;  <span style="color: #008000;">//</span><span style="color: #008000;">sum记录底边贡献的范围</span>
<span style="color: #008080;">23</span> }t[N*<span style="color: #800080;">10</span><span style="color: #000000;">];
</span><span style="color: #008080;">24</span> <span style="color: #0000ff;">int</span> n,ll,rr,num,size,qwq;  <span style="color: #008000;">//</span><span style="color: #008000;">qwq</span>
<span style="color: #008080;">25</span> <span style="color: #0000ff;">double</span> ans,rank[N*<span style="color: #800080;">10</span>];  <span style="color: #008000;">//</span><span style="color: #008000;">rank做离散用</span>
<span style="color: #008080;">26</span> <span style="color: #0000ff;">void</span> readint(<span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">x){
</span><span style="color: #008080;">27</span>     x=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">28</span>     <span style="color: #0000ff;">char</span><span style="color: #000000;"> c;
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">int</span> w=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">30</span>     <span style="color: #0000ff;">for</span> (c=getchar();c&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>||c&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>;c=<span style="color: #000000;">getchar())
</span><span style="color: #008080;">31</span>         <span style="color: #0000ff;">if</span> (c==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) w=-<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">32</span>     <span style="color: #0000ff;">for</span> (;c&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;c&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>;c=<span style="color: #000000;">getchar())
</span><span style="color: #008080;">33</span>         x=(x&lt;&lt;<span style="color: #800080;">3</span>)+(x&lt;&lt;<span style="color: #800080;">1</span>)+(c^<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;">34</span>     x*=<span style="color: #000000;">w;
</span><span style="color: #008080;">35</span> <span style="color: #000000;">}
</span><span style="color: #008080;">36</span> <span style="color: #0000ff;">void</span> readlong(<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> &amp;<span style="color: #000000;">x){
</span><span style="color: #008080;">37</span>     x=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">38</span>     <span style="color: #0000ff;">char</span><span style="color: #000000;"> c;
</span><span style="color: #008080;">39</span>     <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> w=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">40</span>     <span style="color: #0000ff;">for</span> (c=getchar();c&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>||c&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>;c=<span style="color: #000000;">getchar())
</span><span style="color: #008080;">41</span>         <span style="color: #0000ff;">if</span> (c==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) w=-<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">42</span>     <span style="color: #0000ff;">for</span> (;c&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;c&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>;c=<span style="color: #000000;">getchar())
</span><span style="color: #008080;">43</span>         x=(x&lt;&lt;<span style="color: #800080;">3</span>)+(x&lt;&lt;<span style="color: #800080;">1</span>)+(c^<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #008080;">44</span>     x*=<span style="color: #000000;">w;
</span><span style="color: #008080;">45</span> <span style="color: #000000;">}
</span><span style="color: #008080;">46</span> <span style="color: #0000ff;">void</span> pushup(<span style="color: #0000ff;">int</span> root,<span style="color: #0000ff;">int</span> ll,<span style="color: #0000ff;">int</span><span style="color: #000000;"> rr){
</span><span style="color: #008080;">47</span>     <span style="color: #0000ff;">if</span> (t[root].mark) t[root].sum=rank[rr+<span style="color: #800080;">1</span>]-rank[ll]; <span style="color: #008000;">//</span><span style="color: #008000;">离散后的数字映射回原来的数字</span>
<span style="color: #008080;">48</span>     <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (ll==rr) t[root].sum=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">49</span>     <span style="color: #0000ff;">else</span> t[root].sum=t[root&lt;&lt;<span style="color: #800080;">1</span>].sum+t[root&lt;&lt;<span style="color: #800080;">1</span>|<span style="color: #800080;">1</span><span style="color: #000000;">].sum;
</span><span style="color: #008080;">50</span> <span style="color: #000000;">}
</span><span style="color: #008080;">51</span> <span style="color: #0000ff;">void</span> updata(<span style="color: #0000ff;">int</span> l,<span style="color: #0000ff;">int</span> r,<span style="color: #0000ff;">int</span> d,<span style="color: #0000ff;">int</span> root,<span style="color: #0000ff;">int</span> ll,<span style="color: #0000ff;">int</span><span style="color: #000000;"> rr){
</span><span style="color: #008080;">52</span>     <span style="color: #0000ff;">if</span> (l&lt;=ll&amp;&amp;rr&lt;=<span style="color: #000000;">r){
</span><span style="color: #008080;">53</span>         t[root].mark+=<span style="color: #000000;">d;
</span><span style="color: #008080;">54</span> <span style="color: #000000;">        pushup(root,ll,rr);
</span><span style="color: #008080;">55</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;">;
</span><span style="color: #008080;">56</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">57</span>     <span style="color: #0000ff;">int</span> mid=(ll+rr)&gt;&gt;<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008080;">58</span>     <span style="color: #0000ff;">if</span> (l&lt;=mid) updata(l,r,d,root&lt;&lt;<span style="color: #800080;">1</span><span style="color: #000000;">,ll,mid);
</span><span style="color: #008080;">59</span>     <span style="color: #0000ff;">if</span> (r&gt;mid) updata(l,r,d,root&lt;&lt;<span style="color: #800080;">1</span>|<span style="color: #800080;">1</span>,mid+<span style="color: #800080;">1</span><span style="color: #000000;">,rr);
</span><span style="color: #008080;">60</span> <span style="color: #000000;">    pushup(root,ll,rr);
</span><span style="color: #008080;">61</span> <span style="color: #000000;">}
</span><span style="color: #008080;">62</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
</span><span style="color: #008080;">63</span>     qwq=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">64</span>     <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">){
</span><span style="color: #008080;">65</span>         ++qwq; <span style="color: #008000;">//</span><span style="color: #008000;">qwq只是情况记录的个数qwq</span>
<span style="color: #008080;">66</span>         num=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">67</span>         ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">68</span> <span style="color: #000000;">        readint(n);
</span><span style="color: #008080;">69</span>         <span style="color: #0000ff;">if</span> (n==<span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">应题目要求</span>
<span style="color: #008080;">70</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;++<span style="color: #000000;">i){
</span><span style="color: #008080;">71</span>             <span style="color: #0000ff;">double</span><span style="color: #000000;"> x1,y1,x2,y2;
</span><span style="color: #008080;">72</span>             scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%lf%lf%lf%lf</span><span style="color: #800000;">"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;<span style="color: #000000;">y2);
</span><span style="color: #008080;">73</span>             s[++num]=seg(x1,x2,y2,<span style="color: #800080;">1</span><span style="color: #000000;">);
</span><span style="color: #008080;">74</span>             rank[num]=<span style="color: #000000;">x1;
</span><span style="color: #008080;">75</span>             s[++num]=seg(x1,x2,y1,-<span style="color: #800080;">1</span><span style="color: #000000;">);
</span><span style="color: #008080;">76</span>             rank[num]=<span style="color: #000000;">x2;
</span><span style="color: #008080;">77</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">78</span>         sort(rank+<span style="color: #800080;">1</span>,rank+<span style="color: #800080;">1</span>+<span style="color: #000000;">num);
</span><span style="color: #008080;">79</span>         sort(s+<span style="color: #800080;">1</span>,s+<span style="color: #800080;">1</span>+<span style="color: #000000;">num);
</span><span style="color: #008080;">80</span>         size=unique(rank+<span style="color: #800080;">1</span>,rank+<span style="color: #800080;">1</span>+num)-(rank+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">去重,size为去重后点的个数，为离散做准备</span>
<span style="color: #008080;">81</span>         s[num+<span style="color: #800080;">1</span>].h=s[num].h;  <span style="color: #008000;">//</span><span style="color: #008000;">小细节，只为下面i循环后mark能清零且不会在i=n时对结果造成影响</span>
<span style="color: #008080;">82</span>         <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=num;++<span style="color: #000000;">i){
</span><span style="color: #008080;">83</span>             ll=lower_bound(rank+<span style="color: #800080;">1</span>,rank+<span style="color: #800080;">1</span>+size,s[i].l)-(rank+<span style="color: #800080;">1</span>)+<span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;">这里左边第一个点标号为1，其点右边第一个区间标号也为1</span>
<span style="color: #008080;">84</span>             rr=lower_bound(rank+<span style="color: #800080;">1</span>,rank+<span style="color: #800080;">1</span>+size,s[i].r)-(rank+<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">离散，ll,rr为边覆盖的最左区间和最右区间的标号</span>
<span style="color: #008080;">85</span>             updata(ll,rr,s[i].d,<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>,size-<span style="color: #800080;">1</span>); <span style="color: #008000;">//</span><span style="color: #008000;">植树原理，一条直线，两头植树，n个点，n-1个区间</span>
<span style="color: #008080;">86</span>             ans+=t[<span style="color: #800080;">1</span>].sum*(s[i+<span style="color: #800080;">1</span>].h-s[i].h); <span style="color: #008000;">//</span><span style="color: #008000;">长乘宽</span>
<span style="color: #008080;">87</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">88</span>         printf(<span style="color: #800000;">"</span><span style="color: #800000;">Test case #%d\nTotal explored area: %.2f\n\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,qwq,ans);
</span><span style="color: #008080;">89</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">90</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">91</span> }</pre>
</div>
<span class="cnblogs_code_collapse">神奇的代码</span></div>
<p>&nbsp;</p>
</div>
<div class="ptx" lang="en-US">
<p>&nbsp;什么？你说4+2第一天那道绝地求生，有若干个圆形辐射区，问安全区的面积怎么用扫描线扫？</p>
<p>那听说是道圆的面积并的模板题，但本蒟蒻还不会&hellip;&hellip;</p>
<p>&nbsp;</p>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>