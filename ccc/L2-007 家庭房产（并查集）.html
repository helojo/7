<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修L2-007 家庭房产（并查集）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>L2-007 家庭房产（并查集）</center></div><div class='banquan'>原文出处:本文由博客园博主小泰格儿提供。<br/>
原文连接:https://www.cnblogs.com/littleLittleTiger/p/10588106.html</div><br>
    <h2>题目：</h2>
<div class="problem_2tXnk">
<div class="ques-view">
<p>给定每个人的家庭成员和其自己名下的房产，请你统计出每个家庭的人口数、人均房产面积及房产套数。</p>
<h3 id="-">输入格式：</h3>
<p>输入第一行给出一个正整数<span class="katex"><span class="katex-html"><span class="strut" style="height: 0.68333em;"><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N（<span class="katex"><span class="katex-html"><span class="strut" style="height: 0.64444em;"><span class="strut bottom" style="height: 0.78041em; vertical-align: -0.13597em;"><span class="base textstyle uncramped"><span class="mrel">&le;<span class="mord mathrm">1<span class="mord mathrm">0<span class="mord mathrm">0<span class="mord mathrm">0），随后<span class="katex"><span class="katex-html"><span class="strut" style="height: 0.68333em;"><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right: 0.10903em;">N行，每行按下列格式给出一个人的房产：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code>编号 父 母 k 孩子1 ... 孩子k 房产套数 总面积
</code></pre>
<p>其中<code>编号</code>是每个人独有的一个4位数的编号；<code>父</code>和<code>母</code>分别是该编号对应的这个人的父母的编号（如果已经过世，则显示<code>-1</code>）；<code>k</code>（<span class="katex"><span class="katex-html"><span class="strut" style="height: 0.64444em;"><span class="strut bottom" style="height: 0.78041em; vertical-align: -0.13597em;"><span class="base textstyle uncramped"><span class="mord mathrm">0<span class="mrel">&le;<code>k</code><span class="katex"><span class="katex-html"><span class="strut" style="height: 0.64444em;"><span class="strut bottom" style="height: 0.78041em; vertical-align: -0.13597em;"><span class="base textstyle uncramped"><span class="mrel">&le;<span class="mord mathrm">5）是该人的子女的个数；<code>孩子i</code>是其子女的编号。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="-">输出格式：</h3>
<p>首先在第一行输出家庭个数（所有有亲属关系的人都属于同一个家庭）。随后按下列格式输出每个家庭的信息：</p>
<pre><code>家庭成员的最小编号 家庭人口数 人均房产套数 人均房产面积
</code></pre>
<p>其中人均值要求保留小数点后3位。家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。</p>
<h3 id="-">输入样例：</h3>
<pre><code class="lang-in">10
6666 5551 5552 1 7777 1 100
1234 5678 9012 1 0002 2 300
8888 -1 -1 0 1 1000
2468 0001 0004 1 2222 1 500
7777 6666 -1 0 2 300
3721 -1 -1 1 2333 2 150
9012 -1 -1 3 1236 1235 1234 1 100
1235 5678 9012 0 1 50
2222 1236 2468 2 6661 6662 1 300
2333 -1 3721 3 6661 6662 6663 1 100
</code></pre>
<h3 id="-">输出样例：</h3>
<pre><code class="lang-out">3
8888 1 1.000 1000.000
0001 15 0.600 100.000
5551 4 0.750 100.000
</code></pre>
</div>
</div>
<p>&nbsp;</p>
<h2>并查集：</h2>
<p>最初了解并查集是看的这位哥们的博客：<a href="https://www.cnblogs.com/xzxl/p/7226557.html" target="_blank">https://www.cnblogs.com/xzxl/p/7226557.html</a> ，下面我简单概括一下。</p>
<p><span style="font-size: 18px;"><strong>一般题目类型：</strong></span>1、解决有几个联通分支的问题。2、判断两个结点是否在一个联通分支。3、将两个联通分支连起来等等。。。。&nbsp;&nbsp; 其实这些问的都差不多，都是要按题目要求把结点划分成不同的连通分支。</p>
<p><span style="font-size: 18px;"><strong>基本构成：</strong></span></p>
<p>1、<span style="color: #339966;">int pre[ ]</span>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 这个数组记录了每个结点的父结点。数组元素的值就是数组下标表示的结点的父结点。初始化时所有结点的父结点都是它自身，也就是元素的值等于元素下标。</p>
<p>2、<span style="color: #339966;">int find(int x){</span></p>
<p><span style="color: #339966;">&nbsp;&nbsp;&nbsp;&nbsp; while(x!=pre[x])&nbsp;&nbsp;&nbsp; //如果该结点的父结点不是它自身<br /></span></p>
<p><span style="color: #339966;">　　　　x=pre[x];&nbsp;&nbsp;&nbsp; //那么就继续找它的父结点的父结点<br /></span></p>
<p><span style="color: #339966;">　&nbsp; return x;}</span></p>
<p>&nbsp;&nbsp; 查找函数：用于查找结点的父结点。</p>
<p>3、<span style="color: #339966;">void Union(int x,int y){</span></p>
<p><span style="color: #339966;">　　int fx=find(x);&nbsp; //找到x的根结点</span></p>
<p><span style="color: #339966;">　　int fy=find(y);&nbsp; //找到y的根结点</span></p>
<p><span style="color: #339966;">　　if(fx!=fy)&nbsp; //如果x和y的根结点不相同（x和y不属于同一个联通分支）<br /></span></p>
<p><span style="color: #339966;">　　　　pre[fx]=fy; //就把x的根结点的父结点改为y的根结点</span></p>
<p><span style="color: #339966;">　　}</span></p>
<p><span style="color: #339966;">　　</span>合并函数：用于将两个结点所在的连通分支合为一个。通过将其中一个连通分支的根结点的父结点改为另一个连通分支的根结点。<span style="color: #339966;">pre[fx]=fy;</span>也可以根据题意做变动，比如这题要求输出家庭成员的最小编号，那么就要把编号大的根结点并入编号小的一边，这样直接输出一个连通分支的根结点就是这个联通分支中编号最小的了。</p>
<p>&nbsp;</p>
<p>并查集并查集，两个函数就是一个并，一个查，再加上一个存放父结点的数组。一般来说，<span style="background-color: #ffff99;">一个并查集对应三个操作：初始化+查找根结点函数+合并集合函数。</span></p>
<p>&nbsp;</p>
<h2>思路：</h2>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ⽤两个结构体数组，⼀个data⽤来接收数据，接收的时候顺便实现了并查集的操作union，另⼀个数组ans⽤来输出最后的答案，因为要计算家庭⼈数，所以⽤visit标记所有出现过的结点，对于每个结点的⽗结点，people++统计⼈数。标记flag == true，计算true的个数cnt就可以知道⼀共有多少个家庭。排序后输出前cnt个就是所求答案。</p>
<h2>上代码：</h2>
<div class="cnblogs_code">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> DATA{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> id,fid,mid,num,area;
    </span><span style="color: #0000ff;">int</span> cid[<span style="color: #800080;">10</span><span style="color: #000000;">];
}data[</span><span style="color: #800080;">1005</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> ANS{
    </span><span style="color: #0000ff;">int</span> id,people;<span style="color: #008000;">//</span><span style="color: #008000;">家庭成员的最小编号 家庭人口数</span>
    <span style="color: #0000ff;">double</span> num,area;<span style="color: #008000;">//</span><span style="color: #008000;">人均房产套数 人均房产面积</span>
    <span style="color: #0000ff;">bool</span> flag=<span style="color: #0000ff;">false</span>;<span style="color: #008000;">//</span><span style="color: #008000;">统计true的个数可以知道一共有多少个家庭    </span>
}ans[<span style="color: #800080;">10000</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> father[<span style="color: #800080;">10000</span>];<span style="color: #008000;">//</span><span style="color: #008000;">编号都是四位数,表示下标的父节点 </span>
<span style="color: #0000ff;">bool</span> visit[<span style="color: #800080;">10000</span>];<span style="color: #008000;">//</span><span style="color: #008000;">下标所表示的编号是否有人 </span>
<span style="color: #0000ff;">int</span> find(<span style="color: #0000ff;">int</span> x)<span style="color: #008000;">//</span><span style="color: #008000;">找到x的根结点</span>
<span style="color: #000000;">{ 
    </span><span style="color: #0000ff;">while</span>(x!=<span style="color: #000000;">father[x])
        x</span>=<span style="color: #000000;">father[x];
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> x;    
}
</span><span style="color: #0000ff;">void</span> Union(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span> y)<span style="color: #008000;">//</span><span style="color: #008000;">将x和y合并到一颗树中</span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span> fx=<span style="color: #000000;">find(x);
    </span><span style="color: #0000ff;">int</span> fy=<span style="color: #000000;">find(y);
    </span><span style="color: #0000ff;">if</span>(fx&gt;fy)<span style="color: #008000;">//</span><span style="color: #008000;">要求输出家庭成员的最小编号， 所以根节点应该最小 </span>
<span style="color: #000000;">    {
        father[fx]</span>=<span style="color: #000000;">fy;
    }</span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(fx&lt;<span style="color: #000000;">fy){
        father[fy]</span>=<span style="color: #000000;">fx;
    } 
}
</span><span style="color: #0000ff;">bool</span> cmp(ANS a,ANS b)<span style="color: #008000;">//</span><span style="color: #008000;">家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。</span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">if</span>(a.area!=b.area) <span style="color: #0000ff;">return</span> a.area&gt;<span style="color: #000000;">b.area;
    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> a.id&lt;<span style="color: #000000;">b.id;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
     </span><span style="color: #0000ff;">int</span> n,k,cnt=<span style="color: #800080;">0</span><span style="color: #000000;">;
     cin</span>&gt;&gt;<span style="color: #000000;">n;
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">10000</span>;i++<span style="color: #000000;">)
     {
         father[i]</span>=i;<span style="color: #008000;">//</span><span style="color: #008000;">初始化所有结点的父节点都为自身 </span>
<span style="color: #000000;">     }
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
     {
         cin</span>&gt;&gt;data[i].id&gt;&gt;data[i].fid&gt;&gt;data[i].mid&gt;&gt;<span style="color: #000000;">k;
         visit[data[i].id]</span>=<span style="color: #0000ff;">true</span><span style="color: #000000;">;
         </span><span style="color: #0000ff;">if</span>(data[i].fid!=-<span style="color: #800080;">1</span><span style="color: #000000;">)
         {
             visit[data[i].fid]</span>=<span style="color: #0000ff;">true</span><span style="color: #000000;">;
            Union(data[i].fid,data[i].id);</span><span style="color: #008000;">//</span><span style="color: #008000;">如果此人的父亲没有过世，就将其合并到家族    </span>
<span style="color: #000000;">         }
         
         </span><span style="color: #0000ff;">if</span>(data[i].mid!=-<span style="color: #800080;">1</span><span style="color: #000000;">)
         {
             visit[data[i].mid]</span>=<span style="color: #0000ff;">true</span><span style="color: #000000;">;
             Union(data[i].mid,data[i].id);
         }
         </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;k;j++)<span style="color: #008000;">//</span><span style="color: #008000;">把孩子也加入家族 </span>
<span style="color: #000000;">        {
             cin</span>&gt;&gt;<span style="color: #000000;">data[i].cid[j];
             visit[data[i].cid[j]]</span>=<span style="color: #0000ff;">true</span><span style="color: #000000;">;
             Union(data[i].cid[j],data[i].id);
         }    
         cin</span>&gt;&gt;data[i].num&gt;&gt;<span style="color: #000000;">data[i].area;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++) <span style="color: #008000;">//</span><span style="color: #008000;">统计 </span>
<span style="color: #000000;">    {
        </span><span style="color: #0000ff;">int</span> id=<span style="color: #000000;">find(data[i].id);
        ans[id].id</span>=id;<span style="color: #008000;">//</span><span style="color: #008000;">整个家族的根结点 </span>
        ans[id].num+=data[i].num;<span style="color: #008000;">//</span><span style="color: #008000;">整个家族的房产套数 </span>
        ans[id].area+=data[i].area;<span style="color: #008000;">//</span><span style="color: #008000;">整个家族的房产面积 </span>
        ans[id].flag=<span style="color: #0000ff;">true</span>;<span style="color: #008000;">//</span><span style="color: #008000;">用于统计家族数 </span>
<span style="color: #000000;">     } 
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">10000</span>;i++<span style="color: #000000;">)
     {
         </span><span style="color: #0000ff;">if</span>(visit[i])<span style="color: #008000;">//</span><span style="color: #008000;">每找到一个人 </span>
             ans[find(i)].people++;<span style="color: #008000;">//</span><span style="color: #008000;">就将他所在的家族人数加一 </span>
        <span style="color: #0000ff;">if</span>(ans[i].flag)<span style="color: #008000;">//</span><span style="color: #008000;">每找到一个家族 </span>
            cnt++; <span style="color: #008000;">//</span><span style="color: #008000;">家族数加一 </span>
<span style="color: #000000;">     }
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">10000</span>;i++)<span style="color: #008000;">//</span><span style="color: #008000;">计算每个家族的人均房产套数和房产面积 </span>
<span style="color: #000000;">     {
         </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(ans[i].flag)
         {
             ans[i].num </span>= (<span style="color: #0000ff;">double</span>)(ans[i].num * <span style="color: #800080;">1.0</span> /<span style="color: #000000;"> ans[i].people);
             ans[i].area </span>= (<span style="color: #0000ff;">double</span>)(ans[i].area * <span style="color: #800080;">1.0</span> /<span style="color: #000000;"> ans[i].people);
         }
      } 
      sort(ans,ans</span>+<span style="color: #800080;">10000</span><span style="color: #000000;">,cmp); 
      printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, cnt);
     </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; cnt; i++<span style="color: #000000;">)
         printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%04d %d %.3f %.3f\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, ans[i].id, ans[i].people,ans[i].num, ans[i].area);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
 } </span></pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>