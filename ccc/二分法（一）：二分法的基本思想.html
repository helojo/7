<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修二分法（一）：二分法的基本思想' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>二分法（一）：二分法的基本思想</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11212022.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 二分法是一个非常高效的算法，它常常用于计算机的查找过程中。</p>
<p>&nbsp; &nbsp; &nbsp; 先玩一个小游戏。预先给定一个小于100的正整数x，让你猜，猜测过程中给予大小判断的提示，问你怎样快速地猜出来？</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这样猜测最快，先猜50，如果猜对了，结束；如果猜大了，往小的方向猜，再猜25；如果猜小了，往大的方向猜，再猜75；&hellip;，每猜测1次就去掉一半的数，就这样可以逐步逼近预先给定的数字。这种思想就是二分法。</p>
<p>&nbsp; &nbsp; &nbsp; 在用二分法进行查找时，查找对象的数组必须是有序的，即各数组元素的次序是按其值的大小顺序存储的。其基本思想是先确定待查数据的范围（可用 [left,right] 区间表示），然后逐步缩小范围直到找到或找不到该记录为止。具体做法是：先取数组中间位置（mid=(left+right)/2）的数据元素与给定值比较。若相等，则查找成功；否则，若给定值比该数据元素的值小（或大），则给定值必在数组的前半部分[left,mid-1]（或后半部分[mid+1,right]），然后在新的查找范围内进行同样的查找。如此反复进行，直到找到数组元素值与给定值相等的元素或确定数组中没有待查找的数据为止。因此，二分查找每查找一次，或成功，或使查找数组中元素的个数减少一半，当查找数组中不再有数据元素时，查找失败。</p>
<p>&nbsp; &nbsp; &nbsp; 二分法查找是一种非常高效的搜索方法，主要原理是每次搜索可以抛弃一半的值来缩小范围。其时间复杂度是O(log<sub>2</sub>n)，一般用于对普通搜索方法的优化。</p>
<p>&nbsp; &nbsp; 二分法的适用情况一般满足以下几点：（1）该数组数据量巨大，需要对处理的时间复杂度进行优化；（2）该数组已经排序；（3）一般要求找到的是某一个值或一个位置。</p>
<p><span style="font-size: 16px;"><strong>【例1】二分查找。</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; 有若干个数按由小到大的顺序存放在一个一维数组中，输入一个数x，用二分查找法找出x是数组中第几个数组元素的值。如果x不在数组中，则输出&ldquo;无此数！&rdquo;。<br />&nbsp; &nbsp; &nbsp; （1）编程思路。<br />&nbsp; &nbsp; &nbsp; 设有一数组a[n]，数组中的元素按值从小到大排列有序。用变量low、high和mid分别指示待查元素所在区间的下界、上界和中间位置。初始时，low=0，high=n-1。<br />&nbsp; &nbsp; &nbsp; 1）令 mid = (low+ high) /2 。<br />&nbsp; &nbsp; &nbsp; 2）比较给定值x与a[mid]值的大小<br />&nbsp; &nbsp; &nbsp; 若a[mid] == x ，则查找成功，结束查找；<br />&nbsp; &nbsp; &nbsp; 若a[mid]&gt; x ，则表明给定值x只可能在区间low ~ mid-1内，修改检索范围。令high=mid-1，low值保持不变；<br />&nbsp; &nbsp; &nbsp; 若a[mid]&lt; x ，则表明给定值x只可能在区间mid+1~high内，修改检索范围。令low=mid+1，high值保持不变。<br />&nbsp; &nbsp; &nbsp; 3）比较当前变量low和high的值，若low&le;high，重复执行第1）、2）两步，若low&gt;high，表明数组中不存在待查找的元素，查找失败。<br />&nbsp; &nbsp; &nbsp; 例如，设一有序的数组中有11个数据元素，它们的值依次为{3，8，15，21，35，54，63，79，82，92，97}，用二分查找在该数组中查找值为82和87的元素的过程如图1所示。</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/二分法（一）：二分法的基本思想0.png" alt="" /></p>
<p style="text-align: center;">&nbsp; &nbsp; 图1&nbsp; 二分查找的查找过程</p>
<p style="text-align: left;">&nbsp; &nbsp; &nbsp; 图1（a）所示为查找成功的情况，仅需比较2次。若用顺序查找，则需比较9次。图2（b）所示为查找不成功的情况，此时因为low&gt;high，说明数组中没有元素值等于87的元素。得到查找失败信息，也只需比较4次。若用顺序查找，则必须比较12次。<br />&nbsp; &nbsp; &nbsp; 二分查找过程通常可用一个二叉判定树表示。对于上例给定长度的数组，二分查找过程可用图2所示的二叉判定树来描述，树中结点的值为相应元素在数组中的位置。查找成功时恰好走了一条从根结点到该元素相应结点的路径，所用的比较次数是该路径长度加1或结点在二叉判定树上的层次数。所以，折半查找在查找成功时所用的比较次数最多不超过相应的二叉判定树的深度[log2n]+ 1。同理，查找不成功时，恰好走了一条从根结点到某一终端结点的路径。因此，所用的比较次数最多也不超过[log2n] + 1。</p>
<p style="text-align: center;"><br /> <img src="./images/二分法（一）：二分法的基本思想1.png" alt="" /><br />图2  描述折半查找过程的二叉判定树</p>
<p style="text-align: left; margin-left: 30px;">（2）源程序。<br />#include &lt;iostream&gt;<br />using namespace std;<br />int  main()<br />{<br />&nbsp; &nbsp; &nbsp; const int n=20;<br />&nbsp; &nbsp; &nbsp; int a[n]={1,6,9,14,15,17,18,23,24,28,34,39,48,56,67,72,89,92,98,100};<br />&nbsp; &nbsp; &nbsp; int x,low,high,mid;<br />&nbsp; &nbsp; &nbsp; cout&lt;&lt;"Please input a number x:";<br />&nbsp; &nbsp; &nbsp; cin&gt;&gt;x;<br />&nbsp; &nbsp; &nbsp; low =0;     high =n-1;    // 置区间初值<br />&nbsp; &nbsp; &nbsp; while (low&lt;=high) <br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mid = (low+high)/2 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (x == a[mid])   break;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 找到待查记录 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (x&lt;a[mid])  high=mid-1;&nbsp; &nbsp; &nbsp; &nbsp; // 继续在前半区间进行检索 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else  low=mid+1;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 继续在后半区间进行检索<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; if&nbsp; (low&lt;=high)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 找到待查记录 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cout&lt;&lt;x&lt;&lt;" is a["&lt;&lt;mid&lt;&lt;"]"&lt;&lt;endl;<br />&nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;"No found!"&lt;&lt;endl;<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p style="text-align: left;"><span style="font-size: 16px;"><strong>【例2】求平方根 。</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; 编写一个程序计算x的平方根，x保证是一个非负整数。 </p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 已求5的平方根为例，说明应用二分法求平方根的思路。</p>
<p>&nbsp; &nbsp; &nbsp; 设&nbsp; f(x)=x<sup>2</sup>&nbsp;，在&nbsp;x&isin;[1,5]的范围内， f(x) 随着&nbsp;x的增大而增大的（单调递增），这就给二分法创造了条件。</p>
<p>&ensp;&ensp;&ensp;&ensp;首先，令浮点型 left 和 right 的初值分别为1和5，然后通过比较 left 和 right 的中点 mid 处 &nbsp;f(x) 的数值与5的大小来选择子区间进行逼近。有以下两种情况：</p>
<p>&nbsp; &nbsp; &nbsp; 1）如果&nbsp; f(mid)&gt;5，说明当前mid比5的平方根大，应当在&nbsp;[left,mid]的范围内继续逼近，故令&nbsp; right=mid;</p>
<p>&nbsp; &nbsp; &nbsp; 2）如果&nbsp;f(mid)&lt;5，说明当前 mid比5的平方根小，应当在&nbsp;[mid, right]的范围内继续逼近，故令&nbsp; left=mid。</p>
<p>&ensp;&ensp;&ensp;当&nbsp; right&minus;left&lt;10<sup>&minus;5</sup>时结束，此时已经满足精度要求，即为所求的近似值。</p>
<p>&nbsp; &nbsp; &nbsp;（2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />double f(double x)</p>
<p style="margin-left: 30px;"> {<br />&nbsp; &nbsp; return x * x;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; int x;<br />&nbsp; &nbsp; double left,right,mid;<br />&nbsp; &nbsp; scanf("%d",&amp;x);<br />&nbsp; &nbsp; while (x!=0)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left=1.0, right=1.0*x;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while ((right-left)&gt;1e-5)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid=(left+right)/2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (f(mid)&lt;x) left=mid;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else right=mid;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%.4f\n",mid);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;x);<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p><strong><span style="font-size: 16px;">【例3】木材加工 。</span></strong><br />&nbsp; &nbsp; &nbsp; 木材厂有一些原木，现在想把这些木头切割成一些长度相同的小段木头（木头有可能有剩余），需要得到的小段的数目是事先给定的，切割时希望得到的小段越长越好。<br />&nbsp; &nbsp; &nbsp; 编写程序，输入原木的数目 N 和需要得到的小段的数目 K以及各段原木的长度，计算能够得到的小段木头的最大长度。 <br />&nbsp; &nbsp; &nbsp; 木头长度的单位是 cm。原木的长度都是正整数，要求切割得到的小段木头的长度也是正整数。</p>
<p>&nbsp; &nbsp; &nbsp; 例如，输入原木的数目 N 和需要得到的小段的数目 K 分别为3和8，输入的3段原木的长度分别为124、224和319，则能够切割得到的小段的最大长度为 74。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。<br />&nbsp; &nbsp; &nbsp; 这个问题可以采用二分法进行解决。<br />&nbsp; &nbsp; &nbsp; 设left是切割的小段木头的最短长度，right是最大长度，初始时，left为0，right为最长的原木长度加1。<br />&nbsp; &nbsp; &nbsp; 每次取left和right的中间值mid（mid = (left + right) / 2）进行尝试，测试采用当前长度mid进行加工，能否切割出需要的段数K，测试算法描述为：<br />&nbsp; &nbsp; &nbsp; num = 0; <br />&nbsp; &nbsp; &nbsp; for (i = 0; i &lt; n; i++) <br />&nbsp; &nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (num &gt;= k) break; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num = num + len[i] / mid ; <br />&nbsp; &nbsp; &nbsp; } <br />&nbsp; &nbsp; &nbsp; 如果当前mid值可以加工出所需段数（即num &gt;= k），说明当前mid值偏小，可能有余量，就增大mid值继续试（通过让left = mid的方法来增大mid）；不符合要求，当前mid值加工不出所需段数，显然mid偏大了，就减小mid值继续试（通过让right = mid的方法来减小mid）。直到left +1&gt;= right结束尝试，所得的left值就是可以加工出的小段木头的最大长度。<br />&nbsp; &nbsp;（2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;iostream&gt;<br />using namespace std;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n, k, len[10000], i, left, right, mid,num; <br />&nbsp; &nbsp; &nbsp; cout&lt;&lt;"请输入原木的数目 N 和需要得到的小段的数目 K ："&lt;&lt;endl; <br />&nbsp; &nbsp; &nbsp; cin&gt;&gt;n&gt;&gt;k; <br />&nbsp; &nbsp; &nbsp; right = 0; <br />&nbsp; &nbsp; &nbsp; cout&lt;&lt;"请输入各段原木的长度："&lt;&lt;endl;<br />&nbsp; &nbsp; &nbsp; for (i = 0; i &lt; n; i++) <br />&nbsp; &nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;len[i]; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (right &lt; len[i]) right = len[i]; <br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; right++; <br />&nbsp; &nbsp; &nbsp; left = 0   ; <br />&nbsp; &nbsp; &nbsp; while ( left + 1  &lt; right) <br />&nbsp; &nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid = (left + right) / 2; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num = 0; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; n; i++) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (num &gt;= k) break; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num = num + len[i] / mid ; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ( num &gt;= k ) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left = mid;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right = mid; <br />&nbsp; &nbsp; &nbsp; &nbsp;} <br />&nbsp; &nbsp; &nbsp; cout&lt;&lt;"能够切割得到的小段的最大长度为 "&lt;&lt;left&lt;&lt;endl; <br />&nbsp; &nbsp; &nbsp; return 0; <br />} </p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>