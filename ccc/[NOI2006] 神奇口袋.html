<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[NOI2006] 神奇口袋' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[NOI2006] 神奇口袋</center></div><div class='banquan'>原文出处:本文由博客园博主nosta提供。<br/>
原文连接:https://www.cnblogs.com/nosta/p/10923381.html</div><br>
    <p>之前遇到的题完全无印象，倒是本地有一份题解，略作修改放上来。</p>
<h1 id="noi2006神奇口袋">[NOI2006]神奇口袋</h1>
<h2 id="题目">题目</h2>
<p>一个口袋中先放有<span class="math inline">\(a_i\;(1\le a_i,\;1\le i\le t)\)</span>个<span class="math inline">\(i\)</span>颜色的球。若在第<span class="math inline">\(i\)</span>次从中取到的球色为<span class="math inline">\(C_i\)</span>，则要向口袋中放入<span class="math inline">\(d\)</span>个与之同色的求，取到的球也要放回。每个球被取到的几率相同。</p>
<p>先给出<span class="math inline">\(Q=\{(x_n,y_n)\}\)</span>，询问全部满足在第<span class="math inline">\(x_i\)</span>次取球时取到颜色<span class="math inline">\(y_i\)</span>的几率。</p>
<h2 id="分析">分析</h2>
<h3 id="结论">结论</h3>
<p>假设当前<span class="math inline">\(Q\)</span>中的<span class="math inline">\(x\)</span>有序。</p>
<h4 id="结论一-q中x离散后对结果无影响">结论一： <span class="math inline">\(Q\)</span>中<span class="math inline">\(x\)</span>离散后对结果无影响</h4>
<p>证明：</p>
<p>设在第<span class="math inline">\(k\)</span>次取球时，颜色<span class="math inline">\(c\)</span>的数目为<span class="math inline">\(a[c]\)</span>，球的总数为<span class="math inline">\(tot\)</span>。可以得出：</p>
<p>在第<span class="math inline">\(k\)</span>次取到<span class="math inline">\(c\)</span>的几率为<span class="math inline">\(P_k=\dfrac{a[c]}{tot}\)</span> 。又因为</p>
<ul>
<li>在第<span class="math inline">\(k\)</span>次取到<span class="math inline">\(c\)</span>且在第<span class="math inline">\(k+1\)</span>次也取到的几率为<span class="math inline">\(P_1=\dfrac{a[c]}{tot}\times\dfrac{a[c]+d}{tot+d}\)</span>。</li>
<li>在第<span class="math inline">\(k\)</span>次没取到<span class="math inline">\(c\)</span>，但在第<span class="math inline">\(k+1\)</span>取到的几率为<span class="math inline">\(P_2=\dfrac{tot-a[c]}{tot}\times\dfrac{a[c]}{tot+d}\)</span>。</li>
</ul>
<p>故在第<span class="math inline">\(k+1\)</span>次取到<span class="math inline">\(c\)</span>的几率为<span class="math inline">\(P_{k+1}=P_1+P_2=\dfrac{(tot+d)\times a[c]}{(tot+d)tot}=\dfrac{a[c]}{tot}\)</span>。</p>
<p>即<span class="math inline">\(P_k=P_{k+1}\)</span>。再经过简单归纳，即可证明结论一成立。</p>
<h4 id="结论二-q中y的出现顺序对结果无影响">结论二： <span class="math inline">\(Q\)</span>中<span class="math inline">\(y\)</span>的出现顺序对结果无影响</h4>
<p>证明：</p>
<p>设在第<span class="math inline">\(i\)</span>次取球时，颜色<span class="math inline">\(c\)</span>的数目为<span class="math inline">\(a[c]\)</span>，球的总数为<span class="math inline">\(tot\)</span>。对于<span class="math inline">\(y_i,y_{i+1}(1\le i&lt;n)\)</span>，有</p>
<ul>
<li>若<span class="math inline">\(y_i=y_{i+1}\)</span>，显然无影响</li>
<li>若<span class="math inline">\(y_i\not=y_{i+1}\)</span>，则
<ul>
<li>交换之前两组<span class="math inline">\((x,y)\)</span>都成立的几率为<span class="math inline">\(P_1=\dfrac{a[y_i]}{tot}\times\dfrac{a[y_{i+1}]}{tot+d}\)</span>。</li>
<li>交换之后两组<span class="math inline">\((x,y)\)</span>都成立的几率为<span class="math inline">\(P_2=\dfrac{a[y_{i+1}]}{tot}\times\dfrac{a[y_i]}{tot+d}\)</span>。</li>
</ul></li>
</ul>
<p>发现<span class="math inline">\(P_1=P_2\)</span>，即此时也无影响。同样的，略作归纳可知本结论成立。</p>
<h3 id="算法">算法</h3>
<p>由以上两个结论的得出<span class="math inline">\(x\)</span>的顺序无影响，<span class="math inline">\(y\)</span>的循序也无影响。故可以直接在读入<span class="math inline">\(Q\)</span>时对<span class="math inline">\(y\)</span>依次处理即可。</p>
<p><strong>注意</strong>此题需要用到高精度、GCD。为了方便处理，可以对分子分母进行分解。最终将两个数的各个因子合起来。</p>
<h2 id="实例">实例</h2>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=1010;
const int P=200000;
struct BigInt {
    int s[P],ws;
    BigInt(){s[1]=1;ws=1;}
    void Multi(int x) {
        for(int i=1;i&lt;=ws;++i)s[i]=s[i]*x;
        for(int i=1;i&lt;=ws;++i)s[i+1]+=s[i]/10,s[i]%=10;
        while(s[ws+1])++ws,s[ws+1]=s[ws]/10,s[ws]%=10;
    }
    void output(){for(int i=ws;i;--i) printf(&quot;%d&quot;,s[i]);}
}U,D;
int t,n,d,tot,a[N];
int cntp,pri[P],num[P];
bool notp[P]={1,1};
void addon(int x,int w) {
    for(int i=1; x&amp;&amp;i&lt;=cntp; ++i) {
        while(x%pri[i]==0) num[i]+=w, x/=pri[i];
    }
}
int main() {
    for(int i=2; i&lt;P; ++i) {
        if(!notp[i]) pri[++cntp]=i;
        for(int j=1; j&lt;=cntp&amp;&amp;pri[j]*i&lt;P; ++j) {
            notp[i*pri[j]]=1;
            if(i%pri[j]==0) break;
        }
    }
    scanf(&quot;%d%d%d&quot;,&amp;t,&amp;n,&amp;d);
    for(int i=1; i&lt;=t; ++i) {
        scanf(&quot;%d&quot;,&amp;a[i]);
        tot+=a[i];
    }
    for(int i=1,x,y; i&lt;=n; ++i) {
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        if(!a[y]) {puts(&quot;0/1&quot;); return 0;}
        addon(a[y],1);
        addon(tot,-1);
        a[y]+=d, tot+=d;
    }
    for(int i=1; i&lt;=cntp; ++i) {
        for(; num[i]&gt;0; --num[i]) U.Multi(pri[i]);
        for(; num[i]&lt;0; ++num[i]) D.Multi(pri[i]);
    }
    U.output();
    putchar(&#39;/&#39;);
    D.output();
    return 0;
}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>