<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修POJ2431 优先队列+贪心 - biaobiao88' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>POJ2431 优先队列+贪心 - biaobiao88</center></div><div class='banquan'>原文出处:本文由博客园博主恶魔岛提供。<br/>
原文连接:https://www.cnblogs.com/biaobiao88/p/11789263.html</div><br>
    <p>以下代码可对结构体数组中的元素进行排序，也差不多算是一个小小的模板了吧</p>
<div class="cnblogs_Highlighter">
<pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node
{
	int x;
	int y;
	bool operator&lt;(const node &amp;a) const//此操作是对操作符"&lt;"进行重构 
	{
		return x &lt; a.x;//对结构体数组x进行从大到小排序 
//		return y &gt; a.y;//对结构体数组y进行从大到小排序 
	}
}s[100];

//bool cmp(int x,int y)//这个重构函数不能用在结构体数组中 
//{
//	return x &gt; y;
//}

int main()
{
	int n;
	cin &gt;&gt; n;
	for(int i = 0;i &lt; n;i++)
		cin &gt;&gt; s[i].x &gt;&gt; s[i].y;
	
	sort(s,s+n);
	for(int i = 0;i &lt; n;i++)
		cout &lt;&lt; s[i].x &lt;&lt; " " &lt;&lt; s[i].y &lt;&lt; endl;
	cout &lt;&lt; endl;
	return 0;
}
</pre>
</div>
<p>运行结果：<img src="./images/POJ2431 优先队列+贪心 - biaobiao880.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;也可以这样</p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> node
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> y;
    </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>&lt;(<span style="color: #0000ff;">const</span> node &amp;a) <span style="color: #0000ff;">const</span><span style="color: #000000;"> 
    {
        </span><span style="color: #0000ff;">return</span> x &gt;<span style="color: #000000;"> a.x; 
    }
}s[</span><span style="color: #800080;">100</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> cmp(node m,node n)
{
    m.x </span>&lt;<span style="color: #000000;"> n.x;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    cin </span>&gt;&gt;<span style="color: #000000;"> n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>;i &lt; n;i++<span style="color: #000000;">)
        cin </span>&gt;&gt; s[i].x &gt;&gt;<span style="color: #000000;"> s[i].y;
    
    sort(s,s</span>+<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>;i &lt; n;i++<span style="color: #000000;">)
        cout </span>&lt;&lt; s[i].x &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; s[i].y &lt;&lt;<span style="color: #000000;"> endl;
    cout </span>&lt;&lt;<span style="color: #000000;"> endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>对优先队列的应用，POJ2431是一个很好的题目，此题用了优先队列+贪心</p>
<div class="ptt" lang="en-US">Expedition</div>
<div class="plm">
<table align="center">
<tbody>
<tr>
<td><strong>Time Limit:</strong>&nbsp;1000MS</td>
<td width="10px">&nbsp;</td>
<td><strong>Memory Limit:</strong>&nbsp;65536K</td>
</tr>
<tr>
<td><strong>Total Submissions:</strong>&nbsp;29720</td>
<td width="10px">&nbsp;</td>
<td><strong>Accepted:</strong>&nbsp;8212</td>
</tr>
</tbody>
</table>
</div>
<p class="pst">Description</p>
<div class="ptx" lang="en-US">A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck's fuel tank. The truck now leaks one unit of fuel every unit of distance it travels.<br /><br />To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop).<br /><br />The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000).<br /><br />Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all.</div>
<p class="pst">Input</p>
<div class="ptx" lang="en-US">* Line 1: A single integer, N<br /><br />* Lines 2..N+1: Each line contains two space-separated integers describing a fuel stop: The first integer is the distance from the town to the stop; the second is the amount of fuel available at that stop.<br /><br />* Line N+2: Two space-separated integers, L and P</div>
<p class="pst">Output</p>
<div class="ptx" lang="en-US">* Line 1: A single integer giving the minimum number of fuel stops necessary to reach the town. If it is not possible to reach the town, output -1.</div>
<p class="pst">Sample Input</p>
<pre class="sio">4
4 4
5 2
11 5
15 10
25 10
</pre>
<p class="pst">Sample Output</p>
<pre class="sio">2
</pre>
<p class="pst">Hint</p>
<div class="ptx" lang="en-US">INPUT DETAILS:<br /><br />The truck is 25 units away from the town; the truck has 10 units of fuel. Along the road, there are 4 fuel stops at distances 4, 5, 11, and 15 from the town (so these are initially at distances 21, 20, 14, and 10 from the truck). These fuel stops can supply up to 4, 2, 5, and 10 units of fuel, respectively.<br /><br />OUTPUT DETAILS:<br /><br />Drive 10 units, stop to acquire 10 more units of fuel, drive 4 more units, stop to acquire 5 more units of fuel, then drive to the town.</div>
<p class="pst">Source</p>
<div class="ptx" lang="en-US"><a href="http://poj.org/searchproblem?field=source&amp;key=USACO+2005+U+S+Open+Gold">USACO 2005 U S Open Gold</a></div>
<div class="ptx" lang="en-US">思路：贪心思路为，在假设汽车一路向前，在途中有经过加油站的话，把加油站进行排序，符合条件的加油站中的汽油从大到小排序，存到优先队列中，在汽车用完时，即随时可以在队列的队头取汽油，使得汽车尽可能加最多的汽油，停最少次</div>
<div class="ptx" lang="en-US">
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;<span style="color: #000000;">
#include</span>&lt;queue&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> node
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> dis;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> fuel;
    </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>&lt;(<span style="color: #0000ff;">const</span> node &amp;a) <span style="color: #0000ff;">const</span><span style="color: #008000;">//</span><span style="color: #008000;">此重构操作，请参考上面的代码 </span>
<span style="color: #000000;">    {
        </span><span style="color: #0000ff;">return</span> dis &gt; a.dis;<span style="color: #008000;">//</span><span style="color: #008000;">返回dis，说明是对dis这个数组进行排序操作 </span>
<span style="color: #000000;">    }
}stop[</span><span style="color: #800080;">10005</span><span style="color: #000000;">];

priority_queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> que;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,l,p;
    cin </span>&gt;&gt;<span style="color: #000000;"> n;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>;i &lt; n;i++<span style="color: #000000;">)
        cin </span>&gt;&gt; stop[i].dis &gt;&gt;<span style="color: #000000;"> stop[i].fuel;
    cin </span>&gt;&gt; l &gt;&gt;<span style="color: #000000;"> p;
    </span><span style="color: #0000ff;">int</span> ans = <span style="color: #800080;">0</span><span style="color: #000000;">;
    sort(stop,stop </span>+ n);<span style="color: #008000;">//</span><span style="color: #008000;">对加油站距离dis数组进行从大到小排序 </span>
    que.push(p);<span style="color: #008000;">//</span><span style="color: #008000;">队列自动从大到小排序，即排序汽油p </span>
    <span style="color: #0000ff;">int</span> temp = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span>(l &gt; <span style="color: #800080;">0</span> &amp;&amp; !que.empty())<span style="color: #008000;">//</span><span style="color: #008000;">卡车未到达终点并且卡车在当前汽油用完前有路过加油站 </span>
<span style="color: #000000;">    {
        ans</span>++;<span style="color: #008000;">//</span><span style="color: #008000;">卡车停下加一次油计数器 </span>
        l -= que.top();<span style="color: #008000;">//</span><span style="color: #008000;">加油，更新一次汽油用尽后距离终点的距离 </span>
        que.pop();<span style="color: #008000;">//</span><span style="color: #008000;">删除已用的加油站的汽油 </span>
        <span style="color: #0000ff;">while</span>(l &lt;= stop[temp].dis &amp;&amp; temp &lt; n)<span style="color: #008000;">//</span><span style="color: #008000;">卡车距离终点的距离小于等于最近加油站的距离并且这个加油站的位置在终点加油站前面，这里假设终点也为一个加油站。//l &lt;= stop[i].dis意思是卡车能经过离它最近的一个加油站，如果大于的话，说明卡车停下时没有加油站可加油&nbsp; </span>
            que.push(stop[temp++].fuel);<span style="color: #008000;">//</span><span style="color: #008000;">将经过的加油站压入优先队列,要使用的时候就取队头元素（队头中存的汽油最大） //如果经过加油站，则一定要将该加油站的可加油量添加到优先队列当中&nbsp;</span>
<span style="color: #000000;">    }//temp++说明离卡车最近的加油站，卡车继续往前开，加油站点也依次往后，所以变量temp需要自增
    </span><span style="color: #0000ff;">if</span>(l &gt; <span style="color: #800080;">0</span>)<span style="color: #008000;">//</span><span style="color: #008000;">如果卡车距离终点的距离还大于0的话，即通过不了终点 </span>
        cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">-1</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl;
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        cout </span>&lt;&lt; ans - <span style="color: #800080;">1</span> &lt;&lt; endl;<span style="color: #008000;">//</span><span style="color: #008000;">在起点深度时候记为一次加油，这里需要减去1 </span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>其中代码有详细的注释，希望注释能加深理解</p>
<p>代码参考于：博客园-小小菜鸟</p>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>