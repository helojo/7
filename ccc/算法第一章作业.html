<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修算法第一章作业' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>算法第一章作业</center></div><div class='banquan'>原文出处:本文由博客园博主丿不落良辰提供。<br/>
原文连接:https://www.cnblogs.com/Remilia-Scarlet/p/11440472.html</div><br>
    <p><strong><span style="font-family: 宋体; font-size: 18pt;">一：代码规范</span></strong></p>
<p><span style="font-family: 宋体; font-size: 18pt;">　　<span style="font-size: 16px;">参考 ：</span></span><span style="font-family: 宋体; font-size: 16px;">https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/#</span></p>
<p><span style="font-size: 16px;">　　<strong><span style="font-size: 18px;">1 . 头文件</span></strong></span></p>
<p><span style="font-size: 16px;"><strong><span style="font-size: 18px;">　　　　1.1. Self-contained 头文件</span></strong></span></p>
<p><span style="font-size: 16px;"><strong><span style="font-size: 18px;">　　</span></strong></span><span style="font-size: 16px;"><span style="font-size: 18px;">头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以&nbsp;<code><span class="pre">.h</span></code>&nbsp;结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以&nbsp;<code><span class="pre">.inc</span></code>&nbsp;结尾。不允许分离出&nbsp;<code><span class="pre">-inl.h</span></code>&nbsp;头文件的做法.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>1.2. #define 保护</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>所有头文件都应该使用&nbsp;<code><span class="pre">#define</span></code>&nbsp;来防止头文件被多重包含, 命名格式当是:&nbsp;<code><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></code>&nbsp;.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>1.3.&nbsp; 前置声明</strong><br /></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>尽可能地避免使用前置声明。使用&nbsp;<code><span class="pre">#include</span></code>&nbsp;包含需要的头文件即可。</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>1.4. 内联函数</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>1.5. #include 的路径及顺序</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的&nbsp;<cite>.h</cite>, 本项目内的&nbsp;<cite>.h</cite>.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　<strong>2 . 作用域</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　2.1. 命名空间<br /></strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　鼓励在&nbsp;<code><span class="pre">.cc</span></code>&nbsp;文件内使用匿名命名空间或&nbsp;<code><span class="pre">static</span></code>&nbsp;声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>2.2. 匿名命名空间和静态变量</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　在&nbsp;<code><span class="pre">.cc</span></code>&nbsp;文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为&nbsp;<code><span class="pre">static</span></code>&nbsp;。但是不要在&nbsp;<code><span class="pre">.h</span></code>&nbsp;文件中这么做。</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　<strong>　2.3. 非成员函数、静态成员函数和全局函数</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>2.4. 局部变量</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　<strong>　2.5. 静态和全局变量</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　<strong>　3.类</strong><br /></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　3.1. 构造函数的职责</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>3.2.&nbsp; 隐式类型转换</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用&nbsp;<code><span class="pre">explicit</span></code>&nbsp;关键字.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>3.3. 可拷贝类型和可移动类型</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　<strong>　3.4. 结构体 VS. 类</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>仅当只有数据成员时使用&nbsp;<code><span class="pre">struct</span></code>, 其它一概使用&nbsp;<code><span class="pre">class</span></code>.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　3.5. 继承</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;&lt;Design Patterns&gt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为&nbsp;<code><span class="pre">public</span></code>&nbsp;继承.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　<strong>4.格式</strong><br /></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　4.1. 行长度</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>每一行代码字符数不超过 80.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　4.2. 条件语句</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>倾向于不在圆括号内使用空格. 关键字&nbsp;<code><span class="pre">if</span></code>&nbsp;和&nbsp;<code><span class="pre">else</span></code>&nbsp;另起一行.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　举例：if (condition) {</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　<strong>　4.3. 布尔表达式</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　</strong>　如果一个布尔表达式超过标准行宽</span></span><span style="font-size: 16px;"><span style="font-size: 18px;">, 断行方式要统一 一下.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　如：if (..... &amp;&amp;</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　　..... &amp;&amp;</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　&nbsp; &nbsp; .....) {<br /></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　&nbsp; &nbsp;....</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　}</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　4.4. 函数声明与定义</span></span></p>
<p>　　注意以下几点:</p>
<p>&nbsp;</p>
<ul class="simple">
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>




</ul>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　<strong>　5. 注释</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　　　5.1. 类注释</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;">　　　　<strong>5.2. 实现注释</strong></span></span></p>
<p><span style="font-size: 16px;"><span style="font-size: 18px;"><strong>　　</strong>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</span></span></p>
<pre><code><span class="k"><br /><strong><span style="font-size: 18pt;">二、《数学之美系列十三 &mdash; 信息指纹及其应用》 读后感</span></strong></span></pre>
<p>&nbsp;　　<span style="font-size: 18px;">任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其他信息的指纹。这种映射真是太美妙了，把一个一百多个字符的网址随机地映射到128二进制位的正数中，这样子处理后就可以把存储网址的内存需求量从原来的一百多个字节转变成16个字节，而这种产生随机数的算法，是其中的核心。数学的加减乘除，只要按照一定的规则处理，就可以形成一种好的映射，让信息指纹不可逆，更好地保障了用户的安全。学好数学，灵活运用数学规律，可以帮助我们更好地解决现实中的问题。</span></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>