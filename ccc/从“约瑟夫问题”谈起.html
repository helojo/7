<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修从“约瑟夫问题”谈起' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>从“约瑟夫问题”谈起</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11254070.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 约瑟夫问题是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。</p>
<p>&nbsp; &nbsp; &nbsp; 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想自杀。为避免与其他39个决定自杀的犹太人发生冲突，Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p>
<p>&nbsp; &nbsp; &nbsp; 17世纪的法国数学家加斯帕在《数目的游戏问题》中讲了这样一个故事：15个教徒和15 个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了一个办法：30个人围成一圆圈，从第一个人开始依次报数，每数到第九个人就将他扔入大海，如此循环进行，直到仅余15个人为止。问怎样的​排法，才能使每次投入大海的都是非教徒。</p>
<p><strong><span style="font-size: 16px;">【例1】约瑟夫问题。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; N个人围成一圈，从某个人开始，按顺时针方向从1开始依次编号。从编号为1的人开始顺时针<span style="font-family: 宋体;">&ldquo;</span>1，2，&hellip;M<span style="font-family: 宋体;">&rdquo;</span>报数，报到M的人退出圈子。这样不断循环下去，圈子里的人将不断减少。由于人的个数是有限的，因此最终会剩下一个人，该人就是优胜者。输入N和M，输出出圈顺序。<br />例如，N=6、M=5，出圈的顺序是：5，4，6，2，3，1。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 为输出出圈顺序，采用一个数组来进行模拟。</p>
<p>&nbsp; &nbsp; &nbsp; 定义int circle[N+1]，并按circle[i]=i+1的方式赋予各元素初值。该值代表两个含义：1）值为0，代表编号i+1的人不再圈中；2）值非0，代表圈中第i个位置的人编号为i+1。</p>
<p>&nbsp; &nbsp; &nbsp; 定义变量i代表报数位置的流动，i的初值为0，代表编号为1的人的位置，i的变化方式为：</p>
<p>&nbsp;i=(i+1)%(n)，即0--&gt;1--&gt;2&hellip;&hellip;-&gt;n-1&nbsp; -&gt;0--&gt;1&hellip;&hellip;。</p>
<p>&nbsp; &nbsp; &nbsp;i流动到了位置i后，该位置的人若已出圈（circle[i]==0），显然无法报数，得跳过该位置；若该位置的人在圈中，则报数（定义一个表示报数的变量p，初值为0，每次报数p++）。</p>
<p>&nbsp; &nbsp; 当报数到m（即p==m）时，位置i的人出圈，记录出圈人数cnt++，同时p置为0。当出圈人数等于N时循环结束。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,i,p,cnt;<br />&nbsp; &nbsp; &nbsp; int circle[50];<br />&nbsp; &nbsp; &nbsp; while (scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=0;i&lt;n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;circle[i]=i+1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i=0;      // 报数指示<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=0;      // 报数计数器<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt=0;    // 出队人数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (cnt&lt;n)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (circle[i]!=0) p++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (p==m) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d  ",circle[i]); <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; circle[i]=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i=(i+1)%(n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">下面我们从例1的基础上进行扩展讨论。</p>
<p style="margin-left: 30px;">例如，运行例1的程序时，输入41&nbsp; 3，则输出为：</p>
<p>3&nbsp; 6&nbsp; 9&nbsp; 12&nbsp; 15&nbsp; &nbsp;18&nbsp; &nbsp;21&nbsp; &nbsp;24&nbsp; &nbsp;27&nbsp; &nbsp;30&nbsp; &nbsp;33&nbsp; &nbsp;36&nbsp; &nbsp;39&nbsp; &nbsp;1&nbsp; &nbsp;5&nbsp; &nbsp;10&nbsp; &nbsp;14&nbsp; &nbsp;19&nbsp; &nbsp;23&nbsp; &nbsp;28&nbsp; &nbsp;32&nbsp; &nbsp;37</p>
<p>  41&nbsp; 7&nbsp; 13&nbsp; 20&nbsp; 26&nbsp; 34&nbsp; 40&nbsp; 8&nbsp; 17&nbsp; 29&nbsp; 38&nbsp; 11&nbsp; 25&nbsp; 2&nbsp; 22&nbsp; 4&nbsp; 35&nbsp; 16&nbsp; 31</p>
<p>&nbsp; &nbsp; &nbsp; 为这个输出结果进行的模拟是需要耗时的。实际上，在大多数问题中，我们不关心中间的结果，只关心某个最终结果。例如，在Josephus 的故事中，Josephus 和他的朋友不想自杀，Josephus 需要关心的是最后一个和倒数第2个出圈的编号是多少，至于中间过程（39个犹太人谁先自杀，谁后自杀）对Josephus 来说无意义。因此，Josephus 需要的是快速确定最后一个和倒数第2个出圈的编号，然后站到对应位置即可。而无需耗时模拟整个过程。</p>
<p><strong><span style="font-size: 16px;">【例2】猴子选大王。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 一堆猴子都有编号，编号是1，2，3 ...m，这群猴子(m个)按照1~m的顺序围坐一圈，从第1开始数，每数到第N个，该猴子就要离开此圈，这样依次下来，直到圈中只剩下最后一只猴子，则该猴子为大王。已知猴子数m和报数间隔n（设1&lt;=n&lt;=m&lt;=50），问编号为多少的猴子当大王？</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路1。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;将例1的源程序略作修改，增加一个变量last记录最后获胜者编号，不输出中间过程。显然，</p>
<p>if (cnt==n) last=circle[i];</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序1。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp;int n,m,i,p,cnt,last;<br />&nbsp; &nbsp; &nbsp;int circle[50];<br />&nbsp; &nbsp; &nbsp;while (scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=0;i&lt;n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;circle[i]=i+1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i=0;      // 报数指示<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=0;      // 报数计数器<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt=0;    // 出队人数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (cnt&lt;n)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (circle[i]!=0) p++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p==m) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (cnt==n) last=circle[i];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;circle[i]=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i=(i+1)%(n);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",last);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">（3）编程思路2。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;源程序1中采用数组模拟，由于猴子在圈中还是出圈是通过数组元素circle[i]的值非0还是0来判断，位置并未真正删除，因此当n和m很大时，程序的执行效率很低。例如，仅求最后一个出圈的元素，循环就得执行m*n次（p从1报到m，每次报数流动i得走完整一圈，其中n-1个已出圈，圈中仅一个元素）。</p>
<p>&nbsp; &nbsp; &nbsp; 为提高运行效率，可以考虑采用循环链表来进行模拟，这样每次出圈就将链表中的相应元素删除。循环链表只剩最后一个元素时，输出胜者编号。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（4）源程序2。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />struct  Jose<br />{ </p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; int code;                // 编号<br />&nbsp; &nbsp; &nbsp; Jose *next;<br />};<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; Jose *head,*p1,*p2;<br />&nbsp; &nbsp; &nbsp; int n,m,i,cnt,tmp;<br />&nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; while (n!=0 &amp;&amp; m!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head=new Jose;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head-&gt;code=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2=head;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=2;i&lt;=n;i++)  // 创建循环链表<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1=new Jose;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1-&gt;code=i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2-&gt;next=p1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2=p1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2-&gt;next=head;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1=head;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt=n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (cnt&gt;1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp=m%cnt;                // 提高效率之举，当m大于圈中人数时会循环多圈，可以不用<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tmp==0) tmp=cnt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (i&lt;tmp)&nbsp; &nbsp; &nbsp; &nbsp;// 报数m-1次 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p2=p1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p1=p1-&gt;next;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p2-&gt;next=p1-&gt;next;      // 报m的结点出圈<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete p1;              // 释放出圈结点的空间<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt--;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p1=p2-&gt;next;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",p1-&gt;code);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete p1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">（5）编程思路3。</p>
<p>&nbsp; &nbsp; &nbsp; 本例中的源程序2相比源程序1可以提高运行效率，但毕竟也是采用过程模拟，因此对于n和m较大的情况，效率仍然不高。有没有可以根据n和m的值直接推出最后出圈人编号的办法呢？</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;为了讨论方便，先把问题稍微改变一下，并不影响原意。</p>
<p>　　问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。<br />　　我们知道第1个人（编号一定是(m-1)%n）出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:<br />　　k , k+1 , k+2&nbsp; ...&nbsp; n-2 , n-1 , 0 , 1 , 2 , ... k-2<br />　　并且从k开始报0。<br />　　现在我们把他们的编号做一下转换：<br />　　k --&gt; 0&nbsp; &nbsp; &nbsp;　　 k+1 --&gt; 1　&nbsp; 　k+2 --&gt; 2<br />　　&nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp;&nbsp;　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...<br />　　k-3 --&gt; n-3　　k-2 --&gt; n-2<br />　　变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据转换把这个x变回去不刚好就是n个人情况的解吗？</p>
<p>&nbsp; &nbsp; &nbsp; 下面我们来推导变回去的公式。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;序列1： 1 , 2 , 3 , 4 ,&nbsp; &hellip;k-1 , k , k+1&nbsp;&nbsp;,&hellip;， n-2 , n-1 , n<br />　　序列2： 1 , 2 , 3 , 4 , &hellip; k-1 ,&nbsp; k+1 , &hellip; , n-2 , n-1 , n<br />　　序列3：&nbsp; k+1 , k+2 , k+3 , &hellip;,&nbsp; n-2 , n-1 , n ,&nbsp; 1 , 2 , 3 ,&hellip; , k-2 , k-1<br />　　序列4： 1 ,&nbsp; 2 , 3 , 4 , &hellip; , 5 , 6 , 7 , 8 , &hellip;, n-2 , n-1<br />　　∵&nbsp; k=m%n;</p>
<p>&nbsp; &nbsp;　&there4;&nbsp; x' = x+k = x+ m%n ;&nbsp; &nbsp;而&nbsp; x+ m%n 可能大于n</p>
<p>　　&there4; x'=&nbsp; (x+ m%n)%n =&nbsp; (x+m)%n 。<br />　　如何知道(n-1)个人报数的问题的解f(n-1)呢？ 显然只要知道(n-2)个人的解f(n-2)就行了。(n-2)个人的解呢？当然是先求f(n-3) ---- 这显然就是一个倒推问题！<br />　　令 f[i] 表示i个人玩报m退出的约瑟夫环游戏的最后胜利者的编号，则有递推公式：<br />　　f[1] = 0 ;<br />　　f[i] = (f[i-1]+m)%i;&nbsp; &nbsp; &nbsp;(i&gt;1)<br />　　有了这个递推公式，我们就很容易求得n个人报m退出的约瑟夫问题的最后胜利者编号f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1即可。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;编写程序时，我们可以采用数组递推以便保存中间结果，也可以不保存中间任何结果采用迭代直接得到最后胜利者编号。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（6）采用迭代方式实现的源程序3。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,i,s;<br />&nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; while (n!=0 &amp;&amp; m!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=2;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s=(s+m) % i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",s+1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">（7）采用递推方式实现的源程序4。&nbsp;</p>
<p style="margin-left: 30px;">// 采用打表的方式，先将所有的值求出来保存在二维数组f[51][51]中。<br />// f[n][m]的值代表n个人报m游戏的最后胜利者编号。<br />// 则有 f[i][m]=0,  (i=1)<br />//        f[i][m]= (f[i-1][m]+m)%i  (i&gt;1)   <br />#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp;int n,m,i,j,f[51][51];<br />&nbsp; &nbsp; &nbsp;for (i=1;i&lt;51;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f[1][i]=0;<br />&nbsp; &nbsp; &nbsp;for (i=1;i&lt;51;i++)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=2;j&lt;51;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[j][i]=(f[j-1][i]+i)%j;<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp;while (n!=0 &amp;&amp; m!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",f[n][m]+1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p><strong><span style="font-size: 16px;">&nbsp;【例3】城市断电。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 有n（3&lt;=n&lt;150）个城市围成圈，先将第1个城市（编号为1）断电，然后每隔m个城市使一个城市断电，直到剩下最后一个城市不断电。问使2号城市不断电的最小的m是多少？</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 采用例2的求最后胜利者的方式，对n个城市，从m=1开始搜索，若当前m可使2号城市作为胜利者，则m就是所求，否则m=m+1后，继续搜索。</p>
<p>&nbsp; &nbsp; &nbsp; 程序采用打表的方式，先将n=3~149的对应m值求出来并保存到数组ans[150]中。</p>
<p>&nbsp; &nbsp; &nbsp; 另外，需要注意的是第1个城市先断电了，2号城市相当第1个城市，也可以把问题看成编号从1~n-1的约瑟夫问题。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int ans[150],i,j,m,tmp;<br />&nbsp; &nbsp; &nbsp; for (i = 3;i&lt;150;i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp = 1;     // 注意第1个城市已经断电，相当从1~n-1个城市<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for&nbsp; (j = 2;j &lt; i; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = (tmp + m)%j;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if&nbsp; (tmp == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = j;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tmp == 1)   // 最后胜利者是2号城市</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // （编号为1一开始就断电，2号相当圈中第1个城市）<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans[i] = m;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;int n;<br />&nbsp; &nbsp; &nbsp;scanf("%d",&amp;n);<br />&nbsp; &nbsp; &nbsp;while (n!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",ans[n]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;n);<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p style="margin-left: 30px;">将此源程序提交给POJ 2244 <span style="font-family: 宋体;">&ldquo;</span>Eeny Meeny Moo<span style="font-family: 宋体;">&rdquo;，可以Accepted。</span></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;例2、例3采用约瑟夫递推公式，直接得到的是最后胜利者的编号，中间的出圈顺序就没得到。下面我们进一步讨论一下，能否不用模拟的方式，采用递推公式计算的方法，得到例1所示的出圈顺序呢？</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;设有n个人（0,...,n-1），报数m出圈，则第 i 轮出圈的人为</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(i)=(f(i-1)+m-1)%(n-i+1)&nbsp; &nbsp; (i&gt;=1),&nbsp; &nbsp; f(0)=0;&nbsp; &nbsp; f(i)&nbsp;表示当前子序列中要出圈的那个人（当前序列编号为0~(n-i));</p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 例如，设n=6,m=5</p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f(0)=0;</p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(1)=[ f(0)+5-1]%6=4;&nbsp; &nbsp; 子<span>序列（<span>0,1,2,3,4,5<span>）中的4&nbsp; （也就是实际序列（1，2，3，4，5，6）中的5）</span></span></span></p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(2)=[ f(1)+5-1]%5=3;&nbsp; &nbsp; &nbsp;子<span>序列（<span>0,1,2,3,5<span>）中的3&nbsp; &nbsp; &nbsp;（也就是实际序列（1，2，3，4，6）中的4）</span></span></span></p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(3)=[ f(2)+5-1]%4=3;&nbsp; &nbsp; &nbsp;子<span>序列（<span>0,1,2,5<span>）中的5<span>&nbsp; &nbsp; &nbsp; &nbsp; （也就是实际序列（1，2，3，6）中的6）</span></span></span></span></p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(4)=[ f(3)+5-1]%3=1;&nbsp; &nbsp; &nbsp;子<span>序列（<span>0,1,2<span>）中的1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（也就是实际序列（1，2，3）中的2）</span></span></span></p>
<p class="p0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(5)=[ f(4)+5-1]%2=1;&nbsp; &nbsp; &nbsp;子序列（0,2）中的1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （也就是实际序列（1，3）中的3）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(6)=[ f(5)+5-1]%1=0;&nbsp; &nbsp; &nbsp;子序列（0）中的0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （也就是实际序列（1）中的1）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 故得到的出圈顺序为：5，4，6，2，3，1。 结果正确。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 按照这样的思路，可以修改例1的源程序为：</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,i,j,cnt,circle[51],f[51];<br />&nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; while (n!=0 &amp;&amp; m!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0;i&lt;n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;circle[i]=i+1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[0]=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[i]=(f[i-1]+m-1)%(n-i+1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt=n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d ",circle[f[i]]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=f[i];j&lt;cnt-1;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; circle[j]=circle[j+1];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt--;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>