<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修STL用法整理' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>STL用法整理</center></div><div class='banquan'>原文出处:本文由博客园博主江梦丽提供。<br/>
原文连接:https://www.cnblogs.com/jiangml/p/10636820.html</div><br>
    <h2><span style="font-family: 'Microsoft YaHei';">百度百科</span></h2>
<p><span style="font-family: 'Microsoft YaHei';">STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。从根本上说，STL是一些&ldquo;容器&rdquo;的集合，这些&ldquo;容器&rdquo;有list,vector,set,map等，STL也是算法和其他一些组件的集合。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">在C++标准中，STL被组织为下面的13个头文件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;array&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;forward_list&gt;、&lt;map&gt;、&lt;unordered_map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;unordered_set&gt;、&lt;stack&gt;和&lt;utility&gt;。</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>向量(vector)</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;连续存储的元素&lt;vector&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>列表(list)</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;由节点组成的双向链表，每个结点包含着一个元素&lt;list&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>双队列(deque)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>连续存储的指向不同元素的指针所组成的数组&lt;deque&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>集合(set)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>&nbsp;由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序&nbsp;&lt;set&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>多重集合(multiset)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </strong>&nbsp; 允许存在两个次序相等的元素的集合&nbsp;&lt;set&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>栈(stack)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>后进先出的值的排列&nbsp;&lt;stack&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>队列(queue)</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 先进先出的执的排列&nbsp;&lt;queue&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>优先队列(priority_queue)</strong>&nbsp; &nbsp; &nbsp; &nbsp;元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列&nbsp;&lt;queue&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>映射(map)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</strong>由{键，值}对组成的集合，以某种作用于键对上的谓词排列&nbsp;&lt;map&gt;</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>多重映射(multimap)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong>&nbsp;允许键对有相等的次序的映射&nbsp;&lt;map&gt;</span></p>
<h1><span style="font-family: 'Microsoft YaHei';"><strong>一、string</strong></span></h1>
<p><span style="font-family: 'Microsoft YaHei';">在定义 string 类对象时，string 类自身可以管理内存，程序员不必关注内存的分配细节。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">string 类提供的各种操作函数大致分为八类：构造器和析构器、大小和容量、元素存取、字 符串比较、字符串修改、字符串接合、I/O 操作以及搜索和查找。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">要使用 string 类，必须包含头文件 &lt;string&gt;</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span><span style="color: #000000;"> stuff; 
getline(cin, stuff);  <span style="color: #008000;">//获取一行字符串</span></span></pre>
</div>
<h3>1、构造函数</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> strs                      <span style="color: #008000;">//</span><span style="color: #008000;">生成空字符串</span>
<span style="color: #0000ff;">string</span> s(str)                    <span style="color: #008000;">//</span><span style="color: #008000;">生成字符串str的复制品</span>
<span style="color: #0000ff;">string</span> s(str, stridx)            <span style="color: #008000;">//</span><span style="color: #008000;">将字符串str中始于stridx的部分作为构造函数的初值</span>
<span style="color: #0000ff;">string</span> s(str, strbegin, strlen)  <span style="color: #008000;">//</span><span style="color: #008000;">将字符串str中始于strbegin、长度为strlen的部分作为字符串初值</span>
<span style="color: #0000ff;">string</span> s(cstr)                   <span style="color: #008000;">//</span><span style="color: #008000;">以C_string类型cstr作为字符串s的初值</span>
<span style="color: #0000ff;">string</span> s(cstr,char_len)          <span style="color: #008000;">//</span><span style="color: #008000;">以C_string类型cstr的前char_len个字符串作为字符串s的初值</span>
<span style="color: #0000ff;">string</span> s(num, c)                 <span style="color: #008000;">//</span><span style="color: #008000;">生成一个字符串，包含num个c字符</span>
<span style="color: #0000ff;">string</span> s(strs, beg, end)         <span style="color: #008000;">//</span><span style="color: #008000;">以区间[beg, end]内的字符作为字符串s的初值</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> s(<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">错误</span>
<span style="color: #0000ff;">string</span> s(<span style="color: #800080;">1</span>, <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>);    <span style="color: #008000;">//</span><span style="color: #008000;">正确</span>
<span style="color: #0000ff;">string</span> s(<span style="color: #800000;">"</span><span style="color: #800000;">x</span><span style="color: #800000;">"</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">正确</span></pre>
</div>
<h3>2、获取字符串长度</h3>
<div class="cnblogs_code">
<pre>str.size();          <span style="color: #008000;">//</span><span style="color: #008000;">返回 string 类型对象中的字符个数</span>
str.length();        <span style="color: #008000;">//</span><span style="color: #008000;">返回 string 类型对象中的字符个数</span>
str.max_size();      <span style="color: #008000;">//</span><span style="color: #008000;">返回 string 类型对象最多包含的字符数。一旦程序使用长度超过 max_size() 的 string 操作，编译器会拋出 length_error 异常。</span>
str.capacity();      <span style="color: #008000;">//</span><span style="color: #008000;">返回在重新分配内存之前string 类型对象所能包含的最大字符数。</span></pre>
</div>
<h3>3、获取字符串元素：</h3>
<p>一般可使用两种方法访问字符串中的单一字符：下标操作符[]&nbsp;和&nbsp;成员函数at()。两者均返回指定的下标位置的字符。第 1 个字符索引（下标）为 0，最后的字符索引为 length()-1。</p>
<p>需要注意的是，这两种访问方法是有区别的：</p>
<ul>
<li>下标操作符 [] 在使用时不检查索引的有效性，如果下标超出字符的长度范围，会示导致未定义行为。对于常量字符串，使用下标操作符时，字符串的最后字符（即 '\0'）是有效的。对应 string 类型对象（常量型）最后一个字符的下标是有效的，调用返回字符 '\0'。</li>
<li>函数 at() 在使用时会检查下标是否有效。如果给定的下标超出字符的长度范围，系统会抛出 out_of_range 异常。</li>
</ul>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> s=<span style="color: #800000;">"</span><span style="color: #800000;">abcd</span><span style="color: #800000;">"</span><span style="color: #000000;">;
temp </span>= str [<span style="color: #800080;">2</span>];       <span style="color: #008000;">//</span><span style="color: #008000;">获取字符 'c'</span>
temp_1 = str.at(<span style="color: #800080;">2</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">获取字符 'c'</span></pre>
</div>
<h3>&nbsp;4、字符串比较方法</h3>
<p>&nbsp;Basic_string 类模板既提供了&nbsp; &gt;、&lt;、==、&gt;=、&lt;=、!= 等比较运算符，还提供了 compare() 函数，其中 compare() 函数支持多参数处理，支持用索引值和长度定位子串进行比较。该函数返回一个整数来表示比较结果。如果相比较的两个子串相同，compare() 函数返回 0，否则返回非零值。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> A (<span style="color: #800000;">"</span><span style="color: #800000;">aBcdef</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">string</span> B (<span style="color: #800000;">"</span><span style="color: #800000;">AbcdEf</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">string</span> C (<span style="color: #800000;">"</span><span style="color: #800000;">123456</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">string</span> D (<span style="color: #800000;">"</span><span style="color: #800000;">123dfg</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">下面是各种比较方法</span>
<span style="color: #0000ff;">int</span> m=A.compare (B);          <span style="color: #008000;">//</span><span style="color: #008000;">完整的A和B的比较              32</span>
<span style="color: #0000ff;">int</span> n=A.compare(<span style="color: #800080;">1</span>,<span style="color: #800080;">5</span>,B,<span style="color: #800080;">1</span>,<span style="color: #800080;">5</span>);   <span style="color: #008000;">//A的</span><span style="color: #008000;">"Bcdef"和B的"bcdEf"比较   -32</span>
<span style="color: #0000ff;">int</span> q=C.compare(<span style="color: #800080;">0</span>,<span style="color: #800080;">3</span>,D,<span style="color: #800080;">0</span>,<span style="color: #800080;">3</span>);   <span style="color: #008000;">//</span><span style="color: #008000;">"123"和"123"比较              0</span><span style="color: #000000;"><br /></span></pre>
</div>
<h3>5、字符串内容的修改</h3>
<p>可以通过使用多个函数修改字符串的值。例如<span style="color: #000000;"> assign()，operator=，erase()，交换（swap），插入（insert）等。另外，还可通过 append() 函数添加字符。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>str.assign(str1);                      <span style="color: #008000;">//</span><span style="color: #008000;">str1赋值给str</span>
str.assign (str1 , <span style="color: #800080;">3</span>, <span style="color: #800080;">3</span>);              <span style="color: #008000;">//</span><span style="color: #008000;">将从str1[3]长度3的子串赋值给str</span>
str.assign (str1, <span style="color: #800080;">2</span>, str1.npos);       <span style="color: #008000;">//</span><span style="color: #008000;">将从str1[2]到末尾赋值给str</span>
str.assign (<span style="color: #800080;">5</span>, <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>);                   <span style="color: #008000;">//</span><span style="color: #008000;">将XXXXX赋值给str</span>
string::iterator itB;                  <span style="color: #008000;">//</span><span style="color: #008000;">迭代器itB</span>
itB = str1.begin ();                   <span style="color: #008000;">//</span><span style="color: #008000;">将str1.begin()，即1赋值给迭代器itB</span>
str.erase(<span style="color: #800080;">3</span>);                          <span style="color: #008000;">//</span><span style="color: #008000;">从尾开始，删除3个值</span>
str.swap(str2);                        <span style="color: #008000;">//</span><span style="color: #008000;">str值与str2值交换</span>
B.insert (<span style="color: #800080;">1</span>, A);                       <span style="color: #008000;">//</span><span style="color: #008000;">在B[1]位置插入A</span>
B.insert (<span style="color: #800080;">1</span>, <span style="color: #800000;">"</span><span style="color: #800000;">yanchy </span><span style="color: #800000;">"</span>, <span style="color: #800080;">3</span>);            <span style="color: #008000;">//</span><span style="color: #008000;">将&ldquo;yanchy&rdquo;长度为3的子串插入B[1]</span>
B.insert(<span style="color: #800080;">1</span>,A,<span style="color: #800080;">2</span>,<span style="color: #800080;">2</span>);                     <span style="color: #008000;">//</span><span style="color: #008000;">将A从索引2，长度为2的子串插入B[1]</span>
B.insert (<span style="color: #800080;">1</span>,<span style="color: #800080;">5</span>,<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">);                      
B.append (A);                          </span><span style="color: #008000;">//</span><span style="color: #008000;">将A追加到B后</span>
B.append(<span style="color: #800000;">"</span><span style="color: #800000;">12345</span><span style="color: #800000;">"</span>, <span style="color: #800080;">2</span>);                  <span style="color: #008000;">//</span><span style="color: #008000;">将从索引0，长度为2的子串追加至B</span>
B.append (<span style="color: #800000;">"</span><span style="color: #800000;">12345</span><span style="color: #800000;">"</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>);              <span style="color: #008000;">//</span><span style="color: #008000;">将从索引2，长度为3的子串追加至B</span>
B.append (<span style="color: #800080;">10</span> , <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>);                  <span style="color: #008000;"> //追加10个a</span></pre>
</div>
<h3>6、字符串内容的替换</h3>
<p>&nbsp;如果在一个字符串中标识出具体位置，便可以通过下标操作修改指定位置字符的值，或者替换某个子串。完成此项操作需要使用 string 类的成员函数&nbsp;replace()。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">var</span>.replace (<span style="color: #800080;">3</span>,<span style="color: #800080;">3</span>, &ldquo;<span style="color: #800080;">1234</span><span style="color: #000000;">&rdquo;);
</span><span style="color: #0000ff;">var</span>.replace (<span style="color: #800080;">3</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">5</span>, <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span>.replace (<span style="color: #800080;">3</span>,<span style="color: #800080;">1</span>, var1.c_str(), <span style="color: #800080;">1</span>, <span style="color: #800080;">3</span>);</pre>
</div>
<h3>7、字符串查找函数</h3>
<div class="cnblogs_code">
<pre>str.find (<span style="color: #800000;">'</span><span style="color: #800000;">P</span><span style="color: #800000;">'</span>, <span style="color: #800080;">5</span><span style="color: #000000;">);
str.find (</span><span style="color: #800000;">"</span><span style="color: #800000;"> some</span><span style="color: #800000;">"</span>, <span style="color: #800080;">0</span>);</pre>
</div>
<h1>二、序列容器</h1>
<h2>1、array</h2>
<p>array&lt;T,N&gt; 模板定义了一种相当于标准数组的容器类型。它是一个有 N 个 T 类型元素的固定序列。除了需要指定元素的类型和个数之外，它和常规数组没有太大的差别。显然，不能增加或删除元素。</p>
<h3><span style="font-size: 16px;">1.1初始化</span></h3>
<div class="cnblogs_code">
<pre>array&lt;<span style="color: #0000ff;">double</span>, <span style="color: #800080;">100</span>&gt; data;             <span style="color: #008000;">//</span><span style="color: #008000;">定义100个double型元素，但未初始化</span>
array&lt;<span style="color: #0000ff;">double</span>, <span style="color: #800080;">100</span>&gt; data {};          <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
array&lt;<span style="color: #0000ff;">double</span>, <span style="color: #800080;">10</span>&gt; values {<span style="color: #800080;">0.5</span>, <span style="color: #800080;">1.0</span>}; <span style="color: #008000;">//</span><span style="color: #008000;">创建 array 容器的实例时，对元素进行初始化</span>
values.fill(<span style="color: #800080;">3.14</span>);                   <span style="color: #008000;">//</span><span style="color: #008000;">将所有元素设成给定值</span></pre>
</div>
<h3><span style="font-size: 18px;">1.2</span><strong style="font-family: 'Microsoft YaHei'; font-size: 16px;">获取元素</strong></h3>
<div class="cnblogs_code">
<pre>values[<span style="color: #800080;">4</span>] = values[<span style="color: #800080;">3</span>] + <span style="color: #800080;">2</span>.O*values[<span style="color: #800080;">1</span>];            <span style="color: #008000;">//</span><span style="color: #008000;">索引         </span>
values.at (<span style="color: #800080;">4</span>) = values.at(<span style="color: #800080;">3</span>) + <span style="color: #800080;">2</span>.O*values.at(<span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">at()</span>
auto first = height_ins.begin();                  <span style="color: #008000;">//</span><span style="color: #008000;">begin()</span>
auto last = height_ins.end () ;                   <span style="color: #008000;">//</span><span style="color: #008000;">end()</span></pre>
</div>
<h2><strong>2、vector</strong></h2>
<p>vector&lt;T&gt; 容器是包含 T 类型元素的序列容器，和 array&lt;T，N&gt; 容器相似，不同的是 vector&lt;T&gt; 容器的大小可以自动增长，从而可以包含任意数量的元素；因此类型参数 T 不再需要模板参数 N。只要元素个数超出 vector 当前容量，就会自动分配更多的空间。只能在容器尾部高效地删除或添加元素。</p>
<h3><span style="font-family: 'Microsoft YaHei';">2.1初始化</span></h3>
<div class="cnblogs_code">
<pre>vector&lt;<span style="color: #0000ff;">int</span>&gt; v {<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">11</span>};  <span style="color: #008000;">//</span><span style="color: #008000;">以初始化列表中的値作为元素初始值，生成有 5 个int型 vector 容器</span>
vector&lt;<span style="color: #0000ff;">double</span>&gt; values(<span style="color: #800080;">20</span>);       <span style="color: #008000;">//</span><span style="color: #008000;">容器开始时有 20 个元素，它们的默认初始值都为 0</span>
vector&lt;<span style="color: #0000ff;">char</span> &gt;v (<span style="color: #800080;">10</span>, <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>);        <span style="color: #008000;">//</span><span style="color: #008000;">容器开始时有 10 个元素，它们的默认初始值都为 char型 a<br /></span></pre>
<pre>array&lt;string&gt; words {"one", "two","three", "four", "five"};
vector&lt;string&gt; words_copy {begin(words) , end(words)};                                      <span style="color: #008000;"> //元素复制</span><br />vector&lt;string〉words_copy {make_move_iterator(begin(words)),make_move_iterator(end(words))}; <span style="color: #008000;">//元素移动</span></pre>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node{ <br /><span style="color: #008000;">    //初始化结构体
    </span></span><span style="color: #008000;">//</span><span style="color: #008000;">省略代码             </span>
<span style="color: #000000;">};
vector</span>&lt;Node*&gt;v;</pre>
</div>
<h3><strong>2.2大小与容量</strong></h3>
<p>size()、capacity()</p>
<div class="cnblogs_code">
<pre>vector&lt;size_t&gt; v { <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">11</span>, <span style="color: #800080;">13</span>, <span style="color: #800080;">17</span>, <span style="color: #800080;">19</span>, <span style="color: #800080;">23</span> };       <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span><span style="color: #000000;">
cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">The size is </span><span style="color: #800000;">"</span> &lt;&lt; v.size() &lt;&lt; std::endl;           <span style="color: #008000;">//</span><span style="color: #008000;">v.size()      计算元素个数</span>
cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">The capacity is</span><span style="color: #800000;">"</span> &lt;&lt; v.capacity() &lt;&lt; std::endl;    <span style="color: #008000;">//</span><span style="color: #008000;">v.capacity()  计算容量大小</span></pre>
</div>
<h3><strong>2.3获取元素</strong></h3>
<p>front()、back()、begin()、end()、索引</p>
<p>通过使用索引，总是可以访问到现有的元素或为现有元素设定值，但是不能这样生成新元素。</p>
<div class="cnblogs_code">
<pre>vector&lt;<span style="color: #0000ff;">double</span>&gt; v(<span style="color: #800080;">20</span><span style="color: #000000;">);
v[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">3.14159</span><span style="color: #000000;">;
v[</span><span style="color: #800080;">1</span>] = <span style="color: #800080;">5.0</span><span style="color: #000000;">;
v[</span><span style="color: #800080;">2</span>] = <span style="color: #800080;">2.0</span>*[<span style="color: #800080;">0</span>]*v[<span style="color: #800080;">1</span>];</pre>
</div>
<div class="cnblogs_code">
<pre>cout &lt;&lt; v.front () &lt;&lt; endl;   <span style="color: #008000;">//</span><span style="color: #008000;">front()返回序列中第一个元素的引用</span>
cout &lt;&lt; v.front () &lt;&lt; endl;   <span style="color: #008000;">//</span><span style="color: #008000;">back()返回序列中最后一个元素的引用</span>
v.front() = <span style="color: #800080;">2.71828</span>;          <span style="color: #008000;">//</span><span style="color: #008000;">因为返回的是引用，所以可以出现在赋值运算符的左边。</span>
auto pData = v.data();        <span style="color: #008000;">//</span><span style="color: #008000;">返回一个指向数组的指针，它在内部被用来存储元素。data() 返回 vector&lt;T&gt; 容器的 T* 类型的值。</span></pre>
</div>
<h3><strong>2.4</strong><strong>添加元素</strong></h3>
<p>push_back()、emplace_back()、insert()</p>
<p>emplace_back() 函数会调用接收三个参数的 string 构造函数，生成 string 对象，然后把它添加到 words 序列中。构造函数会生成一个从索引 2 幵始、包含 str 中三个字符的子串。</p>
<div class="cnblogs_code">
<pre>vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
v.push_back(</span><span style="color: #800080;">3</span>);                <span style="color: #008000;">//</span><span style="color: #008000;">push_back()把3添加到现有元素的后面</span>
 
<span style="color: #0000ff;">string</span> str {<span style="color: #800000;">"</span><span style="color: #800000;">alleged</span><span style="color: #800000;">"</span><span style="color: #000000;">};
words.emplace_back(str, </span><span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>); <span style="color: #008000;">//</span><span style="color: #008000;"> "leg" in place　　<br /></span></pre>
</div>
<p>insert()</p>
<p>1) 插入第二个参数指定的单个元素</p>
<div class="cnblogs_code">
<pre>vector&lt;<span style="color: #0000ff;">string</span>&gt; words { <span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">three</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">eight</span><span style="color: #800000;">"</span>}     <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
auto iter = words.insert(++begin(words), <span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">one two three eight  返回的迭代器指向被插入的元素 string(&rdquo;two&rdquo;)</span></pre>
</div>
<p>2) 插入一个由第二个和第三个参数指定的元素序列</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">string</span> more[] {<span style="color: #800000;">"</span><span style="color: #800000;">five</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">six</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span> };                          <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
auto iter = words.insert(--end(words) ,begin(more), end(more));   <span style="color: #008000;">//one two three five six seven eight</span><span style="color: #008000;">  返回的迭代器指向插入的第一个元素"five"。</span></pre>
</div>
<p>3)&nbsp;在插入点插入多个单个元素。第二个参数是第三个参数所指定对象的插入次数</p>
<div class="cnblogs_code">
<pre>vector&lt;<span style="color: #0000ff;">int</span>&gt; words{ <span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span> };                    <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
auto iter = words.insert(--end(words), <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">1 2 3 3 4</span></pre>
</div>
<h3>2.5删除元素</h3>
<pre>clear()、pop_back()、erase()</pre>
<div class="cnblogs_code">
<pre>v.clear();                      <span style="color: #008000;">//</span><span style="color: #008000;">删除所有元素</span>
v.pop_back();                   <span style="color: #008000;">//</span><span style="color: #008000;">删除尾部元素</span>
v.erase(begin(v) + <span style="color: #800080;">1</span>);          <span style="color: #008000;">//</span><span style="color: #008000;">删除第二个元素</span>
<span style="color: #000000;">
vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v{ <span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">5</span><span style="color: #000000;"> };     //<span style="color: #008000;">删除范围内的元素，左闭右开</span>
v.erase(begin(v)</span>+<span style="color: #800080;">1</span>,begin(v)+<span style="color: #800080;">3</span>); <span style="color: #008000;">//</span><span style="color: #008000;">1,4,5 </span></pre>
</div>
<h3>2.6其他</h3>
<div class="cnblogs_code">
<pre>v.empty()                       <span style="color: #008000;">//</span><span style="color: #008000;">判空</span>
v1.swap(v2)                     <span style="color: #008000;">//</span><span style="color: #008000;">交换容器间数据</span>
reverse(v.begin(), v.end());    <span style="color: #008000;">//</span><span style="color: #008000;">反转</span></pre>
</div>
<h2>3、deque</h2>
<p>deque&lt;T&gt;，一个定义在 deque 头文件中的容器模板，可以生成包含 T 类型元素的容器，它以双端队列的形式组织元素。可以在容器的头部和尾部高效地添加或删除对象，这是它相对于 vector 容器的优势。</p>
<h3><span style="font-family: 'Microsoft YaHei';">3.1初始化</span></h3>
<div class="cnblogs_code">
<pre>deque&lt;<span style="color: #0000ff;">int</span>&gt; d;                                                <span style="color: #008000;">//</span><span style="color: #008000;">生成deque容器，容器中没有元素，因此添加第一个元素，就会导致内存的分配</span>
deque&lt;<span style="color: #0000ff;">int</span>&gt; d(<span style="color: #800080;">10</span>);                                            <span style="color: #008000;">//</span><span style="color: #008000;">10个元素，默认值为0</span>
deque&lt;<span style="color: #0000ff;">string</span>&gt; words { <span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">none</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">some</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">all</span><span style="color: #800000;">"</span> };        <span style="color: #008000;">//</span><span style="color: #008000;">初始化</span>
deque&lt;<span style="color: #0000ff;">string</span>&gt; words_copy { words };                          <span style="color: #008000;">//</span><span style="color: #008000;">生成words的副本</span>
deque&lt;<span style="color: #0000ff;">string</span>&gt; words_part { begin(words),begin(words) + <span style="color: #800080;">5</span> };  <span style="color: #008000;">//</span><span style="color: #008000;">迭代器标识范围初始化</span></pre>
</div>
<h3>3.2获取元素</h3>
<p>索引、at()、front()、back()</p>
<h3>3.3大小</h3>
<p>size(); 因为deque容量和大小总是一样，所以并没有capacity()</p>
<h3>3.4添加和删除元素</h3>
<p>与vector一样都有成员函数：push_back()、pop_back()、emplace_back()、insert()、erase()、clear()</p>
<p>deque还有：push_front()、pop_front()、emplace_front()</p>
<h3>&nbsp;3.5修改替换元素</h3>
<p>assign()</p>
<h2>4、List</h2>
<p>list&lt;T&gt; 容器模板定义在 list 头文件中，是 T 类型对象的双向链表。</p>
<h3>4.1初始化</h3>
<div class="cnblogs_code">
<pre>list&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> l;
list</span>&lt;<span style="color: #0000ff;">string</span>&gt; l {<span style="color: #800080;">20</span>};                         <span style="color: #008000;">//</span><span style="color: #008000;">二十个元素</span>
list&lt;<span style="color: #0000ff;">double</span>&gt; l (<span style="color: #800080;">50</span>, <span style="color: #800080;">3.14</span>);                   <span style="color: #008000;">//</span><span style="color: #008000;">50个3.14</span>
list&lt;<span style="color: #0000ff;">double</span>&gt; l {l1};                         <span style="color: #008000;">//</span><span style="color: #008000;">生成l1（list容器）的副本</span>
list&lt;<span style="color: #0000ff;">double</span>&gt; l {++cbegin(l1), --cend(l1)};   <span style="color: #008000;">//</span><span style="color: #008000;">l1的开始和结束迭代器所指定的一段元素</span></pre>
</div>
<h3>4.2大小</h3>
<p>size()</p>
<h3>4.3添加删除元素</h3>
<p>添加：</p>
<p>push_back()、push_front()、emplace_back()、emplace_front()，后两个函数更高效。</p>
<p>insert()，插入元素不必移动现有的元素。生成新元素后，这个过程需要将 4 个指针重新设为适当的值。第一个元素的 next 指针指向新的元素，原来的第二个元素的 pre 指针也指向新的元素。新元素的 pre 指针指向第一个元素，next 指针指向序列之前的第二个元素。</p>
<p>删除：</p>
<p>clear()、erase()，list 容器的成员函数 remove() 则移除和参数匹配的元素。</p>
<p>成员函数 remove_if() 期望传入一个一元断言作为参数。一元断言接受一个和元素同类型的参数或引用，返回一个布尔值。断言返回 true 的所有元素都会被移除。</p>
<div class="cnblogs_code">
<pre>numbers.remove_if([](<span style="color: #0000ff;">int</span> n){<span style="color: #0000ff;">return</span> n%<span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>;});   <span style="color: #008000;">//</span><span style="color: #008000;"> Remove even numbers. Result 5 3 7 9</span></pre>
</div>
<p>成员函数 unique()可以移除连续的重复元素，只留下其中的第一个。</p>
<div class="cnblogs_code">
<pre>list&lt;<span style="color: #0000ff;">string</span>&gt; words { <span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">three</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span><span style="color: #000000;">};
words.unique () ; </span><span style="color: #008000;">//</span><span style="color: #008000;"> Now contains "one" "two" "three" "four"</span></pre>
</div>
<h3>4.4排序与合并元素</h3>
<p>list 容器并不提供随机访问迭代器，只提供双向迭代器，因此不能对 list 中的元素使用 sort() 算法，而是定义了自己的 sort() 函数。</p>
<div class="cnblogs_code">
<pre>names.sort(greater&lt;&gt;()); <span style="color: #008000;">//</span><span style="color: #008000;">从大到小排序，头文件 functional 中的模板 greater&lt;T&gt;</span>
names.sort(cmp());       <span style="color: #008000;">//</span><span style="color: #008000;">或者自定义比较函数</span></pre>
</div>
<p>list 的成员函数 merge() 以另一个具有相同类型元素的 list 容器作为参数。两个容器中的元素都必须是升序。参数 list 容器中的元素会被合并到当前的 list 容器中。</p>
<div class="cnblogs_code">
<pre>list&lt;<span style="color: #0000ff;">int</span>&gt; my{<span style="color: #800080;">2</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">14</span><span style="color: #000000;">};
list</span>&lt;<span style="color: #0000ff;">int</span>&gt; your{ -<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">10</span><span style="color: #000000;">};
my.merge (your);               </span><span style="color: #008000;">//</span><span style="color: #008000;">my： -2 1 2 4 6 7 10 14</span>
your.empty();                  <span style="color: #008000;">//</span><span style="color: #008000;">your变为空</span></pre>
</div>
<p>list 容器的成员函数 splice() 有几个重载版本。这个函数将参数 list 容器中的元素移动到当前容器中指定位置的前面。可以移动单个元素、一段元素或源容器的全部元素。</p>
<h1>三、容器适配器</h1>
<h2>1、stack</h2>
<p>stack&lt;T&gt;：是一个封装了 deque&lt;T&gt; 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack&lt;T&gt; 模板定义在头文件 stack 中。</p>
<ul>
<li>top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</li>
<li>push()：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li>
<li>pop()：弹出栈顶元素。</li>
<li>size()：返回栈中元素的个数。</li>
<li>empty()：在栈中没有元素的情况下返回 true。</li>
<li>swap(stack&lt;T&gt; &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同</li>
</ul>
<h2>2、queue</h2>
<p>queue&lt;T&gt;：是一个封装了 deque&lt;T&gt; 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。queue&lt;T&gt; 模板定义在头文件 queue 中。</p>
<ul>
<li>front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li>back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li>push()：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</li>
<li>pop()：删除 queue 中的第一个元素。</li>
<li>size()：返回 queue 中元素的个数。</li>
<li>empty()：如果 queue 中没有元素的话，返回 true。</li>
<li>swap(queue&lt;T&gt; &amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板&nbsp;swap() 来完成同样的操作。</li>
</ul>
<h2></h2>
<p>priority_queue&lt;T&gt;：是一个封装了 vector&lt;T&gt; 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;priority_queue&lt;T&gt; 模板定义在头文件 queue 中。</p>
<ul>
<li>push()：将obj放到容器的适当位置，这通常会包含一个排序操作。</li>
<li>top()：返回优先级队列中第一个元素的引用。</li>
<li>pop()：移除第一个元素。</li>
<li>size()：返回队列中元素的个数。</li>
<li>empty()：如果队列为空的话，返回true。</li>
<li>swap(priority_queue&lt;T&gt;&amp; other)：和参数的元素进行交换，所包含对象的类型必须相同</li>
</ul>
<h1>四、map容器</h1>
<p>map 容器是关联容器的一种。在关联容器中，对象的位置取决于和它关联的键的值。</p>
<p>map 和 mutilmap 容器的模板定义在 map 头文件中，unordered_map 和 unordered_multimap 容器的模板定义在 unordered_map 头文件中。</p>
<p>map 容器有 4 种，每一种都是由类模板定义的。每种 map 容器的模板都有不同的特性：</p>
<ol>
<li>map&lt;K，T&gt;容器，保存的是 pair&lt;const K，T&gt; 类型的元素。键唯一；map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。</li>
<li>multimap&lt;K，T&gt; 容器，也会对元素排序。元素的顺序是通过比较键确定的。但multimap 容器可以保存多个具有相同键值的 &lt;const K,T&gt; 元素。</li>
<li>unordered_map&lt;K，T&gt; 中 pair&lt; const K，T&gt;元素的顺序是由键值的哈希值决定的。不允许有重复的键。</li>
<li>unordered_multimap&lt;K,T&gt; 通过键值生成的哈希值来确定对象的位置，但允许有重复的键。</li>
</ol>
<p>区别： multi前缀表明键不必唯一</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unordered前缀表明容器中元素的位置是通过其键值所产生的哈希值来决定的，而不是通过比较键值决定的。</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>