<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[CF750G] New Year and Binary Tree Paths' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[CF750G] New Year and Binary Tree Paths</center></div><div class='banquan'>原文出处:本文由博客园博主nosta提供。<br/>
原文连接:https://www.cnblogs.com/nosta/p/10829973.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#简单的">简单的</a></li>
        <li><a href="#组合的">组合的</a></li>
        </ul>
    </div>
</div>
<p><a href="https://www.luogu.org/problemnew/show/P5342">题目链接</a></p>
<h2 id="简单的">简单的</h2>
<p>设从节点<span class="math inline">\(x\)</span>开始不断往左儿子走h-1步，则编号和为<span class="math inline">\(x\sum_{i=0}^{h-1}2^i=x(2^h-1)\)</span>。</p>
<p>若倒数第<span class="math inline">\(i\)</span>步走向的是右儿子，则编号和会增加<span class="math inline">\(\sum_{j=0}^{i-1}2^j=2^i-1\)</span>。</p>
<p>这样，从<span class="math inline">\(x\)</span>往下走形成的长为<span class="math inline">\(h\)</span>的链中，其中倒数<span class="math inline">\(i,i\in T\)</span>步时走向右儿子，倒数<span class="math inline">\(i,i\not\in T\)</span>步走向左儿子，这样得到的编号和为</p>
<p><span class="math display">\[
x(2^h-1)+\sum_{i\in T}2^i-|T|=S
\]</span></p>
<p>令<span class="math inline">\(L=\lfloor\frac{S}{2^h-1}\rfloor\)</span>，显然<span class="math inline">\(|T|&lt;h\le\log_2(S+1),x\le L\)</span>。又因为</p>
<p><span class="math display">\[
(L-1)(2^h-1)+\sum_{i\in T}2^i-|T|\le S-(2^h-1)+(2^h-h-1)\\
=S-h&lt;S
\]</span></p>
<p>故<span class="math inline">\(x&gt;L-1\)</span>进而<span class="math inline">\(x=L\)</span>，或称对每个<span class="math inline">\(h\)</span>有唯一的<span class="math inline">\(x=L\)</span>，那么方案数为方程<span class="math inline">\(\sum_{i\in T}2^i=S+|T|+L(2^h-1)\)</span>的解的个数。（这显然最多只有一组解）</p>
<h2 id="组合的">组合的</h2>
<p>从节点<span class="math inline">\(x\)</span>的左右儿子出发的两天简单链分别表示为<span class="math inline">\((h_0,T_0),(h_1,T_1)\)</span>，总的编号和</p>
<p><span class="math display">\[
x+2x(2^{h_0}-1)+(2x+1)(2^{h_1}-1)+\sum_{i\in T_0}2^i+\sum_{i\in T_1}2^i-|T_0|-|T_1|\\
=x(2^{h_0+1}+2^{h_1+1}-3)+2^{h_1}-1+\sum_{i\in T_0}2^i+\sum_{i\in T_1}2^i-|T_0|-|T_1|=S
\]</span></p>
<p>大胆猜想<span class="math inline">\(h_0,h_1\)</span>确定时有唯一的<span class="math inline">\(x=\lfloor\frac{S-2^{h_1}+1}{2^{h_0+1}+2^{h_1+1}-3}\rfloor\)</span>。</p>
<p>接着问题转变为在<span class="math inline">\({2^1,2^2,\cdots,2^{h_0-1}},{2^1,2^2,\cdots,2^{h_1-1}}\)</span>中一共选取<span class="math inline">\(n\)</span>个数之和等于<span class="math inline">\(S-(\cdots)+n\)</span>（QAQ）的方案数。</p>
<p>考虑枚举<span class="math inline">\(n\)</span>，设<span class="math inline">\(f[i,j,0/1]\)</span>表示考虑完前<span class="math inline">\(i\)</span>个指数后，已经选了<span class="math inline">\(j\)</span>个数字，这一位（二进制末尾第<span class="math inline">\(i+1\)</span>位）为是否进位的方案数。其中<span class="math inline">\(f[0,0,0]=1\)</span>。</p>
<p>答案是<span class="math inline">\(\sum_{h_0,h_1}(\sum_n f[\max(h_0,h_1),n,0])\)</span>。时间复杂度<span class="math inline">\(O(\log_2^5S)\)</span>。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define LL long long 
using namespace std;
const int N=53;

LL S,L,ans;
LL P[N]={1};
LL f[N][N*2][2];

int main() {
    scanf(&quot;%lld&quot;,&amp;S); L=log2(S+1);
    for(int i=1; i&lt;N; ++i) P[i]=P[i-1]&lt;&lt;1;
    for(int h=1; h&lt;=L; ++h) {
        LL x=S%(P[h]-1);
        for(int i=h; i; --i) if(x&gt;=P[i]-1) x-=P[i]-1;
        ans+=(!x);
    }
    for(int h0=1; h0&lt;L; ++h0)
    for(int h1=1; S+1-P[h1]&gt;=P[h0+1]+P[h1+1]-3; ++h1) {
        LL x=(S+1-P[h1])/(P[h0+1]+P[h1+1]-3);
        LL r=(S+1-P[h1])%(P[h0+1]+P[h1+1]-3);
        if(!r) {ans++; continue;}
        if(h0==1&amp;&amp;h1==1) {ans+=(S==x*5+1); continue;}
        for(int n=1; n&lt;=h0+h1; ++n) {
            LL C=r+n,L=log2(C);
            if(C&amp;1) continue;
            memset(f[0],0,sizeof f[0]); f[0][0][0]=1;
            for(int i=1; i&lt;=L; ++i) {
                int d=(C&gt;&gt;i)&amp;1; memset(f[i],0,sizeof f[i]);
                for(int j=0; j&lt;=i+i-2&amp;&amp;j&lt;=n; ++j)
                for(int k=0; k&lt;2; ++k) if(f[i-1][j][k]) 
                    for(int x=0; x&lt;2; ++x) if(!x||i&lt;h0)
                    for(int y=0; y&lt;2; ++y) if(!y||i&lt;h1) 
                        if(((k+x+y)&amp;1)==d) f[i][j+x+y][(k+x+y)&gt;&gt;1]+=f[i-1][j][k];
            }
            ans+=f[L][n][0];
        }
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}</code></pre>
<p><del>不知道1K+ms是怎么跑出来的</del></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>