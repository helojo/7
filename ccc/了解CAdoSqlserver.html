<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修了解CAdoSqlserver' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>了解CAdoSqlserver</center></div><div class='banquan'>原文出处:本文由博客园博主蓟_可爱的叔提供。<br/>
原文连接:https://www.cnblogs.com/wjq13752525588/p/11451448.html</div><br>
    <p>include &lt;vector&gt;</p>
<p>　　表示引用了vector类, vector是STL中的一种数据结构，或者叫容器，功能相当于数组，但是功能强大很多。vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。</p>
<p>　　catch（...）//抛出异常</p>
<p>　　#pragma once一般是由编译器提供保证：同一个文件不会被包含多次。这里所说的&ldquo;同一个文件&rdquo;是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once声明，而只能针对文件。此方式不会出现宏名碰撞引发的奇怪问题，大型项目的编译速度也因此提供了一些。缺点是如果某个头文件有多份拷贝，此方法不能保证它们不被重复包含。在C/C++中，#pragma once是一个非标准但是被广泛支持的方式。</p>
<p>　　#pragma once方式产生于#ifndef之后。#ifndef方式接受C/C++语言标准的支持，不受编译器的任何限制；而#pragma once方式有些编译器不支持（较老的编译器不支持，如GCC3.4版本之前不支持#pragma once），兼容性不够好。#ifndef可以针对一个文件中的部分代码，而#pragma once只能针对整个文件。</p>
<p>C++variant数据类型</p>
<p>　　_variant_t是一个类,是VARIANT的完全包装类,它提供多种构造函数和数据转换函数.它继承自一个结构体。</p>
<p>　　_variant_t变量初始化调用的是_va,riant_t的构造函数,如果用一个int型的变量对数字类的变量进行初始化,会出错,因为_variant_t的构造函数中没有用整型对其初始化的构造函数,可先将整型转化成long对其进行初始化,赋值操作与构造函数类似,可如下操作:</p>
<p>　　int a = 2000;</p>
<p>　　_variant_t var;</p>
<p>　　var.vt = VT_12；</p>
<p>　　var.lVal = a;</p>
<p>　　对于没有构造函数的数据类型都可以这样赋值。</p>
<p>　　对于有构造函数的就可以直接利用构造函数赋值，例如：</p>
<p>　　long l = 222;</p>
<p>　　_variant_t lVal(l);</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>