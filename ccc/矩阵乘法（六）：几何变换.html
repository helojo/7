<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修矩阵乘法（六）：几何变换' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>矩阵乘法（六）：几何变换</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11471143.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 在计算机图形学中，矩阵乘法有着很好的应用。图形的变换可以通过构造相应的矩阵进行计算来完成。</p>
<p>&nbsp; &nbsp; &nbsp; 我们知道，平面上的元素，就是点、线、面，而线就是由一个个点组成的，面是由一条条线组成的，所以归根结底，平面上所有的图形都是由点组成的。在坐标系中，一个点就是由一对x，y值组成的，p = {x, y}。在平面上，过两点间的，可以画一条直线，所以我们一般通过 两个点p1, p2可定义一条直线，e = {p1, p2}，而图形呢，则是由众多的点和点之间的的线段组成的。所以，平面上的图形变换，本质是点坐标位置的变换。</p>
<p>&nbsp; &nbsp; &nbsp; 在平面中，常用的基本图形变换有以下四种：</p>
<p>&nbsp; &nbsp; &nbsp; 1）平移（Translation）。</p>
<p>&nbsp; &nbsp; &nbsp; 设点(x,y)水平向右平移dx个单位，垂直向上平移dy个单位。表示点（x,y）的矩阵P和构造的平移变换矩阵T如下：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（六）：几何变换0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 则点(x,y)的平移后的新位置P'可以通过矩阵乘法计算出来。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（六）：几何变换1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 2）缩放（Scale）。</p>
<p>&nbsp; &nbsp; &nbsp; 设点(x,y)在水平方向和垂直方向的缩放比例分别为Sx和Sy。表示点（x,y）的矩阵P和构造的缩放变换矩阵S如下：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（六）：几何变换2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 则点(x,y)的缩放后的新位置P'可以通过矩阵乘法计算出来。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（六）：几何变换3.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 3）旋转（Rotation）。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;设点(x,y)绕原点逆时针旋转&alpha;角度。表示点（x,y）的矩阵P和构造的旋转变换矩阵R如下：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（六）：几何变换4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 旋转矩阵的构造原理参见下图。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（六）：几何变换5.png" alt="" width="407" height="138" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;则点(x,y)绕原点逆时针旋转后的新位置P'可以通过矩阵乘法计算出来。</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（六）：几何变换6.png" alt="" width="486" height="76" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 4）反射（Reflect）。</p>
<p>&nbsp; &nbsp; &nbsp; 反射变换分为关于原点反射、关于x轴反射和关于y轴反射三种。</p>
<p>&nbsp; &nbsp; &nbsp; 点 p(x,y) 关于原点反射后得到的点为po'(-x,-y)。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 点 p(x,y) 关于x轴反射后得到的点为px'(x,-y)，也称为上下翻转。&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp; 点 p(x,y) 关于x轴反射后得到的点为py'(-x,y)，也称为左右翻转。</p>
<p>&nbsp; &nbsp; &nbsp; 三种反射的矩阵计算如下：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（六）：几何变换7.png" alt="" /></p>
<p>&nbsp;</p>
<p><strong>&nbsp;<span style="font-size: 16px;">【例1】点的变换。</span></strong></p>
<p>&nbsp;描述</p>
<p>&nbsp; &nbsp; &nbsp; 平面上有不超过10000个点，坐标都是已知的，现在可能对所有的点做以下几种操作：</p>
<p>&nbsp; &nbsp; &nbsp; 平移一定距离(M)，相对X轴上下翻转(X)，相对Y轴左右翻转(Y)，坐标缩小或放大一定的倍数(S)，所有点对坐标原点逆时针旋转一定角度(R)。</p>
<p>&nbsp; &nbsp; &nbsp; 操作的次数不超过10000次，求最终所有点的坐标。</p>
<p>&nbsp;输入</p>
<p>&nbsp; &nbsp; &nbsp; 测试数据的第一行是两个整数N,M，分别表示点的个数与操作的个数(N,M&lt;=10000)<br />&nbsp; &nbsp; &nbsp; 随后的一行有N对数对，每个数对的第一个数表示一个点的x坐标，第二个数表示y坐标，这些点初始坐标大小绝对值不超过100。<br />&nbsp; &nbsp; &nbsp; 随后的M行，每行代表一种操作，行首是一个字符：<br />&nbsp; &nbsp; &nbsp; 首字符如果是M,则表示平移操作，该行后面将跟两个数x,y，表示把所有点按向量(x,y)平移;<br />&nbsp; &nbsp; &nbsp; 首字符如果是X，则表示把所有点相对于X轴进行上下翻转;<br />&nbsp; &nbsp; &nbsp; 首字符如果是Y，则表示把所有点相对于Y轴进行左右翻转;<br />&nbsp; &nbsp; &nbsp; 首字符如果是S，则随后将跟一个数P,表示坐标放大P倍;<br />&nbsp; &nbsp; &nbsp; 首字符如果是R，则随后将跟一个数A,表示所有点相对坐标原点逆时针旋转一定的角度A(单位是度)<br />输出<br />&nbsp; &nbsp; &nbsp;每行输出两个数，表示一个点的坐标(对结果四舍五入到小数点后1位，输出一位小数位）<br />点的输出顺序应与输入顺序保持一致<br />样例输入<br />&nbsp; &nbsp; &nbsp;2 5<br />&nbsp; &nbsp; &nbsp;1.0 2.0 2.0 3.0<br />&nbsp; &nbsp; &nbsp; X<br />&nbsp; &nbsp; &nbsp; Y<br />&nbsp; &nbsp; &nbsp; M 2.0 3.0<br />&nbsp; &nbsp; &nbsp; S 2.0<br />&nbsp; &nbsp; &nbsp; R 180<br />样例输出<br />&nbsp; &nbsp; &nbsp;-2.0 -2.0<br />&nbsp; &nbsp; &nbsp;0.0 0.0</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;直接按前面的介绍内容，分别构造5类变换矩阵。定义矩阵ans初始为单位矩阵。然后每输入m种操作中的一种时，根据操作类型构造相应的变换矩阵temp，然后ans右乘temp，即ans=temp*ans。输入完m种操作后，得到的ans矩阵就是每个点的变换矩阵，进行变换矩阵与点的矩阵乘法就可以得到每个点的最终坐标。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;math.h&gt;<br />#define PI acos(-1.0)<br />#define MAXN 10005<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; double mat[4][4]; // 存储矩阵中各元素<br />};<br />struct Point<br />{<br />&nbsp; &nbsp; &nbsp; double x ,y ;<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) ;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; char ch ;<br />&nbsp; &nbsp; &nbsp; Point p[MAXN];<br />&nbsp; &nbsp; &nbsp; Matrix ans,temp;<br />&nbsp; &nbsp; &nbsp; double a ;<br />&nbsp; &nbsp; &nbsp; int n,m,i,j;<br />&nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; for (i=0 ;i&lt;n;i++)<br />&nbsp; &nbsp; &nbsp; scanf("%lf%lf" ,&amp;p[i].x ,&amp;p[i].y);<br />&nbsp; &nbsp; &nbsp; memset(ans.mat,0,sizeof(ans.mat));&nbsp; &nbsp; &nbsp; // 初始为单位阵<br />&nbsp; &nbsp; &nbsp; &nbsp;ans.mat[1][1]=ans.mat[2][2]=ans.mat[3][3]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp;for (i=0 ;i&lt;m;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(temp.mat,0,sizeof(temp.mat));        // 初始为单位阵<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp.mat[1][1]=temp.mat[2][2]=temp.mat[3][3]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getchar();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%c",&amp;ch);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ch == 'M')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 平移<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%lf%lf" ,&amp;temp.mat[1][3] ,&amp;temp.mat[2][3]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (ch == 'X')&nbsp; &nbsp; &nbsp;// 相对X轴上下翻转<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[2][2]=-1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (ch == 'Y')&nbsp; &nbsp; &nbsp;// 相对于Y轴左右翻转<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[1][1] = -1 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (ch == 'S')&nbsp; &nbsp; &nbsp; // 坐标放大P倍<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%lf" ,&amp;temp.mat[1][1]) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[2][2] = temp.mat[1][1] ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (ch == 'R')&nbsp; &nbsp; // 相对坐标原点逆时针旋转一定的角度A<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%lf" ,&amp;a) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = (a*PI)/180.0 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[1][1] = temp.mat[2][2] = cos(a) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[1][2] = -sin(a) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp.mat[2][1] = sin(a) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans=matMul(temp,ans,3);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; for (i=0 ;i&lt;n ; i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=1 ;j&lt;=2; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (j!=1)  printf(" ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%.1lf" ,(ans.mat[j][1]*p[i].x+ans.mat[j][2]*p[i].y+ans.mat[j][3]));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0 ;<br />}</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 16px;">【例2】openGL （HDU 3320）。</span></strong></p>
<p><strong>Problem Description</strong><br />Jiaoshou selected a course about &ldquo;openGL&rdquo; this semester. He was quite interested in modelview, which is a part of &ldquo;openGL&rdquo;. Just using three functions, it could make the model to move, rotate and largen or lessen. But he was puzzled with the theory of the modelview. He didn&rsquo;t know a vertex after several transformations where it will be.</p>
<p>Now, He tells you the position of the vertex and the transformations. Please help Jiaoshou find the position of the vertex after several transformations.<br /> </p>
<p><strong>Input</strong><br />The input will start with a line giving the number of test cases, T.<br />Each case will always begin with &ldquo;glBegin(GL_POINTS);&rdquo;.Then the case will be followed by 5 kinds of function.<br />1. glTranslatef(x,y,z);<br />  This function will translate the vertex(x&rsquo;,y&rsquo;,z&rsquo;) to vertex(x+x&rsquo;,y+y&rsquo;,z+z&rsquo;).<br />2. glRotatef(angle,x,y,z);<br />  This function will turn angle radians counterclockwise around the axis (0,0,0)-&gt;(x,y,z).<br />3. glScalef(x,y,z);<br />  This function wiil translate the vertex(x&rsquo;,y&rsquo;,z&rsquo;) to vertex(x*x&rsquo;,y*y&rsquo;,z*z&rsquo;).<br />4. glVertex3f(x,y,z);<br />  This function will draw an initial vertex at the position(x,y,z). It will only appear once in one case just before &ldquo;glEnd();&rdquo;. In openGL, the transformation matrices are right multiplied by vertex matrix. So you should do the transformations in the reverse order. <br />5. glEnd();<br />  This function tells you the end of the case.<br />In this problem angle,x,y,z are real numbers and range from -50.0 to 50.0. And the number of functions in each case will not exceed 100.<br /> </p>
<p><strong>Output</strong><br />For each case, please output the position of the vertex after several transformations x,y,z in one line rounded to 1 digits after the decimal point , separated with a single space. We guarantee that x,y,z are not very large.<br /> </p>
<p><strong>Sample Input</strong><br />1<br />glBegin(GL_POINTS);<br />glScalef(2.0,0.5,3.0);<br />glTranslatef(0.0,1.0,0.0);<br />glVertex3f(1.0,1.0,1.0);<br />glEnd();<br /> </p>
<p><strong>Sample Output</strong><br />2.0 1.0 3.0<br /><strong>Hint</strong><br />In this sample, we first let the vertex do &ldquo;glTranslatef(x,y,z);&rdquo; this function, then do &ldquo;glScalef(x,y,z)&rdquo;.</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 题目的意思是：给出三维空间一个点的坐标，对它进行多种变换（平移、缩放、绕过原点的任意轴旋转），输出它的最终坐标。需要注意的是它给出各变换的操作顺序是反过来的（见题目Hint）。</p>
<p>&nbsp; &nbsp; &nbsp; 根据输入构造好三维坐标点的平移、缩放和旋转转换矩阵，用矩阵乘法乘起来就是最终坐标。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;math.h&gt;<br />#include &lt;string.h&gt;<br />int cnt;<br />char opstr[105][105];<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; double mat[5][5];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]);<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix translate(Matrix p, double x, double y, double z)    // 平移<br />{<br />&nbsp; &nbsp; &nbsp; &nbsp;Matrix tmp;<br />&nbsp; &nbsp; &nbsp; &nbsp;memset(tmp.mat,0,sizeof(tmp.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp;for (int i=1;i&lt;=4;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp.mat[i][i]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp;tmp.mat[1][4] = x;<br />&nbsp; &nbsp; &nbsp; &nbsp;tmp.mat[2][4] = y;<br />&nbsp; &nbsp; &nbsp; &nbsp;tmp.mat[3][4] = z;<br />&nbsp; &nbsp; &nbsp; &nbsp;p=matMul(tmp,p,4);<br />&nbsp; &nbsp; &nbsp; &nbsp;return p;<br />}<br />Matrix scale(Matrix p, double a, double b, double c)    //缩放<br />{<br />&nbsp; &nbsp; &nbsp; Matrix tmp;<br />&nbsp; &nbsp; &nbsp; memset(tmp.mat,0,sizeof(tmp.mat));<br />&nbsp; &nbsp; &nbsp; for (int i=1;i&lt;=4;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp.mat[i][i]=1;<br />&nbsp; &nbsp; &nbsp; tmp.mat[1][1] = a;<br />&nbsp; &nbsp; &nbsp; tmp.mat[2][2] = b;<br />&nbsp; &nbsp; &nbsp; tmp.mat[3][3] = c;<br />&nbsp; &nbsp; &nbsp; p=matMul(tmp,p,4);<br />&nbsp; &nbsp; &nbsp; return p;<br />}<br />Matrix rotate(Matrix p, double x, double y, double z, double d)    // 旋转<br />{<br />&nbsp; &nbsp; &nbsp; double di = sqrt(x*x+y*y+z*z);&nbsp; &nbsp; &nbsp; &nbsp;// 单位化<br />&nbsp; &nbsp; &nbsp; x/=di, y/=di, z/=di;<br />&nbsp; &nbsp; &nbsp; Matrix tmp;<br />&nbsp; &nbsp; &nbsp; memset(tmp.mat,0,sizeof(tmp.mat));<br />&nbsp; &nbsp; &nbsp; tmp.mat[1][1] = (1-cos(d))*x*x + cos(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[1][2] = (1-cos(d))*x*y - z*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[1][3] = (1-cos(d))*x*z + y*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[2][1] = (1-cos(d))*x*y + z*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[2][2] = (1-cos(d))*y*y + cos(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[2][3] = (1-cos(d))*y*z - x*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[3][1] = (1-cos(d))*x*z - y*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[3][2] = (1-cos(d))*y*z + x*sin(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[3][3] = (1-cos(d))*z*z + cos(d);<br />&nbsp; &nbsp; &nbsp; tmp.mat[4][4]=1;<br />&nbsp; &nbsp; &nbsp; p=matMul(tmp,p,4);<br />&nbsp; &nbsp; &nbsp; return p;<br />}<br />Matrix work()    <br />{<br />&nbsp; &nbsp; &nbsp; Matrix p;<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; double x,y,z,d;<br />&nbsp; &nbsp; &nbsp; memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=4;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[i][i]=1;<br />&nbsp; &nbsp; &nbsp; for (i=cnt-3;i&gt;0;i--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (opstr[i][2]=='T')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sscanf(opstr[i],"glTranslatef(%lf,%lf,%lf);",&amp;x,&amp;y,&amp;z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=translate(p,x,y,z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (opstr[i][2]=='S')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sscanf(opstr[i],"glScalef(%lf,%lf,%lf);",&amp;x,&amp;y,&amp;z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=scale(p,x,y,z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (opstr[i][2]=='R')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sscanf(opstr[i],"glRotatef(%lf,%lf,%lf,%lf);",&amp;d,&amp;x,&amp;y,&amp;z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p=rotate(p,x,y,z,d);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return p;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int t;<br />&nbsp; &nbsp; &nbsp; double x,y,z;<br />&nbsp; &nbsp; &nbsp; scanf("%d",&amp;t);<br />&nbsp; &nbsp; &nbsp; while(t--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%s",opstr[cnt++]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (opstr[cnt-1][2]=='E')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Matrix ans=work();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sscanf(opstr[cnt-2], "glVertex3f(%lf,%lf,%lf);",&amp;x,&amp;y,&amp;z);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%.1lf %.1lf %.1lf\n",x*ans.mat[1][1]+y*ans.mat[1][2]+z*ans.mat[1][3]+ans.mat[1][4],<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x*ans.mat[2][1]+y*ans.mat[2][2]+z*ans.mat[2][3]+ans.mat[2][4],<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x*ans.mat[3][1]+y*ans.mat[3][2]+z*ans.mat[3][3]+ans.mat[3][4]);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; 弄明白了本例，可以顺手将<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4087" target="_blank">HDU 4087 &ldquo;ALetter to Programmers&rdquo;</a>做一下，以加深对三维几何变换的理解。HDU 4087比本例复杂一些，因为存在某个指定的平移、缩放或旋转操作集重复执行，因此会用到矩阵快速幂运算。</p>
<p>&nbsp; &nbsp; &nbsp; 下面给出HDU 4087的源程序供参考。需要说明的是，这个源程序在HDU上用C++提交，一直Wrong Answer。采用G++提交可以Accepted。到现在我也没弄明白，所以仅供大家参考了。</p>
<p style="margin-left: 30px;">（3）HDU 4087的参考源程序。</p>
<pre><code><span style="color: #000000;">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#define eps 1e-6
#define pi acos(-1.0)
<strong>struct</strong> Matrix<strong>
{</strong><strong>
     double</strong> mat<strong>[</strong>5<strong>][</strong>5<strong>];</strong>   // 存储矩阵中各元素
<strong>};</strong>
Matrix matMul<strong>(</strong>Matrix a<strong> ,</strong>Matrix b<strong>,</strong><strong>int</strong> n<strong>)
{</strong>
      Matrix c<strong>;</strong>
      memset<strong>(</strong>c<strong>.</strong>mat<strong>,</strong>0<strong>,</strong><strong>sizeof</strong><strong>(</strong>c<strong>.</strong>mat<strong>));</strong><strong>
      int</strong> i<strong>,</strong>j<strong>,</strong>k<strong>;</strong><strong>
      for</strong><strong> (</strong>k<strong> =</strong> 1<strong>;</strong> k<strong>&lt;=</strong>n<strong> ;</strong> k<strong>++)</strong><strong>
          for</strong><strong> (</strong>i<strong>=</strong>1<strong> ;</strong>i<strong>&lt;=</strong>n<strong> ;</strong> i<strong>++)</strong><strong>
              if</strong><strong> (</strong>a<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>k<strong>]!=</strong>0<strong>)</strong><strong>
                  for</strong><strong> (</strong>j<strong> =</strong> 1<strong> ;</strong>j<strong>&lt;=</strong>n<strong> ;</strong>j<strong>++)</strong>
                      c<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>j<strong>] = (</strong>c<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>j<strong>] +</strong> a<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>k<strong>] *</strong> b<strong>.</strong>mat<strong>[</strong>k<strong>][</strong>j<strong>]);</strong><strong>
      return</strong> c<strong>;
}</strong>
Matrix quickMatPow<strong>(</strong>Matrix a<strong> ,</strong><strong>int</strong> n<strong>,</strong><strong>int</strong> b<strong>)</strong> // n阶矩阵a快速b次幂
<strong>{</strong>
      Matrix c<strong>;</strong>
      memset<strong>(</strong>c<strong>.</strong>mat<strong> ,</strong>0<strong> ,</strong><strong>sizeof</strong><strong>(</strong>c<strong>.</strong>mat<strong>));</strong><strong>
      int</strong> i<strong>;</strong><strong>
      for</strong><strong> (</strong>i<strong> =</strong> 1<strong> ;</strong>i<strong> &lt;=</strong> n<strong> ;</strong>i<strong>++)</strong>
           c<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>i<strong>] =</strong> 1<strong>;</strong><strong>
      while</strong><strong> (</strong>b<strong>!=</strong>0<strong>)
      {</strong><strong>
           if</strong><strong> (</strong>b<strong> &amp;</strong> 1<strong>)</strong> 
               c<strong> =</strong> matMul<strong>(</strong>c<strong> ,</strong>a<strong> ,</strong>n<strong>);</strong>  // c=c*a; 
           a<strong> =</strong> matMul<strong>(</strong>a<strong> ,</strong>a<strong> ,</strong>n<strong>);</strong>      // a=a*a
           b<strong> /=</strong> 2<strong>;
      }</strong><strong>
      return</strong> c<strong>;
}</strong>
Matrix translate<strong>(</strong>Matrix p<strong>,</strong><strong> double</strong> x<strong>,</strong><strong> double</strong> y<strong>,</strong><strong> double</strong> z<strong>)</strong>    // 平移
<strong>{</strong>
    Matrix tmp<strong>;</strong>
    memset<strong>(</strong>tmp<strong>.</strong>mat<strong>,</strong>0<strong>,</strong><strong>sizeof</strong><strong>(</strong>tmp<strong>.</strong>mat<strong>));</strong><strong>
    for</strong><strong> (</strong><strong>int</strong> i<strong>=</strong>1<strong>;</strong>i<strong>&lt;=</strong>4<strong>;</strong>i<strong>++)</strong>
        tmp<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>i<strong>]=</strong>1<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>1<strong>][</strong>4<strong>] =</strong> x<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>2<strong>][</strong>4<strong>] =</strong> y<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>3<strong>][</strong>4<strong>] =</strong> z<strong>;</strong>
    p<strong>=</strong>matMul<strong>(</strong>tmp<strong>,</strong>p<strong>,</strong>4<strong>);</strong><strong>
    return</strong> p<strong>;
}</strong>
Matrix scale<strong>(</strong>Matrix p<strong>,</strong><strong> double</strong> a<strong>,</strong><strong> double</strong> b<strong>,</strong><strong> double</strong> c<strong>)</strong>    //缩放
<strong>{</strong>
    Matrix tmp<strong>;</strong>
    memset<strong>(</strong>tmp<strong>.</strong>mat<strong>,</strong>0<strong>,</strong><strong>sizeof</strong><strong>(</strong>tmp<strong>.</strong>mat<strong>));</strong><strong>
    for</strong><strong> (</strong><strong>int</strong> i<strong>=</strong>1<strong>;</strong>i<strong>&lt;=</strong>4<strong>;</strong>i<strong>++)</strong>
        tmp<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>i<strong>]=</strong>1<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>1<strong>][</strong>1<strong>] =</strong> a<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>2<strong>][</strong>2<strong>] =</strong> b<strong>;</strong>
    tmp<strong>.</strong>mat<strong>[</strong>3<strong>][</strong>3<strong>] =</strong> c<strong>;</strong>
    p<strong>=</strong>matMul<strong>(</strong>tmp<strong>,</strong>p<strong>,</strong>4<strong>);</strong><strong>
    return</strong> p<strong>;
}</strong>
Matrix rotate<strong>(</strong>Matrix p<strong>,</strong><strong> double</strong> x<strong>,</strong><strong> double</strong> y<strong>,</strong><strong> double</strong> z<strong>,</strong><strong> double</strong> d<strong>)</strong>    // 旋转
<strong>{</strong>
    d<strong> =</strong> d<strong>/</strong>180<strong>*</strong>pi<strong>;</strong><strong>
    double</strong> di<strong> =</strong> sqrt<strong>(</strong>x<strong>*</strong>x<strong>+</strong>y<strong>*</strong>y<strong>+</strong>z<strong>*</strong>z<strong>);</strong>    //单位化
    x<strong>/=</strong>di<strong>,</strong> y<strong>/=</strong>di<strong>,</strong> z<strong>/=</strong>di<strong>;</strong>
    Matrix tmp<strong>;</strong>
    memset<strong>(</strong>tmp<strong>.</strong>mat<strong>,</strong>0<strong>,</strong><strong>sizeof</strong><strong>(</strong>tmp<strong>.</strong>mat<strong>));</strong>
    tmp<strong>.</strong>mat<strong>[</strong>1<strong>][</strong>1<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>x<strong>*</strong>x<strong> +</strong> cos<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>1<strong>][</strong>2<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>x<strong>*</strong>y<strong> -</strong> z<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>1<strong>][</strong>3<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>x<strong>*</strong>z<strong> +</strong> y<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>2<strong>][</strong>1<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>x<strong>*</strong>y<strong> +</strong> z<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>2<strong>][</strong>2<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>y<strong>*</strong>y<strong> +</strong> cos<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>2<strong>][</strong>3<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>y<strong>*</strong>z<strong> -</strong> x<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>3<strong>][</strong>1<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>x<strong>*</strong>z<strong> -</strong> y<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>3<strong>][</strong>2<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>y<strong>*</strong>z<strong> +</strong> x<strong>*</strong>sin<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>3<strong>][</strong>3<strong>] = (</strong>1<strong>-</strong>cos<strong>(</strong>d<strong>))*</strong>z<strong>*</strong>z<strong> +</strong> cos<strong>(</strong>d<strong>);</strong>
    tmp<strong>.</strong>mat<strong>[</strong>4<strong>][</strong>4<strong>]=</strong>1<strong>;</strong>
    p<strong>=</strong>matMul<strong>(</strong>tmp<strong>,</strong>p<strong>,</strong>4<strong>);</strong><strong>
    return</strong> p<strong>;
}</strong>
Matrix work<strong>(</strong><strong>int</strong> n<strong>)    
{</strong>
    Matrix p<strong>;</strong><strong>
    int</strong> i<strong>;</strong><strong>
    double</strong> x<strong>,</strong>y<strong>,</strong>z<strong>,</strong>d<strong>;</strong>
    memset<strong>(</strong>p<strong>.</strong>mat<strong>,</strong>0<strong>,</strong><strong>sizeof</strong><strong>(</strong>p<strong>.</strong>mat<strong>));</strong><strong>
    for</strong><strong> (</strong>i<strong>=</strong>1<strong>;</strong>i<strong>&lt;=</strong>4<strong>;</strong>i<strong>++)</strong>
        p<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>i<strong>]=</strong>1<strong>;</strong><strong>
    char</strong> s<strong>[</strong>100<strong>];</strong><strong>
    while</strong><strong> (</strong>1<strong>)
    {</strong>
        scanf<strong>(</strong>"%s"<strong>,</strong> s<strong>);</strong><strong>
        if</strong><strong> (</strong>strcmp<strong>(</strong>s<strong>,</strong>"translate"<strong>)==</strong>0<strong>)
        {</strong>
            scanf<strong>(</strong>"%lf%lf%lf"<strong>,&amp;</strong>x<strong>,&amp;</strong>y<strong>,&amp;</strong>z<strong>);</strong>
            p<strong>=</strong>translate<strong>(</strong>p<strong>,</strong>x<strong>,</strong>y<strong>,</strong>z<strong>);</strong><strong>
            continue</strong><strong>;
        }</strong><strong>
        if</strong><strong> (</strong>strcmp<strong>(</strong>s<strong>,</strong>"scale"<strong>)==</strong>0<strong>)
        {</strong>
            scanf<strong>(</strong>"%lf%lf%lf"<strong>,&amp;</strong>x<strong>,&amp;</strong>y<strong>,&amp;</strong>z<strong>);</strong>
            p<strong>=</strong>scale<strong>(</strong>p<strong>,</strong>x<strong>,</strong>y<strong>,</strong>z<strong>);</strong><strong>
            continue</strong><strong>;
        }</strong><strong>
        if</strong><strong> (</strong>strcmp<strong>(</strong>s<strong>,</strong>"rotate"<strong>)==</strong>0<strong>)
        {</strong>
            scanf<strong>(</strong>"%lf%lf%lf%lf"<strong>,&amp;</strong>x<strong>,&amp;</strong>y<strong>,&amp;</strong>z<strong>,&amp;</strong>d<strong>);</strong>
            p<strong>=</strong>rotate<strong>(</strong>p<strong>,</strong>x<strong>,</strong>y<strong>,</strong>z<strong>,</strong>d<strong>);</strong><strong>
            continue</strong><strong>;
        }</strong><strong>
        if</strong><strong> (</strong>strcmp<strong>(</strong>s<strong>,</strong>"repeat"<strong>)==</strong>0<strong>)
        {</strong><strong>
            int</strong> n1<strong>;</strong>
            scanf<strong>(</strong>"%d"<strong>, &amp;</strong>n1<strong>);</strong>
            p<strong> =</strong> matMul<strong>(</strong>work<strong>(</strong>n1<strong>),</strong>p<strong>,</strong>4<strong>);
        }</strong><strong>
        if</strong><strong> (</strong>strcmp<strong>(</strong>s<strong>,</strong>"end"<strong>)==</strong>0<strong>)
        {</strong>
            p<strong>=</strong>quickMatPow<strong>(</strong>p<strong>,</strong>4<strong>,</strong>n<strong>);</strong><strong>
            return</strong> p<strong>;
        }
    }
}</strong><strong>
int</strong><strong> main</strong><strong>()
{</strong><strong>
    int</strong> n<strong>,</strong>i<strong>;</strong>
    Matrix p<strong>;</strong><strong>
    double</strong> a<strong>[</strong>4<strong>];</strong><strong>
    double</strong> tx<strong>,</strong>ty<strong>,</strong>tz<strong>,</strong>td<strong>;</strong><strong>
    while</strong><strong>(</strong>scanf<strong>(</strong>"%d"<strong>, &amp;</strong>n<strong>) &amp;&amp;</strong> n<strong>!=</strong>0<strong>)
    {</strong>
        p<strong>=</strong>work<strong>(</strong>1<strong>);</strong><strong>
        while</strong><strong> (</strong>n<strong>--)
        {</strong>
            scanf<strong>(</strong>"%lf%lf%lf"<strong>,&amp;</strong>a<strong>[</strong>1<strong>],&amp;</strong>a<strong>[</strong>2<strong>],&amp;</strong>a<strong>[</strong>3<strong>]);</strong>
            tx<strong>=</strong>a<strong>[</strong>1<strong>],</strong>ty<strong>=</strong>a<strong>[</strong>2<strong>],</strong>tz<strong>=</strong>a<strong>[</strong>3<strong>],</strong>td<strong>=</strong>1<strong>;</strong><strong>
            for</strong><strong> (</strong>i<strong>=</strong>1<strong>;</strong> i<strong>&lt;=</strong>4<strong>;</strong>i<strong>++)
            {</strong>
                a<strong>[</strong>i<strong>] =</strong>p<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>1<strong>]*</strong>tx<strong> +</strong>p<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>2<strong>]*</strong>ty<strong> +</strong>p<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>3<strong>]*</strong>tz<strong> +</strong> p<strong>.</strong>mat<strong>[</strong>i<strong>][</strong>4<strong>]*</strong>td<strong>;</strong><strong>
                if</strong><strong> (</strong>fabs<strong>(</strong>a<strong>[</strong>i<strong>])&lt;</strong>eps<strong>)</strong> a<strong>[</strong>i<strong>]=</strong>0.0<strong>;
            }</strong> 
           printf<strong>(</strong>"%.2lf %.2lf %.2lf\n"<strong>,</strong>a<strong>[</strong>1<strong>],</strong>a<strong>[</strong>2<strong>],</strong>a<strong>[</strong>3<strong>]);
        }</strong>
        printf<strong>(</strong>"\n"<strong>);
    }</strong><strong>
    return</strong> 0<strong>; 
}</strong></span></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>