<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修各种排序（二）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>各种排序（二）</center></div><div class='banquan'>原文出处:本文由博客园博主yu__xuan提供。<br/>
原文连接:https://www.cnblogs.com/poi-bolg-poi/p/12006080.html</div><br>
    <ul>
<li>本文中 <span class="math inline">\(n\)</span> 代表着待排序序列的长度。</li>
<li>算法是否稳定：若 <span class="math inline">\(a_i = a_j \ , \ i &lt; j\)</span>，排序后若<span class="math inline">\(i &lt; j\)</span> 则稳定，反之不稳定。（可能有点歧义凑活看）</li>
</ul>
<h3 id="归并排序">归并排序</h3>
<p>用了二分的思想。<br />
在递归的过程中不断将需要排序的区间缩小，使小区间有序后，再使大区间变得有序会简单很多。</p>
<p>最差时间复杂度:<span class="math inline">\(O(nlogn)\)</span><br />
最优时间复杂度:<span class="math inline">\(O(nlogn)\)</span><br />
平均时间复杂度:<span class="math inline">\(O(nlogn)\)</span><br />
算法是否稳定：是</p>
<pre><code>void mergesort(int l,int r,int mid) {//将[l,r]区间排好序
    int i=l,j=mid+1,cnt=0;//[l,mid]与[mid+1,r]已经有序了，所以可以进行下面的操作。
    while(i&lt;=mid&amp;&amp;j&lt;=r) temp[++cnt]=a[i]&lt;=a[j]?a[i++]:a[j++];
    while(i&lt;=mid) temp[++cnt]=a[i++];
    while(j&lt;=r) temp[++cnt]=a[j++];
    for(int i=l;i&lt;=r;++i) a[i]=temp[i-l+1];
}
void merge(int l,int r) {//不断将区间缩小
    if(l==r) return;
    int mid=(l+r)&gt;&gt;1;
    merge(l,mid),merge(mid+1,r);
    mergesort(l,r,mid);return;//递归，先给小区间排序后大区间。
}
merge(1,n);</code></pre>
<p>上张图理解一下：<img src="./images/各种排序（二）0.png" /></p>
<p>可用于求逆序对的个数。</p>
<h3 id="堆排序">堆排序</h3>
<p>不想写，咕咕咕。</p>
<h3 id="快速排序">快速排序</h3>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>