<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++基础学习（一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++基础学习（一）</center></div><div class='banquan'>原文出处:本文由博客园博主孔胡子提供。<br/>
原文连接:https://www.cnblogs.com/KongHuZi/p/11188991.html</div><br>
    <h1>1. 数据类型</h1>
<h2>1.1 基本内置类型</h2>
<p>　　我们通过下列代码可知电脑上的基本数据类型的大小：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include&lt;iostream&gt;  
<span style="color: #008080;"> 2</span> #include&lt;<span style="color: #0000ff;">string</span>&gt;  
<span style="color: #008080;"> 3</span> #include &lt;limits&gt;  
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">char: \t\t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">char</span><span style="color: #000000;">);
</span><span style="color: #008080;">10</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">11</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">char</span>&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">12</span>     
<span style="color: #008080;">13</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">float: \t\t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">float</span><span style="color: #000000;">);
</span><span style="color: #008080;">14</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">float</span>&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">15</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">float</span>&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">16</span>     
<span style="color: #008080;">17</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">int: \t\t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;">);
</span><span style="color: #008080;">18</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">19</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">int</span>&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">20</span>     
<span style="color: #008080;">21</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">unsigned: \t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(unsigned);
</span><span style="color: #008080;">22</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;unsigned&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">23</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;unsigned&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">24</span>     
<span style="color: #008080;">25</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">long: \t\t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">long</span><span style="color: #000000;">);
</span><span style="color: #008080;">26</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">long</span>&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">27</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">long</span>&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">28</span>     
<span style="color: #008080;">29</span>     
<span style="color: #008080;">30</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">double: \t</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">所占字节数：</span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">double</span><span style="color: #000000;">);
</span><span style="color: #008080;">31</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最大值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">::max)();
</span><span style="color: #008080;">32</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t最小值：</span><span style="color: #800000;">"</span> &lt;&lt; (numeric_limits&lt;<span style="color: #0000ff;">double</span>&gt;::min)() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">33</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">34</span> }</pre>
</div>
<p>&nbsp;</p>
<h2>1.2 const 和 auto&nbsp;</h2>
<h3>1. const 基本介绍</h3>
<p>　　const对象一旦创建后其值就不能再改变，所以const对象必须初始化。<strong>编译器在编译过程会把用到该变量的地方替换成相应的值</strong>，为了执行上述的替换，编译器必须知道变量的初始值。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i = get_size();  <span style="color: #008000;">//</span><span style="color: #008000;"> 运行时初始化</span>
<span style="color: #008080;">2</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> j = <span style="color: #800080;">3</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 编译时初始化</span>
<span style="color: #008080;">3</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> k;<span style="color: #008000;">//</span><span style="color: #008000;"> 错误</span></pre>
</div>
<p>　　默认情况下，const对象仅在文件中有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。<strong>如果想在在文件中得到共享，即在一个文件中定义const，而在其他多个文件中声明并使用它</strong>。可以使用 extern 关键词，对于const变量不管是声明还是定义都添加 extern 关键词，这样只需定义一次就可以了。</p>
<p>　　但是需要注意下面这个<em><a href="https://www.cnblogs.com/fuzhe1989/p/3554345.html#top" target="_blank">例子</a></em>：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> A {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">int</span>*<span style="color: #000000;"> ptr;
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">int</span> k = <span style="color: #800080;">5</span>, r = <span style="color: #800080;">6</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">const</span> A a = { &amp;<span style="color: #000000;">k };<span style="color: #008000;">//<span style="color: #008000;"> const声明的变量必须初始化</span></span>
</span><span style="color: #008080;"> 9</span>     a.ptr = &amp;r; <span style="color: #008000;">//</span><span style="color: #008000;"> !error</span>
<span style="color: #008080;">10</span>     *a.ptr = <span style="color: #800080;">7</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> no error</span>
<span style="color: #008080;">11</span> }</pre>
</div>
<p>　　可以看到，const 修饰 a 之后其实要求的是 ptr （存储一个地址）不能变，但其实可以改变 *ptr&mdash;&mdash; c++ 保持物理常量行不变，逻辑常量性不保证。</p>
<h3>2. 类中的const变量</h3>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> A {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i; <span style="color: #008000;">//</span><span style="color: #008000;"> 构造类是初始化。非静态</span>
<span style="color: #008080;"> 3</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> B {
</span><span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i;<span style="color: #008000;">//</span><span style="color: #008000;"> 静态</span>
<span style="color: #008080;"> 7</span> <span style="color: #000000;">};
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> B::i = <span style="color: #800080;">3</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 常在类中中直接声明</span>
<span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">12</span> <span style="color: #000000;">{
</span><span style="color: #008080;">13</span>     A bf = { <span style="color: #800080;">1</span><span style="color: #000000;"> };
</span><span style="color: #008080;">14</span>  
<span style="color: #008080;">15</span> }</pre>
</div>
<p>&nbsp;</p>
<h3>3. 顶/底层 const&nbsp; 和 auto</h3>
<p>　　下面是顶层 const 和 底层 const 的实例：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #008000;">/*</span>
<span style="color: #008080;"> 2</span> <span style="color: #008000;">    ①
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">    顶层const：指针本身是个常量
</span><span style="color: #008080;"> 4</span> <span style="color: #008000;">    底层const：指针所指的对象是一个常量
</span><span style="color: #008080;"> 5</span>     
<span style="color: #008080;"> 6</span> <span style="color: #008000;">    ②
</span><span style="color: #008080;"> 7</span> <span style="color: #008000;">    auto一般会忽略顶层const，会保留底层const
</span><span style="color: #008080;"> 8</span> <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span> #include<span style="color: #800000;">"</span><span style="color: #800000;">iostream</span><span style="color: #800000;">"</span>
<span style="color: #008080;">11</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;">12</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">13</span> <span style="color: #000000;">{
</span><span style="color: #008080;">14</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> i = <span style="color: #800080;">19</span>; <span style="color: #008000;">//</span><span style="color: #008000;">i值不能改变，顶层const</span>
<span style="color: #008080;">15</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> *p = &amp;i;<span style="color: #008000;">//</span><span style="color: #008000;">p值可以改变，底层const（*P值不能改变-&gt;指针所指的对象是个常量）</span>
<span style="color: #008080;">16</span>     
<span style="color: #008080;">17</span>     <span style="color: #0000ff;">int</span> z = <span style="color: #800080;">18</span><span style="color: #000000;">;
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">int</span> *<span style="color: #0000ff;">const</span> o = &amp;z;<span style="color: #008000;">//</span><span style="color: #008000;">o值不能改变，顶层const</span>
<span style="color: #008080;">19</span>     <span style="color: #0000ff;">int</span> t = <span style="color: #800080;">13</span><span style="color: #000000;">;
</span><span style="color: #008080;">20</span>     <span style="color: #008000;">//</span><span style="color: #008000;">o = &amp;t; </span><span style="color: #008000;">//</span><span style="color: #008000;">错误，因为o是顶层，o值不能改变
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>     <span style="color: #008000;">//</span><span style="color: #008000;">打印类型</span>
<span style="color: #008080;">23</span>     cout &lt;&lt; typeid(i).name() &lt;&lt; endl;<span style="color: #008000;">//</span><span style="color: #008000;">int</span>
<span style="color: #008080;">24</span>     cout &lt;&lt; typeid(p).name() &lt;&lt; endl;<span style="color: #008000;">//</span><span style="color: #008000;">int const *</span>
<span style="color: #008080;">25</span>     cout &lt;&lt; typeid(*p).name() &lt;&lt; endl;<span style="color: #008000;">//</span><span style="color: #008000;">int </span>
<span style="color: #008080;">26</span>     cout &lt;&lt; typeid(o).name() &lt;&lt; endl &lt;&lt; endl;<span style="color: #008000;">//</span><span style="color: #008000;"> int *</span>
<span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span>     auto a =<span style="color: #000000;"> o;
</span><span style="color: #008080;">29</span>     <span style="color: #0000ff;">int</span> y = <span style="color: #800080;">12</span><span style="color: #000000;">;
</span><span style="color: #008080;">30</span>     a = &amp;y; <span style="color: #008000;">//</span><span style="color: #008000;"> a值可改变，说明忽略了o的顶层const。对比第20行的o</span>
<span style="color: #008080;">31</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">*a=</span><span style="color: #800000;">"</span> &lt;&lt; *a &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t a类型</span><span style="color: #800000;">"</span> &lt;&lt; typeid(a).name()&lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span>     auto b =<span style="color: #000000;"> p;
</span><span style="color: #008080;">34</span>     b = &amp;y; <span style="color: #008000;">//</span><span style="color: #008000;">p是底层const，b也是底层const，b值可改变，但是*b不能改变
</span><span style="color: #008080;">35</span>     <span style="color: #008000;">//</span><span style="color: #008000;">*b = 9; </span><span style="color: #008000;">//</span><span style="color: #008000;">报错，b是底层const，b指针所指的对象不能改变。---》说明auto保留了底层const</span>
<span style="color: #008080;">36</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">*b=</span><span style="color: #800000;">"</span> &lt;&lt; *b &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t b类型</span><span style="color: #800000;">"</span> &lt;&lt; typeid(b).name() &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> 
<span style="color: #008080;">39</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">40</span> }</pre>
</div>
<h3>&nbsp;4. const 修饰函数</h3>
<p>　　const 可以修饰类返回值（一般用于类返回值是指针的形式。<strong>修饰返回值的函数没有意义</strong>）。也可以写在函数后（如第7行），标是允许修改类的成员变量（mutable关键字修饰的成员变量除外）.</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">struct</span><span style="color: #000000;"> A {
</span><span style="color: #008080;"> 2</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
</span><span style="color: #008080;"> 3</span>     mutable <span style="color: #0000ff;">int</span><span style="color: #000000;"> j;
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">void</span> f() <span style="color: #0000ff;">const</span><span style="color: #000000;">{
</span><span style="color: #008080;"> 6</span>         <span style="color: #008000;">//</span><span style="color: #008000;">this-&gt;i++;</span><span style="color: #008000;">//</span><span style="color: #008000;"> error, const 修饰的函数不能改变类成员变量。</span>
<span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">this</span>-&gt;j++;<span style="color: #008000;">//</span><span style="color: #008000;"> 除非是使用mutable关键字</span>
<span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span> 
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span>*<span style="color: #000000;"> g() {  
</span><span style="color: #008080;">11</span>         <span style="color: #0000ff;">int</span> k = <span style="color: #800080;">2</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">return</span> &amp;<span style="color: #000000;">k;
</span><span style="color: #008080;">13</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>     <span style="color: #0000ff;">int</span> *<span style="color: #0000ff;">const</span><span style="color: #000000;"> h() {  
</span><span style="color: #008080;">16</span>         <span style="color: #0000ff;">int</span> k = <span style="color: #800080;">2</span><span style="color: #000000;">;
</span><span style="color: #008080;">17</span>         <span style="color: #0000ff;">return</span> &amp;<span style="color: #000000;">k;
</span><span style="color: #008080;">18</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">19</span> 
<span style="color: #008080;">20</span> <span style="color: #000000;">};
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span>     A a = { <span style="color: #800080;">1</span> , <span style="color: #800080;">2</span><span style="color: #000000;">};
</span><span style="color: #008080;">25</span> <span style="color: #000000;">    a.f();
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;">28</span> <span style="color: #008000;">        a.g() 返回的是 const int *k 类型。是底层const, *k 不能改变
</span><span style="color: #008080;">29</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;">30</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span>* k =<span style="color: #000000;"> a.g();
</span><span style="color: #008080;">31</span>     <span style="color: #008000;">//</span><span style="color: #008000;">*k = 3; </span><span style="color: #008000;">//</span><span style="color: #008000;"> 非法</span>
<span style="color: #008080;">32</span>     k = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>();<span style="color: #008000;">//</span><span style="color: #008000;"> 合法</span>
<span style="color: #008080;">33</span> 
<span style="color: #008080;">34</span> 
<span style="color: #008080;">35</span>     <span style="color: #008000;">/*</span>
<span style="color: #008080;">36</span> <span style="color: #008000;">        a.h() 返回的是  int *const b 类型。是顶层const, b 不能改变
</span><span style="color: #008080;">37</span>     <span style="color: #008000;">*/</span>
<span style="color: #008080;">38</span>     <span style="color: #0000ff;">int</span>* <span style="color: #0000ff;">const</span> b =<span style="color: #000000;"> a.h();
</span><span style="color: #008080;">39</span>     *b = <span style="color: #800080;">3</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 合法
</span><span style="color: #008080;">40</span>     <span style="color: #008000;">//</span><span style="color: #008000;">b = new int();</span><span style="color: #008000;">//</span><span style="color: #008000;"> 非法</span>
<span style="color: #008080;">41</span> }</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　</p>
<h1>2. vector 类型</h1>
<h2>2.1 vector 基本操作</h2>
<ul>
<li>v.empty()&nbsp;</li>
<li>v.size()&nbsp; 返回 vector 对象中元素个数，返回值类型由 vector 定义的 size_type 决定 （vector&lt;int&gt;::size_type）</li>
<li><strong><span style="text-decoration: underline;">v[n] 返回 v 中第 n 个位置上元素的引用</span></strong></li>
<li>v1 = v2 用 v2 中元素的拷贝替换 v1 中的元素</li>
<li>v1 == v2 当且仅当元素数量 and 元素值相同</li>
</ul>
<h2>2.2 访问 vector&nbsp;</h2>
<ul>
<li>可以通过下标形式<span style="background-color: #ffff00; color: #ff6600;">访问 </span>vector，但是不能通过下标形式<span style="background-color: #ffff00; color: #ff6600;">添加</span>元素而是，push_back()</li>
<li>使用 range-base-for 或者 iterator 遍历</li>
</ul>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include&lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include&lt;vector&gt;
<span style="color: #008080;"> 3</span> #include&lt;typeinfo&gt;
<span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
</span><span style="color: #008080;"> 6</span>     std::vector&lt;std::<span style="color: #0000ff;">string</span>&gt; v1{ <span style="color: #800000;">"</span><span style="color: #800000;">Tom</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">Jack</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">Michael</span><span style="color: #800000;">"</span><span style="color: #000000;"> };
</span><span style="color: #008080;"> 7</span>     std::vector&lt;<span style="color: #0000ff;">int</span>&gt; v2(<span style="color: #800080;">5</span>, <span style="color: #800080;">7</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>     
<span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> i : v1) {
</span><span style="color: #008080;">10</span>         std::cout &lt;&lt; i &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">11</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">12</span>     
<span style="color: #008080;">13</span>     std::cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">====================</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">14</span> 
<span style="color: #008080;">15</span>     <span style="color: #0000ff;">for</span> (auto k = v2.begin(); k != v2.end(); ++<span style="color: #000000;">k) {
</span><span style="color: #008080;">16</span>         std::cout &lt;&lt; *k &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">18</span> 
<span style="color: #008080;">19</span>     std::cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">====================</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">20</span>     
<span style="color: #008080;">21</span>     v1.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">good dog</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">22</span>     std::vector&lt;std::<span style="color: #0000ff;">string</span>&gt;::iterator iter =<span style="color: #000000;"> v1.begin();
</span><span style="color: #008080;">23</span>     <span style="color: #0000ff;">for</span> (; iter != v1.end(); ++<span style="color: #000000;">iter) {
</span><span style="color: #008080;">24</span>         std::cout &lt;&lt; *iter &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">25</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">26</span>     
<span style="color: #008080;">27</span>     std::cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">====================</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">28</span>     
<span style="color: #008080;">29</span>     v2[<span style="color: #800080;">0</span>] = <span style="color: #800080;">9</span><span style="color: #000000;">;
</span><span style="color: #008080;">30</span>     <span style="color: #0000ff;">for</span> (decltype(v2.size()) i = <span style="color: #800080;">0</span>; i &lt; v2.size(); ++i) {  <span style="color: #008000;">//</span><span style="color: #008000;"> v2.size() 返回的是无符号数（&gt;=0）,可以用 int,但需要保证不能为负数，否则无符号数会自动合法话。可运行36~38行</span>
<span style="color: #008080;">31</span>         std::cout &lt;&lt; v2[i] &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">32</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">33</span> 
<span style="color: #008080;">34</span>     std::cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">====================</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> std::endl;
</span><span style="color: #008080;">35</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 会输出 &ldquo;大于&rdquo;</span>
<span style="color: #008080;">36</span>     <span style="color: #008000;">/*</span><span style="color: #008000;">decltype(v2.size()) i = -1;
</span><span style="color: #008080;">37</span> <span style="color: #008000;">    if( i &gt; 10)
</span><span style="color: #008080;">38</span> <span style="color: #008000;">        std::cout &lt;&lt; "大于" &lt;&lt; std::endl;</span><span style="color: #008000;">*/</span> 
<span style="color: #008080;">39</span> 
<span style="color: #008080;">40</span> 
<span style="color: #008080;">41</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">42</span> }</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>3. 迭代器</h1>
<ul>
<li>我们知道已经可以使用下标运算符来访问 string 对象或 vector 对象的元素（<span style="color: #000000; background-color: #ffff00;">因为只有一些标准库类型有下标运算符，并非全都如此</span>），但是<span style="text-decoration: underline;"><em><strong>还有一种更通用的机制可以实现</strong></em></span>&mdash;&mdash;使用迭代器。</li>
<li><span style="background-color: #ffff00;"><strong>如果容器为空</strong></span>，可通过 iter.end() != iter.begin() 来判断，例如：有 string str 对象，则 if (str.end() != str.begin()) {.....} 来<span style="background-color: #ffff00;"><strong>保证 str 不为空</strong></span></li>
<li><span style="text-decoration: underline;"><em><strong>凡使用了迭代器的循环体，都不要向迭代器所属容器中添加元素</strong></em></span></li>
</ul>
<h2><strong>3.1 迭代器和指针</strong></h2>
<p><strong>　　</strong>我们可能有疑问，如果是 vector&lt;int&gt; v1 = {1,2,3}，那么通过迭代器迭代时，每次的迭代器是 1，2，3 三个数字的地址吗（<span style="background-color: #ffff00;">因为我们可以通过 *iter 来取得数值</span> ）？答案是不是的。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include&lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include&lt;vector&gt;
<span style="color: #008080;"> 3</span> #include&lt;typeinfo&gt;
<span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
</span><span style="color: #008080;"> 6</span>     std::vector&lt;<span style="color: #0000ff;">int</span>&gt; v = { <span style="color: #800080;">1</span> ,<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span><span style="color: #000000;"> };
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> i : v)  
</span><span style="color: #008080;"> 8</span>         std::cout &lt;&lt; typeid(i).name() &lt;&lt; &amp;i &lt;&lt;<span style="color: #000000;">std::endl;
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">for</span> (auto k = v.cbegin(); k != v.cend(); ++k)  <span style="color: #008000;">//</span><span style="color: #008000;"> cbegin()得到const_iterator。begin()得到iterator。如果只进行读操作可用前者</span>
<span style="color: #008080;">10</span>         std::cout &lt;&lt; typeid(k).name() &lt;&lt;<span style="color: #000000;">std::endl;
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> }</pre>
</div>
<p>　　我们可以比较 range-based-for 和 iterator-for 的输出类型，其中第八行 &amp;i 输出了 v 中的元素的地址。</p>
<p>　　那迭代器到底是啥？<a href="https://blog.csdn.net/gogokongyin/article/details/51206225" target="_blank">此处有解释。</a></p>
<p>　　<a class="question-hyperlink" href="https://stackoverflow.com/questions/29578219/range-based-for-loop-vs-regular-iterator-for-loop" target="_blank">range based for loop vs regular iterator for loop</a></p>
<p>　　</p>
<p><strong>　　</strong></p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>