<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修48.QT-网络通信讲解1' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>48.QT-网络通信讲解1</center></div><div class='banquan'>原文出处:本文由博客园博主NQian提供。<br/>
原文连接:https://www.cnblogs.com/lifexy/p/11315263.html</div><br>
    <p><span style="font-size: 18px; color: #008000; background-color: #ffff99;"><strong>网络概念</strong></span></p>
<ul>
<li><span style="font-size: 15px;">MAC地址<span style="color: #ff0000;">(硬件地址)</span></span></li>
<li><span style="font-size: 15px;">网络IP地址<span style="color: #ff0000;">(如192.168.1.101)</span></span></li>
<li><span style="font-size: 15px;">网络端口<span style="color: #ff0000;">(实现多路通信,用来给不同应用程序来区分使用,范围0~65535，比如浏览网页服务(80端口)， FTP服务(21端口) )</span></span></li>
</ul>
<p><span style="font-size: 18px; color: #008000; background-color: #ffff99;"><strong>交换机和路由器</strong></span></p>
<ul>
<li><span style="font-size: 15px;">路由器在网络层，路由器可以处理TCP/IP协议，交换机不可以.</span></li>
<li><span style="font-size: 15px;">交换机在中继层。路由器根据IP地址寻址，交换机根据MAC地址寻址。</span></li>
<li><span style="font-size: 15px;">路由器提供防火墙的服务，具有虚拟拨号上网功能，交换机不具备这些功能。</span></li>
</ul>
<p><span style="font-size: 15px; color: #800000;"><strong>交换机</strong></span></p>
<p><span style="font-size: 15px;">端到端转发，基于MAC地址实现不同设备间的数据转发,转发速度快.</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>路由器</strong></span></p>
<p><span style="font-size: 15px;">根据实际数据路线转发,基于网络IP地址实现不同网络间的数据转发</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>静态路由</strong></span></p>
<p><span style="font-size: 15px;">指网络管理员配置好的转发路径,能够直接确定数据路线转发,大型和复杂的网络环境通常不宜采用静态路由,当连线一改变,则静态路由需要重新配置</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>动态路由</strong></span></p>
<p><span style="font-size: 15px;">路由器根据算法自动地建立自己的路由表实现数据转发,由于需要路由器之间频繁地交换各自的路由表,从而安全保密性低.</span></p>
<p><span style="font-size: 15px;"><strong>&nbsp;</strong></span></p>
<p><span style="font-size: 18px; color: #008000; background-color: #ffff99;"><strong>网络协议</strong></span></p>
<p><span style="font-size: 15px;">为数据交换而建立的规则、标准或约定的集合</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>协议栈</strong></span></p>
<p><span style="font-size: 15px;">&nbsp;<img src="./images/48.QT-网络通信讲解10.png" alt="" /></span></p>
<p><span style="font-size: 15px;">如上图所示,可以看到应用层的FTP协议是基于传输层的TCP协议来实现文件共享传输.而传输层的TCP协议则基于网络层的IP实现的</span></p>
<p><span style="font-size: 15px;">默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息</span></p>
<p><span style="font-size: 15px;">&nbsp;</span></p>
<p><span style="font-size: 18px; color: #008000; background-color: #ffff99;"><strong>TCP</strong><strong>和UDP</strong></span></p>
<p><span style="color: #800000;"><strong><span style="font-size: 15px;">TCP(传输控制协议)</span></strong></span></p>
<p><span style="font-size: 15px;">面向连接的协议, 主要用于大量数据的场合,比如文件传输,一个TCP连接必须要经过3次握手才能建立</span></p>
<p><span style="font-size: 15px;">&nbsp;<img src="./images/48.QT-网络通信讲解11.png" alt="" /></span></p>
<ol>
<li><span style="font-size: 15px;">客户端向服务器请求发送信号</span></li>
<li><span style="font-size: 15px;">服务器接收到后,向客户端发送回应信号,并提供seq序列号<span style="color: #ff0000;">(表示每个数据包的编号,因为数据是被拆成多个数据包发送的)</span>.告诉客户端,你下个数据包序号从指定值开始</span></li>
<li><span style="font-size: 15px;">客户端再次发出ACK确定服务器的发送ACK请求同步要求</span></li>
</ol>
<p><span style="font-size: 15px;">然后握手完成后,便开始进行数据传输了.</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>为什么要第3</strong><strong>次握手,</strong><strong>而不是2</strong><strong>次握手？</strong></span></p>
<p><span style="font-size: 15px;">避免重复连接请求,如果第一次连接请求超时了, 这时客户端假如重发请求,而第一次连接请求最终还是发送到服务器了,则服务器将再次重复接受到该请求,由于服务器之前已经确定过了第3次确定请求,所以服务器可以直接抛弃不管了<span style="color: #ff0000;">(假如没有第3次确认,则服务器无法避免重连)</span></span></p>
<p><span style="font-size: 15px;">一个TCP断连则需要4次挥手才能断开</span></p>
<p><span style="font-size: 15px;">&nbsp;<img src="./images/48.QT-网络通信讲解12.png" alt="" /></span></p>
<p><span style="font-size: 15px;">1.客户端发送一个FIN，用来关闭客户到服务器的数据传送</span></p>
<p><span style="font-size: 15px;">2.服务器收到这个FIN，它发回一个ACK，确认序号为收到的seq序号加1。</span></p>
<p><span style="font-size: 15px;">3.服务器关闭与客户端的连接，发送一个FIN给客户端A</span></p>
<p><span style="font-size: 15px;">4.客户端发回ACK报文确认，并将确认序号设置为收到序号加1</span></p>
<p><span style="color: #800000;"><strong><span style="font-size: 15px;">UDP(用户数据报协议)</span></strong></span></p>
<p><span style="font-size: 15px;">无连接的协议, 主要用于不要求分组顺序到达、少量数据的传输场合, 数据传输效率高.缺点容易掉包.</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px; color: #008000; background-color: #ffff99;"><strong>QT</strong><strong>网络编程</strong></span></p>
<p><span style="font-size: 15px;">Qt Network模块提供的类允许编写 TCP/IP clients 和 servers、以及FTP和HTTP等常用协议<span style="color: #ff0000;">(后续章节讲解FTP和HTTP)</span></span></p>
<p><span style="font-size: 15px;">而QTcpSocket和QTcpServer类则是实现TCP客户端和服务器用的.</span></p>
<p><span style="font-size: 15px; color: #800000;"><strong>QTcpSocket </strong></span></p>
<p><span style="font-size: 15px;">在网络编程中, QTcpSocket支持以下两种访问方式</span></p>
<p><span style="color: #0000ff;"><strong><span style="font-size: 15px;">1)异步(非阻塞)访问</span></strong></span></p>
<p><span style="font-size: 15px;">异步方式通过QTcpSocket的信号与槽实现,比如当我们调用connectToHost()连接服务器时,此时并非立即连接成功,所以我们需要等待connected()信号触发后,才知道连接成功,当然也可以通过信号error()来处理与服务器的连接发生错误的异常事件.</span></p>
<p><span style="color: #0000ff;"><strong><span style="font-size: 15px;">2) 同步(阻塞)访问</span></strong></span></p>
<p><span style="font-size: 15px;">通过waitForXxxx()函数实现阻塞,最好使用多线程实现,否则的话,会导致界面也会进入阻塞.</span></p>
<p><span style="font-size: 15px;">QTcpSocket同步连接服务器步骤如下:</span></p>
<div class="cnblogs_code">
<pre>socket-&gt;connectToHost(<span style="color: #800000;">"</span><span style="color: #800000;">192.168.1.101</span><span style="color: #800000;">"</span>, <span style="color: #800080;">8088</span>);         <span style="color: #008000;">//</span><span style="color: #008000;">连接服务器</span>
<span style="color: #0000ff;">if</span> (socket-&gt;waitForConnected(<span style="color: #800080;">1000</span>))            <span style="color: #008000;">//</span><span style="color: #008000;">阻塞等待1000ms</span><span style="color: #000000;">
      qDebug(</span><span style="color: #800000;">"</span><span style="color: #800000;">Connected!</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #0000ff;">else</span>
      <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
socket</span>-&gt;write(data, len);                  <span style="color: #008000;">//</span><span style="color: #008000;">写数据</span><span style="color: #000000;">
socket </span>-&gt;<span style="color: #000000;">waitForBytesWritten();
<br /></span></pre>
<pre>socket-&gt;waitForReadyRead();　　　　　　　　　　<span style="color: #008000;">//等待读取数据</span></pre>
<pre>qDebug()&lt;&lt; "Received Bytes:" &lt;&lt; socket-&gt;read(buf, sizeof(buf)-1);</pre>
<pre><code><span style="color: #000000;">
socket </span>-&gt;disconnectFromHost();            <span style="color: #008000;">//</span><span style="color: #008000;">断开连接</span>
socket -&gt;waitForDisconnected(); <br /><br /></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-size: 15px;">未完待续,下章来学习客户端与服务器实例</span></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>