<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Codeforces Beta Round #2' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Codeforces Beta Round #2</center></div><div class='banquan'>原文出处:本文由博客园博主巫提供。<br/>
原文连接:https://www.cnblogs.com/guttentag/p/11782765.html</div><br>
    <div class="header">
<div class="title" style="text-align: center;"><a href="https://codeforces.com/contest/2">Codeforces Beta Round #2</a></div>
<div class="title" style="text-align: center;">&nbsp;</div>
<div class="title" style="text-align: center;"><span style="font-size: 18px;"><a href="https://codeforces.com/contest/2/problem/A" target="_blank">A. Winner</a></span></div>
<div class="title" style="text-align: center;">&nbsp;</div>
<div class="time-limit">
<div class="property-title">The winner of the card game popular in Berland "Berlogging" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line "<span class="tex-font-style-tt">name score", where&nbsp;<span class="tex-font-style-tt">name&nbsp;is a player's name, and&nbsp;<span class="tex-font-style-tt">score&nbsp;is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to&nbsp;<span class="tex-span"><em>m</em>) at the end of the game, than wins the one&nbsp;<span class="tex-font-style-it">of them&nbsp;who scored at least&nbsp;<span class="tex-span"><em>m</em>&nbsp;points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.</span></span></span></span></span></span></div>
</div>
</div>
<div class="input-specification">
<div class="section-title">Input</div>
<p>The first line contains an integer number&nbsp;<span class="tex-span"><em>n</em>&nbsp;(<span class="tex-span">1&thinsp;&thinsp;&le;&thinsp;&thinsp;<em>n</em>&thinsp;&thinsp;&le;&thinsp;&thinsp;1000),&nbsp;<span class="tex-span"><em>n</em>&nbsp;is the number of rounds played. Then follow&nbsp;<span class="tex-span"><em>n</em>&nbsp;lines, containing the information about the rounds in "<span class="tex-font-style-tt">name score" format in chronological order, where&nbsp;<span class="tex-font-style-tt">name&nbsp;is a string of lower-case Latin letters with the length from 1 to 32, and&nbsp;<span class="tex-font-style-tt">score&nbsp;is an integer number between -1000 and 1000, inclusive.</span></span></span></span></span></span></span></p>
</div>
<div class="output-specification">
<div class="section-title">Output</div>
<p>Print the name of the winner.</p>
</div>
<div class="sample-tests">
<div class="section-title">Examples</div>
<div class="sample-test">
<div class="input">
<div class="title">input</div>
<pre>3<br />mike 3<br />andrew 5<br />mike 2</pre>
</div>
<div class="output">
<div class="title">output</div>
<pre>andrew</pre>
</div>
<div class="input">
<div class="title">input</div>
<pre>3<br />andrew 3<br />andrew 2<br />mike 5</pre>
</div>
<div class="output">
<div class="title">output</div>
<pre>andrew<br />题意：大概意思就是给你一些人玩游戏的过程，问你游戏结束时，谁的总分最高，要注意的就是如果最后总分有一样的，那就是先得到最高分的人获胜。<br />代码奉上：</pre>
<div class="cnblogs_code">
<pre>#include &lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">string</span> s[<span style="color: #800080;">10002</span><span style="color: #000000;">],a;
</span><span style="color: #0000ff;">int</span> n,i,o[<span style="color: #800080;">100032</span>],m=-<span style="color: #800080;">0x3f3f3f</span><span style="color: #000000;">,temp;
map</span>&lt;<span style="color: #0000ff;">string</span>,<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">p,t;
main()
{
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>; i&lt;n; i++<span style="color: #000000;">)
    {
        cin</span>&gt;&gt;s[i]&gt;&gt;<span style="color: #000000;">o[i];
        p[s[i]]</span>+=<span style="color: #000000;">o[i];
    }
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>; i&lt;n; i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">if</span>(p[s[i]]&gt;<span style="color: #000000;">m)
            m</span>=<span style="color: #000000;">p[s[i]];
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>; i&lt;n; i++<span style="color: #000000;">)
    {
        </span><span style="color: #0000ff;">if</span>((t[s[i]]+=o[i])&gt;=m&amp;&amp;p[s[i]]&gt;=<span style="color: #000000;">m)
        {
            cout</span>&lt;&lt;s[i]&lt;&lt;<span style="color: #000000;">endl;
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<div class="header">
<div class="title" style="text-align: center;"><span style="font-size: 18px;"><a href="https://codeforces.com/contest/2/problem/B" target="_blank">B. The least round way</a></span></div>
<div class="title" style="text-align: center;">&nbsp;</div>
</div>
<div>
<p>There is a square matrix&nbsp;<span class="tex-span"><em>n</em>&thinsp;&times;&thinsp;<em>n</em>, consisting of non-negative integer numbers. You should find such a way on it that</span></p>
<ul>
<li>starts in the upper left cell of the matrix;</li>
<li>each following cell is to the right or down from the current cell;</li>
<li>the way ends in the bottom right cell.</li>
</ul>
<p>Moreover, if we multiply together all the numbers along the way, the result should be the least "round". In other words, it should end in the least possible number of zeros.</p>
</div>
<div class="input-specification">
<div class="section-title">Input</div>
<p>The first line contains an integer number&nbsp;<span class="tex-span"><em>n</em>&nbsp;(<span class="tex-span">2&thinsp;&le;&thinsp;<em>n</em>&thinsp;&le;&thinsp;1000),&nbsp;<span class="tex-span"><em>n</em>&nbsp;is the size of the matrix. Then follow&nbsp;<span class="tex-span"><em>n</em>&nbsp;lines containing the matrix elements (non-negative integer numbers not exceeding&nbsp;<span class="tex-span">10<span class="upper-index">9).</span></span></span></span></span></span></p>
</div>
<div class="output-specification">
<div class="section-title">Output</div>
<p>In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.</p>
<div>
<div id="pageContent" class="content-with-sidebar">
<div class="problemindexholder">
<div class="ttypography">
<div class="problem-statement">
<div class="sample-tests">
<div class="section-title">Examples</div>
<div class="sample-test">
<div class="input">
<div class="title">input</div>
<pre>3<br />1 2 3<br />4 5 6<br />7 8 9</pre>
</div>
<div class="output">
<div class="title">output</div>
<pre>0<br />DDRR</pre>
<p>&nbsp;题意：这个题就是给你一个n*n的矩阵，然后让你从左上角走到右下角，问走过的路线每个数都乘起来，然后找出结果中末尾0的个数最少的以及这条路线是如何走的，只能向右或向下。</p>
<p>代码如下：</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cnblogs_code">
<pre>#include &lt;bits/stdc++.h&gt;
<span style="color: #0000ff;">#define</span> inf 0x3f3f3f3f
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">int</span> f[<span style="color: #800080;">1001</span>][<span style="color: #800080;">1001</span>][<span style="color: #800080;">2</span><span style="color: #000000;">],n,x,k;
</span><span style="color: #0000ff;">char</span> g[<span style="color: #800080;">1001</span>][<span style="color: #800080;">1001</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">void</span> gao(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y)
{
    </span><span style="color: #0000ff;">if</span>(x==<span style="color: #800080;">1</span>&amp;&amp;y==<span style="color: #800080;">1</span>)<span style="color: #008000;">//</span><span style="color: #008000;">如果是起点，返回</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(g[x][y][k])<span style="color: #008000;">//</span><span style="color: #008000;">判断g的，1记录的向下,0记录的向右</span>
        gao(x-<span style="color: #800080;">1</span>,y),putchar(<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        gao(x,y</span>-<span style="color: #800080;">1</span>),putchar(<span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">);
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    memset(f,</span><span style="color: #800080;">0</span>,<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(f));
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>; i&lt;=n; ++<span style="color: #000000;">i)
        f[</span><span style="color: #800080;">0</span>][i][<span style="color: #800080;">0</span>]=f[<span style="color: #800080;">0</span>][i][<span style="color: #800080;">1</span>]=f[i][<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>]=f[i][<span style="color: #800080;">0</span>][<span style="color: #800080;">1</span>]=inf;<span style="color: #008000;">//</span><span style="color: #008000;">让第一行的上一行和第一列的前一列</span>
    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>; i&lt;=n; ++<span style="color: #000000;">i)
    {
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>; j&lt;=n; ++<span style="color: #000000;">j)
        {
            scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">k);
            </span><span style="color: #0000ff;">if</span>(!k)<span style="color: #008000;">//</span><span style="color: #008000;">当前值为零</span>
                x=i;<span style="color: #008000;">//</span><span style="color: #008000;">标记一下，记录第几行存在0</span>
            <span style="color: #0000ff;">else</span><span style="color: #000000;">
            {
                </span><span style="color: #0000ff;">while</span>(k%<span style="color: #800080;">2</span>==<span style="color: #800080;">0</span><span style="color: #000000;">)
                    </span>++f[i][j][<span style="color: #800080;">0</span>],k/=<span style="color: #800080;">2</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果当前位置的值为2的倍数，则记录进0中，存进数值除以2的值</span>
                <span style="color: #0000ff;">while</span>(k%<span style="color: #800080;">5</span>==<span style="color: #800080;">0</span><span style="color: #000000;">)
                    </span>++f[i][j][<span style="color: #800080;">1</span>],k/=<span style="color: #800080;">5</span>;<span style="color: #008000;">//</span><span style="color: #008000;">如果当前数值是5的倍数，测记录进1中，存进数值除以5的值</span>
<span style="color: #000000;">            }
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>; k&lt;<span style="color: #800080;">2</span>; k++)<span style="color: #008000;">//</span><span style="color: #008000;">统计行进过程中2的倍数和5的倍数</span>
<span style="color: #000000;">            {
                </span><span style="color: #0000ff;">if</span>(g[i][j][k]=f[i-<span style="color: #800080;">1</span>][j][k]&lt;f[i][j-<span style="color: #800080;">1</span>][k])<span style="color: #008000;">//</span><span style="color: #008000;">判断此行的上一行的2的倍数个数小于此列的上一列的2的倍数的个数,也就是当前位置的上一个位置，左边和上边，那个方向的2更少，g为一的时候，则是向下走</span>
                    f[i][j][k]+=f[i-<span style="color: #800080;">1</span>][j][k];<span style="color: #008000;">//</span><span style="color: #008000;">则进行此位置加上上一行的2或5的倍数的个数，就把那个方向的数加上</span>
                <span style="color: #0000ff;">else</span><span style="color: #008000;">//</span><span style="color: #008000;">否则则是另一个方向，向右走的</span>
                    f[i][j][k]+=f[i][j-<span style="color: #800080;">1</span>][k];<span style="color: #008000;">//</span><span style="color: #008000;">否则就是此位置加上上一列2或5的倍数的个数</span>
<span style="color: #000000;">            }
        }
    }
    k</span>=f[n][n][<span style="color: #800080;">1</span>]&lt;f[n][n][<span style="color: #800080;">0</span>];<span style="color: #008000;">//</span><span style="color: #008000;">最后一个位置的2和5个数那个比较多</span>
    <span style="color: #0000ff;">if</span>(x&amp;&amp;f[n][n][k]&gt;<span style="color: #800080;">1</span>)<span style="color: #008000;">//</span><span style="color: #008000;">说明前面至少有一对2和5，也就是至少有一个零，同时如果过程中有为零的，也就是x被标记过，那就是只存在一个零，相当于就一个10。</span>
<span style="color: #000000;">    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">1\n</span><span style="color: #800000;">"</span>;<span style="color: #008000;">//</span><span style="color: #008000;">接下来就是输出过程中以x这个点为十字路口，前面一个方向，后面一个方向</span>
        <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>; i&lt;=x; i++<span style="color: #000000;">)
            putchar(</span><span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>; i&lt;=n; i++<span style="color: #000000;">)
            putchar(</span><span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=x+<span style="color: #800080;">1</span>; i&lt;=n; i++<span style="color: #000000;">)
            putchar(</span><span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d\n</span><span style="color: #800000;">"</span>,f[n][n][k]),gao(n,n);<span style="color: #008000;">//</span><span style="color: #008000;">先输出最少的对数，因为一个是记数2的，一个是记数5的</span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div>
</div>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>