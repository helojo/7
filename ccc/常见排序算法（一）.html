<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修常见排序算法（一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>常见排序算法（一）</center></div><div class='banquan'>原文出处:本文由博客园博主贵志提供。<br/>
原文连接:https://www.cnblogs.com/lemonyam/p/10801483.html</div><br>
    <p><strong><span style="font-size: 14pt;">排序：</span></strong></p>
<p><span style="font-size: 15px;">　　1、排序在计算机数据处理中经常遇到，在日常的数据处理中，一般可以认为有 1/4 的时间用在排序上，而对于程序安装，</span></p>
<p><span style="font-size: 15px;">　　　&nbsp; 多达 50% 的时间花费在对表的排序上。简而言之，排序是将一组<strong>杂乱无章</strong>的数据按一定的规律<strong>顺次排列</strong>起来</span></p>
<p><span style="font-size: 15px;">　　2、内排与外排：根据排序方法在排序过程中数据元素<strong>是否完全在内存</strong>而划分，若一部分数据在外存，则为外排，否则，为内排</span></p>
<p><span style="font-size: 15px;">　　3、排序算法的<strong>稳定性</strong>：根据排序后相同元素<strong>顺序是否会发生改变</strong>而定，</span></p>
<p><span style="font-size: 15px;">　　　&nbsp; 如两个数 a 与 b，a == b 且 a 在 b 的前面，若排序后 a 仍然在 b 的前面，则为稳定的，否则，为不稳定的</span></p>
<p><span style="font-size: 15px;">　　4、排序算法的性能评估：算法的<strong>执行时间</strong>是衡量算法好坏的最重要参数，其时间开销可用算法执行中的数据<strong>比较次数</strong>与<strong>移动次数</strong>来衡量</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">排序算法：</span></strong></p>
<p><strong><span style="font-size: 14pt;">　　</span><span style="font-size: 16px;">1、时间复杂度：</span></strong></p>
<p><span style="font-size: 15px;">　　　　a、平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序</span></p>
<p><span style="font-size: 15px;">　　　　b、线性对数阶 (O(nlog2n)) 排序：快速排序、堆排序和归并排序</span></p>
<p><span style="font-size: 15px;">　　　　c、</span><span style="font-size: 15px;">O(n1+&sect;)) 排序，&sect; 是介于 0 和 1 之间的常数：希尔排序</span></p>
<p><span style="font-size: 15px;">　　　　d、线性阶 (O(n)) 排序：基数排序，桶排序和计数排序</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 15px;">　　<strong><span style="font-size: 16px;">2、稳定性：</span></strong></span></p>
<p><span style="font-size: 15px;">　　　　a、稳定的排序算法：冒泡排序、插入排序、归并排序、计数排序、桶排序和基数排序</span></p>
<p><span style="font-size: 15px;">　　　　b、不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</span></p>
<p><span style="color: #ff0000;"><em><span style="font-size: 15px;">注：稳定性是相对的，例如我们把比较冒泡排序里对两个元素比较的算法改成大于等于，它会变成不稳定的！</span></em></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 15px;">　　<strong><span style="font-size: 16px;">3、比较与非比较：</span></strong></span></p>
<p><span style="font-size: 15px;">　　　　a、比较排序：冒泡排序、插入排序、希尔排序、选择排序、快速排序、归并排序和堆排序</span></p>
<p><span style="font-size: 15px;">　　　　b、非比较排序：计数排序、桶排序和基数排序</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）0.png" alt="" width="1390" height="940" /></span></strong></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 14pt;">十大经典排序算法：</span></strong></p>
<p><span style="color: #ff0000;"><em><span style="font-size: 15px;"><strong>以下均按非降序排序</strong></span></em></span></p>
<p><span style="font-size: 15px;">　　<span style="font-size: 16px;">1、<strong>冒泡排序</strong>(bubbleSort)：</span></span></p>
<p><span style="font-size: 15px;">　　　　a、比较相邻两个元素，若前者的大于后者，则交换这两个元素</span></p>
<p><span style="font-size: 15px;">　　　　b、向后移动一项，再执行比较交换操作；当移动到最后一位时，这个元素即为本轮最大值</span></p>
<p><span style="font-size: 15px;">　　　　c、从新从头开始，除了最后一项，执行 a、b 操作，直到排序完成</span></p>
<p><span style="color: #ff0000;"><em><span style="font-size: 15px;">注：在排序过程中，我们可以设置一个标志判断在一轮排序中是否有交换元素，若一轮排序过后仍无交换，则说明排序已完成</span></em></span></p>
<p><span style="font-size: 15px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）1.png" alt="" /></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('1658581b-01c3-4310-8776-5500a6356757')"><img id="code_img_closed_1658581b-01c3-4310-8776-5500a6356757" class="code_img_closed" src="./images/常见排序算法（一）2.png" alt="" /><img id="code_img_opened_1658581b-01c3-4310-8776-5500a6356757" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('1658581b-01c3-4310-8776-5500a6356757',event)" src="./images/常见排序算法（一）3.png" alt="" />
<div id="cnblogs_code_open_1658581b-01c3-4310-8776-5500a6356757" class="cnblogs_code_hide">
<pre>#include &lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;<span style="color: #000000;">
#include </span>&lt;cstdlib&gt;

<span style="color: #008000;">//</span><span style="color: #008000;">采用引用的方式传参，否则传入的只是一个不会改变原数据的形参 </span>
<span style="color: #0000ff;">void</span> bubbleSort(std::vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums);

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    std::vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nums;
    </span><span style="color: #0000ff;">int</span> len = <span style="color: #800080;">0</span><span style="color: #000000;">;
    std::cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">请输入长度：</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
        std::cin</span>&gt;&gt;<span style="color: #000000;">len;
        </span><span style="color: #0000ff;">if</span> (len &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">)
</span><span style="color: #008000;">//</span><span style="color: #008000;">            标准错误流，输出错误信息 </span>
            std::cerr&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">请输入正整数：</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    } </span><span style="color: #0000ff;">while</span> (len &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
    std::cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">输入 </span><span style="color: #800000;">"</span>&lt;&lt;len&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;"> 个数: </span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">    size_t 是 unsigned_int 类型，建议在使用下标时使用，但若将负数赋值给它，则会将该数转换为正数，从而产生错误 </span>
    <span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
        std::cin</span>&gt;&gt;<span style="color: #000000;">num;
        nums.push_back(num);
    }
    
    bubbleSort(nums);
    std::cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">排序后的数组：</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">    自由 for 循环 </span>
    <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums)
</span><span style="color: #008000;">//</span><span style="color: #008000;">        std::ends 输出空白符，不同电脑的空白符可能不一样 </span>
        std::cout&lt;&lt;num&lt;&lt;<span style="color: #000000;">std::ends;
    std::cout</span>&lt;&lt;<span style="color: #000000;">std::endl;
    
    system(</span><span style="color: #800000;">"</span><span style="color: #800000;">pause</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

</span><span style="color: #0000ff;">void</span> bubbleSort(std::vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums)
{
</span><span style="color: #008000;">//</span><span style="color: #008000;">    设置交换标志，若一次循环后所有元素都未发生交换，则说明数组已经排列好，可提前退出 </span>
    <span style="color: #0000ff;">bool</span> exchange = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    size_t len </span>=<span style="color: #000000;"> nums.size();
    </span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">1</span>; i &lt; len; ++<span style="color: #000000;">i) {
        exchange </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        为了方便，我把最小的元素移动到了最前 </span>
        <span style="color: #0000ff;">for</span> (size_t j = len-<span style="color: #800080;">1</span>; j &gt;= i; j--<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (nums[j-<span style="color: #800080;">1</span>] &gt;<span style="color: #000000;"> nums[j]) {
                </span><span style="color: #0000ff;">int</span> temp = nums[j-<span style="color: #800080;">1</span><span style="color: #000000;">];
                nums[j</span>-<span style="color: #800080;">1</span>] =<span style="color: #000000;"> nums[j];
                nums[j] </span>=<span style="color: #000000;"> temp;
                exchange </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">exchange)
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>&nbsp;　<span style="font-size: 15px;">　<span style="font-size: 16px;">2、<strong>选择排序</strong>(selectionSort)：</span></span></p>
<p><span style="font-size: 15px;">　　　　a、在初始序列 <strong>R[i...n-1]</strong> 中找到最小的元素，放到 <strong>R[i]</strong> 处，i=0，n=待排对象大小</span></p>
<p><span style="font-size: 15px;">　　　　b、<strong>++i</strong></span></p>
<p><span style="font-size: 15px;"><strong>　　　　</strong>c、重复执行 a、b 操作，直至第 <strong>n-1 轮</strong></span></p>
<p><span style="font-size: 15px;"><strong><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）4.png" alt="" /></strong></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('59aad491-cb9f-4298-adf7-bcf3ab0a1e4c')"><img id="code_img_closed_59aad491-cb9f-4298-adf7-bcf3ab0a1e4c" class="code_img_closed" src="./images/常见排序算法（一）2.png" alt="" /><img id="code_img_opened_59aad491-cb9f-4298-adf7-bcf3ab0a1e4c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('59aad491-cb9f-4298-adf7-bcf3ab0a1e4c',event)" src="./images/常见排序算法（一）3.png" alt="" />
<div id="cnblogs_code_open_59aad491-cb9f-4298-adf7-bcf3ab0a1e4c" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">void</span> selectionSort(std::vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums)
{
    size_t len </span>=<span style="color: #000000;"> nums.size();
</span><span style="color: #008000;">//</span><span style="color: #008000;">    在每次循环里选出最小的一个排在前面 </span>
    <span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; len-<span style="color: #800080;">1</span>; ++<span style="color: #000000;">i){
        </span><span style="color: #0000ff;">int</span> min =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (size_t j = i+<span style="color: #800080;">1</span>; j &lt; len; ++<span style="color: #000000;">j){
            </span><span style="color: #0000ff;">if</span> (nums[j] &lt;<span style="color: #000000;"> nums[min])
                min </span>=<span style="color: #000000;"> j;
        }
        </span><span style="color: #0000ff;">if</span> (i !=<span style="color: #000000;"> min){
            </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> nums[i];
            nums[i] </span>=<span style="color: #000000;"> nums[min];
            nums[min] </span>=<span style="color: #000000;"> temp;
        } 
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 16px;"><strong>3、简单插入排序</strong>(insertionSort)<strong>：</strong></span></p>
<p><span style="font-size: 15px;"><strong>　　　　</strong></span><span style="font-size: 15px;">a、</span><span style="font-size: 15px;">从第一个元素开始，该元素可以认为<strong>已经被排序</strong></span></p>
<p><span style="font-size: 15px;">　　　　b、</span><span style="font-size: 15px;">取出<strong>下一</strong>个元素，在已经排序的元素序列中<strong>从后向前</strong>扫描</span></p>
<p><span style="font-size: 15px;">　　　　c、</span><span style="font-size: 15px;">如果该元素大于新元素，将该元素移到<strong>下一</strong>位置</span></p>
<p><span style="font-size: 15px;">　　　　d、</span><span style="font-size: 15px;">重复操作 c，直到找到已排序的元素<strong>小于或等于</strong>新元素的位置</span></p>
<p><span style="font-size: 15px;">　　　　e、</span><span style="font-size: 15px;">将新元素<strong>插入</strong>到该位置后</span></p>
<p><span style="font-size: 15px;">　　　　f、</span><span style="font-size: 15px;">重复操作 b-e</span></p>
<p><span style="font-size: 15px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）7.png" alt="" /></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('af35b51b-ab37-4c85-bb43-8847737a1f69')"><img id="code_img_closed_af35b51b-ab37-4c85-bb43-8847737a1f69" class="code_img_closed" src="./images/常见排序算法（一）2.png" alt="" /><img id="code_img_opened_af35b51b-ab37-4c85-bb43-8847737a1f69" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('af35b51b-ab37-4c85-bb43-8847737a1f69',event)" src="./images/常见排序算法（一）3.png" alt="" />
<div id="cnblogs_code_open_af35b51b-ab37-4c85-bb43-8847737a1f69" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">void</span> insertionSort(std::vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums)
{
    size_t len </span>=<span style="color: #000000;"> nums.size();
    
    </span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">1</span>; i &lt; len; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> nums[i];
        
</span><span style="color: #008000;">//</span><span style="color: #008000;">        在循环中把较大的数往后移一位 </span>
        size_t j =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">while</span> (j &gt; <span style="color: #800080;">0</span> &amp;&amp; temp &lt; nums[j-<span style="color: #800080;">1</span><span style="color: #000000;">]) {
            nums[j] </span>= nums[j-<span style="color: #800080;">1</span><span style="color: #000000;">];
            j</span>--<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (j !=<span style="color: #000000;"> i)
            nums[j] </span>=<span style="color: #000000;"> temp;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 16px;">4、<strong>希尔排序</strong>(shellSort)：</span></p>
<p><span style="font-size: 15px;">　　　　a、设对象有 n 个元素，先取整数 <strong>gap &lt; n</strong> 作为间隔，并将全部元素分为 gap 个子序列，所有距离为 gap 的元素放在同一子序列中，</span></p>
<p><span style="font-size: 15px;">　　　　　&nbsp; 在每个子序列中分别施行<strong>直接插入</strong>排序</span></p>
<p><span style="font-size: 15px;">　　　　b、缩小间隔 gap，如 <strong>gap = gap/3 + 1</strong></span></p>
<p><span style="font-size: 15px;">　　　　c、重复 a、b 操作，直到取 <strong>gap == 1</strong> 为</span></p>
<p><span style="color: #ff0000;"><em><span style="font-size: 15px;">注：gap 有多种取法，但如果 gap = n/2 或 gap = gap/2 时，只有到最后一步奇数位置才会和偶数位置的数进行比较</span></em></span></p>
<p><span style="font-size: 15px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）10.png" alt="" /></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('e4026d44-a929-41f5-bf30-5de03ae7a749')"><img id="code_img_closed_e4026d44-a929-41f5-bf30-5de03ae7a749" class="code_img_closed" src="./images/常见排序算法（一）2.png" alt="" /><img id="code_img_opened_e4026d44-a929-41f5-bf30-5de03ae7a749" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e4026d44-a929-41f5-bf30-5de03ae7a749',event)" src="./images/常见排序算法（一）3.png" alt="" />
<div id="cnblogs_code_open_e4026d44-a929-41f5-bf30-5de03ae7a749" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">void</span> shellSort(std::vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums)
{
    </span><span style="color: #0000ff;">int</span> gap = <span style="color: #800080;">1</span>, len =<span style="color: #000000;"> nums.size();
</span><span style="color: #008000;">//</span><span style="color: #008000;">    先让间隔 gap 尽量大 </span>
    <span style="color: #0000ff;">while</span> (gap &lt;<span style="color: #000000;"> len)
        gap </span>= gap*<span style="color: #800080;">3</span>+<span style="color: #800080;">1</span><span style="color: #000000;">;
        
    </span><span style="color: #0000ff;">while</span> (gap &gt; <span style="color: #800080;">0</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = gap; i &lt; len; i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">int</span> j = i -<span style="color: #000000;"> gap;
</span><span style="color: #008000;">//</span><span style="color: #008000;">                     直接插入排序</span>
            <span style="color: #0000ff;">while</span> (j &gt;= <span style="color: #800080;">0</span> &amp;&amp; nums[j] &gt;<span style="color: #000000;"> temp){
                nums[j</span>+gap] =<span style="color: #000000;"> nums[j];
                j </span>-=<span style="color: #000000;"> gap;
            }
            nums[j</span>+gap] =<span style="color: #000000;"> temp;
        }
        gap </span>/= <span style="color: #800080;">3</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
<p>　　<span style="font-size: 16px;">5、<strong>快速排序</strong>(quickSort)：</span></p>
<p><span style="font-size: 15px;">　　　　a、</span><span style="font-size: 15px;">从数列中挑出一个元素，称为 &ldquo;<strong>基准</strong>&rdquo;（一般为第一个元素）</span></p>
<p><span style="font-size: 15px;">　　　　b、</span><span style="font-size: 15px;">重新排序数列，所有元素<strong>比基准值小的摆放在基准前面</strong>，所有元素<strong>比基准值大的摆在基准的后面</strong>（相同的数可以到任一边）。</span></p>
<p><span style="font-size: 15px;">　　　　　&nbsp; 在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</span></p>
<p><span style="font-size: 15px;">　　　　c、</span><span style="font-size: 15px;"><strong>递归</strong>地把小于基准值元素的子数列和大于基准值元素的子数列排序</span></p>
<p><span style="color: #ff0000;"><em><span style="font-size: 15px;">注：快排的非递归算法可以使用栈来实现</span></em></span></p>
<p>&nbsp;</p>
<p><span style="font-size: 15px;"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/常见排序算法（一）13.png" alt="" /></span></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('be5e4285-f669-48fa-9bfa-c7f6c4ac8c43')"><img id="code_img_closed_be5e4285-f669-48fa-9bfa-c7f6c4ac8c43" class="code_img_closed" src="./images/常见排序算法（一）2.png" alt="" /><img id="code_img_opened_be5e4285-f669-48fa-9bfa-c7f6c4ac8c43" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('be5e4285-f669-48fa-9bfa-c7f6c4ac8c43',event)" src="./images/常见排序算法（一）3.png" alt="" />
<div id="cnblogs_code_open_be5e4285-f669-48fa-9bfa-c7f6c4ac8c43" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">void</span> QuickSort(<span style="color: #0000ff;">int</span>* arr, <span style="color: #0000ff;">int</span> low, <span style="color: #0000ff;">int</span><span style="color: #000000;"> high)
{
    </span><span style="color: #0000ff;">int</span> star = low, end =<span style="color: #000000;"> high;
    </span><span style="color: #0000ff;">if</span> (star &gt;<span style="color: #000000;"> end)
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
    </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> arr[star];
    </span><span style="color: #0000ff;">while</span> (star !=<span style="color: #000000;"> end) {
</span><span style="color: #008000;">//</span><span style="color: #008000;">        从后找出小于&ldquo;基准&rdquo;的数 </span>
        <span style="color: #0000ff;">while</span> (arr[end] &gt;= temp &amp;&amp; star &lt;<span style="color: #000000;"> end)
            end</span>--<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        从前找出大于&ldquo;基准&rdquo;的数 </span>
        <span style="color: #0000ff;">while</span> (arr[star] &lt;= temp &amp;&amp; star &lt;<span style="color: #000000;"> end)
            star</span>++<span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">        若还在范围内，则交换这两者 </span>
        <span style="color: #0000ff;">if</span> (star &lt;<span style="color: #000000;"> end) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> arr[star];
            arr[star] </span>=<span style="color: #000000;"> arr[end];
            arr[end] </span>=<span style="color: #000000;"> t;
        }
    }
</span><span style="color: #008000;">//</span><span style="color: #008000;">    把&ldquo;基准&rdquo;移动到&ldquo;中间&rdquo; </span>
    <span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> arr[low];
    arr[low] </span>=<span style="color: #000000;"> arr[star];
    arr[star] </span>=<span style="color: #000000;"> t;
    
</span><span style="color: #008000;">//</span><span style="color: #008000;">    递归 </span>
    QuickSort(arr, low, star-<span style="color: #800080;">1</span><span style="color: #000000;">);
    QuickSort(arr, star</span>+<span style="color: #800080;">1</span><span style="color: #000000;">, high);
      
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>