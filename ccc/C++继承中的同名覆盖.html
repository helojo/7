<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++继承中的同名覆盖' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++继承中的同名覆盖</center></div><div class='banquan'>原文出处:本文由博客园博主子宇24提供。<br/>
原文连接:https://www.cnblogs.com/dishengAndziyu/p/10915115.html</div><br>
    <p align="left">1，父子间的冲突是由继承带来的，两个类之间存在了继承的关系，必然的会带来一 些问题，本文要讨论的是父子之间成员变量或成员函数的命名问题；</p>
<p align="left">&nbsp;</p>
<p align="left">2，思考：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，子类中是否可以定义父类中的同名成员？</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，可以，本文先编程解决这个问题；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2，这个问题就是同名覆盖问题；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 2，如果可以，如何区分？如果不可以，为什么？</p>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">3，同名成员变量编程实验：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include &lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">10</span> <span style="color: #000000;">};
</span><span style="color: #008080;">11</span> 
<span style="color: #008080;">12</span> <span style="color: #0000ff;">class</span> Child : <span style="color: #0000ff;">public</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">13</span> <span style="color: #000000;">{
</span><span style="color: #008080;">14</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">15</span>     <span style="color: #0000ff;">int</span> mi;  <span style="color: #008000;">//</span><span style="color: #008000;"> 编译结果通过，子类可以定义父类里面的同名变量；</span>
<span style="color: #008080;">16</span> <span style="color: #000000;">};
</span><span style="color: #008080;">17</span> 
<span style="color: #008080;">18</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">19</span> <span style="color: #000000;">{
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    Child c;
</span><span style="color: #008080;">21</span>     
<span style="color: #008080;">22</span>     c.mi = <span style="color: #800080;">100</span>;    <span style="color: #008000;">//</span><span style="color: #008000;"> mi 究竟是子类自定义的，还是从父类继承得到的？</span>
<span style="color: #008080;">23</span>     
<span style="color: #008080;">24</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">25</span> }</pre>
</div>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">4，父子间的冲突（同名覆盖）：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，子类可以定义父类中的同名成员；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 2，子类中的成员将隐藏父类中的同名成员；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，编译器认为已经从父类中继承得到这个成员了，又自定义了一个同名成员，目的只有一个，就是你想要自己自定义的同名成员、而不想要从父类那里继承得到的同名成员，因此会产生同名覆盖现象；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 3，父类中的同名成员依然存在于子类中；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，隐藏、不是销毁；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 4，通过作用域分辨符（::）访问父类中的同名成员；</p>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">5，访问父类中的同名成员方式：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，Child c；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 2，c.mi = 100;&nbsp; // 子类中的 mi；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 3，c.Parent::mi = 1000；&nbsp; // 父类中的 mi；</p>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">6，同名成员变量深度分析编程实验：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include &lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> A
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span>     <span style="color: #0000ff;">int</span> g_i = <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">}
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> B
</span><span style="color: #008080;">12</span> <span style="color: #000000;">{
</span><span style="color: #008080;">13</span>     <span style="color: #0000ff;">int</span> g_i = <span style="color: #800080;">1</span>;  <span style="color: #008000;">//</span><span style="color: #008000;"> 同名的全局变量，但是位于两个不同的命名空间；</span>
<span style="color: #008080;">14</span> <span style="color: #000000;">}
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">17</span> <span style="color: #000000;">{
</span><span style="color: #008080;">18</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">19</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">20</span>     
<span style="color: #008080;">21</span> <span style="color: #000000;">    Parent()
</span><span style="color: #008080;">22</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">23</span>         cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Parent() : </span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">&amp;mi = </span><span style="color: #800000;">"</span> &lt;&lt; &amp;mi &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">24</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">25</span> <span style="color: #000000;">};
</span><span style="color: #008080;">26</span> 
<span style="color: #008080;">27</span> <span style="color: #0000ff;">class</span> Child : <span style="color: #0000ff;">public</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">28</span> <span style="color: #000000;">{
</span><span style="color: #008080;">29</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">30</span>     <span style="color: #0000ff;">int</span> mi;  <span style="color: #008000;">//</span><span style="color: #008000;"> 编译器没有简单的对同名成员报错，是因为作用域，虽然两个成员的名字相同，但是出于不同的作用域当中；同命名空间的本质是一样的；</span>
<span style="color: #008080;">31</span>     
<span style="color: #008080;">32</span> <span style="color: #000000;">    Child()
</span><span style="color: #008080;">33</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">34</span>         cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Child() : </span><span style="color: #800000;">"</span> &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">&amp;mi = </span><span style="color: #800000;">"</span> &lt;&lt; &amp;mi &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008080;">35</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">36</span> <span style="color: #000000;">};
</span><span style="color: #008080;">37</span> 
<span style="color: #008080;">38</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">39</span> <span style="color: #000000;">{
</span><span style="color: #008080;">40</span>     Child c;  <span style="color: #008000;">//</span><span style="color: #008000;"> Parent() : &amp;mi = 0xbfb43a08    Child() : &amp;mi = 0xbfb43a0c</span>
<span style="color: #008080;">41</span>     
<span style="color: #008080;">42</span>     c.mi = <span style="color: #800080;">100</span><span style="color: #000000;">;    
</span><span style="color: #008080;">43</span>     
<span style="color: #008080;">44</span>     c.Parent::mi = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #008080;">45</span>     
<span style="color: #008080;">46</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">&amp;c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; &amp;c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> &amp;c.mi = 0xbfb43a0c，证明</span><span style="color: #008000;">直接访问的是子类的 mi；  </span>
<span style="color: #008080;">47</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 100；</span>
<span style="color: #008080;">48</span>     
<span style="color: #008080;">49</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">&amp;c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; &amp;c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> &amp;c.Parent::mi = 0xbfb43a08；  作用域分辨符访问父类 mi；</span>
<span style="color: #008080;">50</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1000；</span>
<span style="color: #008080;">51</span>     
<span style="color: #008080;">52</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">53</span> }</pre>
</div>
<p align="left">&nbsp;&nbsp;&nbsp; 1，父类和子类可以产生同名覆盖冲突，但是通过作用域分辨符可以解决这个问&nbsp;&nbsp;&nbsp;&nbsp; 题；</p>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">7，再论重载：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，类中的成员函数可以进行重载：</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，重载函数的本质为多个不同的函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2，函数名和参数列表是唯一的标识；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3，函数重载必须发生在同一个作用域中；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p align="left">8，问题：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，子类中定义的函数是否能重载父类中的同名函数？</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，将父子间的冲突问题上升到成员函数了；</p>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">9，父子间的函数重载编程实验：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，继承父类成员函数，累加父类的同名成员；</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include &lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">10</span>     
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v)
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">13</span>         mi +=<span style="color: #000000;"> v;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span>     
<span style="color: #008080;">16</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">18</span>         mi += (a +<span style="color: #000000;"> b);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> <span style="color: #000000;">};
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> <span style="color: #0000ff;">class</span> Child : <span style="color: #0000ff;">public</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">25</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">26</span> <span style="color: #000000;">};
</span><span style="color: #008080;">27</span> 
<span style="color: #008080;">28</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">29</span> <span style="color: #000000;">{
</span><span style="color: #008080;">30</span> <span style="color: #000000;">    Child c;
</span><span style="color: #008080;">31</span>     
<span style="color: #008080;">32</span>     c.mi = <span style="color: #800080;">100</span><span style="color: #000000;">;    
</span><span style="color: #008080;">33</span>     
<span style="color: #008080;">34</span>     c.Parent::mi = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #008080;">35</span>     
<span style="color: #008080;">36</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 100；</span>
<span style="color: #008080;">37</span>     
<span style="color: #008080;">38</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1000；</span>
<span style="color: #008080;">39</span>     
<span style="color: #008080;">40</span>     c.add(<span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 继承自父类的成员函数；这个函数得到的 mi 不知道后面还要定义一个子类，它知道的 mi 只是父类中的，这个时候 mi 的作用域在父类中，所以给了父类中的 mi 做累加；</span>
<span style="color: #008080;">41</span>     c.add(<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 继承自父类的成员函数；</span>
<span style="color: #008080;">42</span>     
<span style="color: #008080;">43</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 100；</span>
<span style="color: #008080;">44</span>     
<span style="color: #008080;">45</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1006；累加到父类中的 mi 了；</span>
<span style="color: #008080;">46</span>     
<span style="color: #008080;">47</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">48</span> }</pre>
</div>
<p align="left">&nbsp;&nbsp;&nbsp; 2，函数的同名覆盖：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include &lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">10</span>     
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v)
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">13</span>         mi +=<span style="color: #000000;"> v;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span>     
<span style="color: #008080;">16</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">18</span>         mi += (a +<span style="color: #000000;"> b);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> <span style="color: #000000;">};
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> <span style="color: #0000ff;">class</span> Child : <span style="color: #0000ff;">public</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">25</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">26</span>     
<span style="color: #008080;">27</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span><span style="color: #000000;"> z)
</span><span style="color: #008080;">28</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">29</span>         mi += (x + y +<span style="color: #000000;"> z);
</span><span style="color: #008080;">30</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">31</span> <span style="color: #000000;">};
</span><span style="color: #008080;">32</span> 
<span style="color: #008080;">33</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">34</span> <span style="color: #000000;">{
</span><span style="color: #008080;">35</span> <span style="color: #000000;">    Child c;
</span><span style="color: #008080;">36</span>     
<span style="color: #008080;">37</span>     c.mi = <span style="color: #800080;">100</span><span style="color: #000000;">;    
</span><span style="color: #008080;">38</span>     
<span style="color: #008080;">39</span>     c.Parent::mi = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #008080;">40</span>     
<span style="color: #008080;">41</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 100；</span>
<span style="color: #008080;">42</span>     
<span style="color: #008080;">43</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1000；
</span><span style="color: #008080;">44</span>     
<span style="color: #008080;">45</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> c.add(1);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 编译器显示没有匹配的函数调用 Child::add(int)；同名成员函数覆盖，并没有重载，作用域不同；
</span><span style="color: #008080;">46</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> c.add(2, 3);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 编译器显示没有匹配的函数调用 Child::add(int, int)；同名成员函数覆盖，并没有重载，作用域不同；</span>
<span style="color: #008080;">47</span>     
<span style="color: #008080;">48</span>     c.Parent::add(<span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 作用域分辨符解决同名成员函数覆盖问题；</span>
<span style="color: #008080;">49</span>     c.Parent::add(<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 作用域分辨符解决同名成员函数覆盖问题；累加父类中的 mi</span>
<span style="color: #008080;">50</span>     
<span style="color: #008080;">51</span>     c.add(<span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 调用子类中的 add()，默认情况下访问的就是子类中的 mi，这个地方发生了同名覆盖；</span>
<span style="color: #008080;">52</span>     
<span style="color: #008080;">53</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 115；默认访问的 mi 是子类中的 mi；</span>
<span style="color: #008080;">54</span>     
<span style="color: #008080;">55</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1006；前两次累加的是父类中的 mi；</span>
<span style="color: #008080;">56</span>     
<span style="color: #008080;">57</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">58</span> }</pre>
</div>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">10，父子间的冲突：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，子类中的函数将隐藏父类的同名函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 2，子类无法重载父类中的成员函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，因为它们处于不同的作用域；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 3，使用作用域分辨符访问父类中的同名函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，类名加上作用域分辨符；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 4，子类可以定义父类中完全相同的成员函数；</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> #include &lt;iostream&gt;
<span style="color: #008080;"> 2</span> #include &lt;<span style="color: #0000ff;">string</span>&gt;
<span style="color: #008080;"> 3</span> 
<span style="color: #008080;"> 4</span> <span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #008080;"> 5</span> 
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 8</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 9</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">10</span>     
<span style="color: #008080;">11</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> v)
</span><span style="color: #008080;">12</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">13</span>         mi +=<span style="color: #000000;"> v;
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span>     
<span style="color: #008080;">16</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b)
</span><span style="color: #008080;">17</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">18</span>         mi += (a +<span style="color: #000000;"> b);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> <span style="color: #000000;">};
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span> <span style="color: #0000ff;">class</span> Child : <span style="color: #0000ff;">public</span><span style="color: #000000;"> Parent
</span><span style="color: #008080;">23</span> <span style="color: #000000;">{
</span><span style="color: #008080;">24</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;">25</span>     <span style="color: #0000ff;">int</span><span style="color: #000000;"> mi;
</span><span style="color: #008080;">26</span>     
<span style="color: #008080;">27</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> v)  <span style="color: #008000;">//</span><span style="color: #008000;"> 同名覆盖；函数重写；</span>
<span style="color: #008080;">28</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">29</span>         mi +=<span style="color: #000000;"> v;
</span><span style="color: #008080;">30</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">31</span>     
<span style="color: #008080;">32</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span> b)  <span style="color: #008000;">//</span><span style="color: #008000;"> 同名覆盖；函数重写；</span>
<span style="color: #008080;">33</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">34</span>         mi += (a +<span style="color: #000000;"> b);
</span><span style="color: #008080;">35</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">36</span>     
<span style="color: #008080;">37</span>     <span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span> z)  <span style="color: #008000;">//</span><span style="color: #008000;"> 重载；</span>
<span style="color: #008080;">38</span> <span style="color: #000000;">    {
</span><span style="color: #008080;">39</span>         mi += (x + y +<span style="color: #000000;"> z);
</span><span style="color: #008080;">40</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">41</span> <span style="color: #000000;">};
</span><span style="color: #008080;">42</span> 
<span style="color: #008080;">43</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
</span><span style="color: #008080;">44</span> <span style="color: #000000;">{
</span><span style="color: #008080;">45</span> <span style="color: #000000;">    Child c;
</span><span style="color: #008080;">46</span>     
<span style="color: #008080;">47</span>     c.mi = <span style="color: #800080;">100</span><span style="color: #000000;">;    
</span><span style="color: #008080;">48</span>     
<span style="color: #008080;">49</span>     c.Parent::mi = <span style="color: #800080;">1000</span><span style="color: #000000;">;
</span><span style="color: #008080;">50</span>     
<span style="color: #008080;">51</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 100；</span>
<span style="color: #008080;">52</span>     
<span style="color: #008080;">53</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.Parent::mi = 1000；</span>
<span style="color: #008080;">54</span>     
<span style="color: #008080;">55</span>     c.add(<span style="color: #800080;">1</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 同名覆盖；</span>
<span style="color: #008080;">56</span>     c.add(<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 同名覆盖；</span>
<span style="color: #008080;">57</span>     c.add(<span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>);  <span style="color: #008000;">//</span><span style="color: #008000;"> 函数重载；</span>
<span style="color: #008080;">58</span>     
<span style="color: #008080;">59</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> c.mi = 121；函数同名覆盖和重载，都是默认访问的子类的 mi；</span>
<span style="color: #008080;">60</span>     
<span style="color: #008080;">61</span>     cout &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">c.Parent::mi = </span><span style="color: #800000;">"</span> &lt;&lt; c.Parent::mi &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> 父类中的函数被同名覆盖，未有访问父类中的 mi；</span>
<span style="color: #008080;">62</span>     
<span style="color: #008080;">63</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">64</span> }</pre>
</div>
<p align="left">&nbsp;&nbsp;&nbsp;</p>
<p align="left">11，小结：</p>
<p align="left">&nbsp;&nbsp;&nbsp; 1，子类可以定义父类中的同名成员；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 2，子类中的成员将隐藏父类中的同名成员；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，包括同名成员变量和同名成员函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2，重写的依据；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3，这就是同名覆盖；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 3，子类和父类中的函数不能构成重载关系；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，作用域不同；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 4，子类可以定义父类中完全相同的成员函数；</p>
<p align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，作用域不同；</p>
<p align="left">&nbsp;&nbsp;&nbsp; 5，使用作用域分辨符访问父类中的同名成员；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1，父类名加上作用域分辨符；</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>