<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修递归（一）：递归的基本思想' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>递归（一）：递归的基本思想</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11083792.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 递归是算法设计中的一种基本而重要的算法。递归方法通过函数调用自身将问题转化为本质相同但规模较小的子问题，是分治策略的具体体现。</p>
<p>&nbsp; &nbsp; &nbsp; 递归算法的定义：如果一个对象的描述中包含它本身，我们就称这个对象是递归的，这种用递归来描述的算法称为递归算法。</p>
<p>&nbsp; &nbsp; &nbsp; 先来看看大家熟知的一个的故事： 从前有座山，山上有座庙，庙里有个老和尚在给小和尚讲故事，老和尚讲：从前有座山，山上有座庙，庙里有个老和尚在给小和尚讲故事，老和尚讲：&hellip;&hellip; 上面的故事本身是递归的，用递归算法描述：</p>
<p style="margin-left: 30px;">void&nbsp; bonze-tell-story （）</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 60px;">if (讲话被打断)</p>
<p style="margin-left: 60px;">{&nbsp; 故事结束； return； }</p>
<p style="margin-left: 60px;">从前有座山，山上有座庙，庙里有个老和尚在给小和尚讲故事；</p>
<p style="margin-left: 60px;">bonze-tell-story（）；</p>
<p style="margin-left: 30px;">}</p>
<p>&nbsp; &nbsp; &nbsp; 从上面的递归事例不难看出，递归算法存在的两个必要条件：（1）必须有递归的终止条件，如老和尚的故事一定要在某个时候应该被打断，可以是小和尚听烦了叫老和尚停止，或老和尚本身就只想重复讲10遍等；（2）过程的描述中包含它本身。</p>
<p>&nbsp; &nbsp; &nbsp; 递归是一种非常有用的程序设计技术。当一个问题蕴含递归关系且结构比较复杂时，采用递归算法往往比较自然、简洁、容易理解。</p>
<p>&nbsp; &nbsp; &nbsp; 递归思想的基本思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。用递归思想写出的程序往往十分简洁易懂。 一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<p>&nbsp; &nbsp; &nbsp; 使用递归要注意以下几点：</p>
<p>&nbsp; &nbsp; &nbsp;（1）递归就是在过程或函数里调用自身；</p>
<p>&nbsp; &nbsp; &nbsp; （2）在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。</p>
<p><strong>【例1】用递归法计算p<sup>n</sup>。</strong><br />&nbsp; &nbsp; &nbsp; （1）编程思想。<br />&nbsp; &nbsp; &nbsp; &nbsp;1）描述递归关系。<br />&nbsp; &nbsp; &nbsp; 递归关系是这样的一种关系。设{U1，U2，U3，&hellip;，Un，&hellip;}是一个序列，如果从某一项k开始，Un和它之前的若干项之间存在一种只与n有关的关系，这便称为递归关系。<br />&nbsp; &nbsp; &nbsp; 当n&ge;1时，p<sup>n</sup>=p*p<sup>(n&minus;1)</sup>（n=0时，p<sup>0</sup>=1），这就是一种递归关系。对于特定的p<sup>k</sup>，它只与k与p<sup>(k&minus;1)</sup>有关。<br />&nbsp; &nbsp; &nbsp; 2）确定递归边界。<br />&nbsp; &nbsp; &nbsp; 在步骤1的递归关系中，对大于k的Un的求解将最终归结为对Uk的求解。这里的Uk称为递归边界（或递归出口）。在本例中，递归边界为k=0，即p<sup>0</sup>=1。对于任意给定的p<sup>n</sup>，程序将最终求解到p<sup>0</sup>。<br />&nbsp; &nbsp; &nbsp; 确定递归边界十分重要，如果没有确定递归边界，将导致程序无限递归而引起死循环。<br />&nbsp; &nbsp; &nbsp; 例如以下程序：<br />&nbsp; &nbsp; &nbsp; &nbsp;int  f(int x)<br />&nbsp; &nbsp; &nbsp; &nbsp;{  return(f(x&minus;1)); }<br />&nbsp; &nbsp; &nbsp; &nbsp;int main()<br />&nbsp; &nbsp; &nbsp; &nbsp;{   cout&lt;&lt;f(5)&lt;&lt;endl;  }<br />&nbsp; &nbsp; &nbsp; 它没有规定递归边界，运行时将无限循环，会导致错误。<br />&nbsp; &nbsp; &nbsp; 3）写出递归函数。<br />&nbsp; &nbsp; &nbsp; 将步骤1）和步骤2）中的递归关系与边界统一起来用数学语言来表示，即<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p<sup>n</sup>= p*p<sup>n&minus;1</sup>&nbsp; &nbsp; 当n&gt;=1时<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p<sup>n</sup>= 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 当n=0时<br />&nbsp; &nbsp; &nbsp; 再将这种关系翻译为代码，即一个函数：<br />&nbsp; &nbsp; &nbsp; &nbsp;int  f(int p , int n)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n==0)  return 1;    <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return  p*f(p,n-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序。<br />&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;iostream&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp;using namespace std;<br />&nbsp; &nbsp; &nbsp; &nbsp;int  f(int p , int n)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (n==0)  return 1;    <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return  p*f(p,n-1);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;int main()<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int p, n,k;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (cin &gt;&gt;p&gt;&gt;n  &amp;&amp; p!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k=f(p,n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;k&lt;&lt;endl;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><strong>【例2】分苹果</strong></p>
<p>&nbsp; &nbsp; &nbsp; 把 M 个同样的苹果分放在N 个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？例如，M=7，N=3，则有（7,0,0）、（6,1,0）、（5,2,0）、（5,1,1）、（4,3,0）（4,2,1）、（3,3,1）和（3,2,2）共8种分法。注意：（5，1，1）和（1，5，1）是同一种分法。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 所有不同的摆放方法可以分为两类：至少有一个盘子空着和所有盘子都不空。我们可以分别计算这两类摆放方法的数目，然后把它们加起来。</p>
<p>&nbsp; &nbsp; &nbsp; 对于至少空着一个盘子的情况，则N 个盘子摆放M 个苹果的摆放方法数目与N-1 个盘子摆放M 个苹果的摆放方法数目相同。对于所有盘子都不空的情况，则N 个盘子摆放M 个苹果的摆放方法数目等于N 个盘子摆放M-N 个苹果的摆放方法数目。我们可以据此来用递归的方法求解这个问题。</p>
<p>&nbsp; &nbsp; &nbsp; 设f(m, n) 为m 个苹果，n 个盘子的放法数目，则先对n 作讨论，如果n&gt;m，必定有n-m 个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响；即</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(n&gt;m) &nbsp;f(m,n) = f(m,m)。</p>
<p>&nbsp; &nbsp; &nbsp; 当n &lt;= m 时，不同的放法可以分成两类：即有至少一个盘子空着或者所有盘子都有苹果，前一种情况相当于f(m , n) = f(m , n-1); 后一种情况可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m , n) = f(m-n , n)。总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) 。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;整个递归过程描述如下：</p>
<p style="margin-left: 30px;">int &nbsp;f(int m , int n)</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; if&nbsp; (n ==１|| m == 0) &nbsp;return 1;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; if&nbsp; (n &gt; m) &nbsp;return f (m, m);</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; &nbsp; return &nbsp;f (m , n-1)+f (m-n , n);</p>
<p style="margin-left: 30px;">}</p>
<p>&nbsp; &nbsp; &nbsp; 递归终止条件说明：当n=１时，所有苹果都必须放在一个盘子里，所以返回１；当没有苹果可放时，定义为１种放法；递归的两条路，第一条n 会逐渐减少，总会到达终止条件 n==1；第二条m 会逐渐减少，因为n&gt;m 时，我们会return f(m , m) ，所以也会到达终止条件&nbsp; m==0。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序</p>
<p style="margin-left: 30px;">#include &lt;iostream&gt;</p>
<p style="margin-left: 30px;">using namespace std;</p>
<p style="margin-left: 30px;">int&nbsp; f(int m , int n)</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; if (n==1 || m==0)&nbsp; return 1;&nbsp;&nbsp;&nbsp;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; if&nbsp; (n &gt; m)&nbsp; return f (m, m);</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; return&nbsp; f(m,n-1)+f(m-n,n);</p>
<p style="margin-left: 30px;">}</p>
<p style="margin-left: 30px;">int main()</p>
<p style="margin-left: 30px;">{</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; int n, m,k;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; while (cin &gt;&gt;m&gt;&gt;n&nbsp; &amp;&amp; n!=0)</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k=f(m,n);</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;k&lt;&lt;endl;</p>
<p style="margin-left: 30px;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin-left: 30px;">&nbsp; &nbsp; return 0;</p>
<p style="margin-left: 30px;">}</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>