<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++负数类型转换,-1对256取模' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++负数类型转换,-1对256取模</center></div><div class='banquan'>原文出处:本文由博客园博主HaoPeng_Zhang提供。<br/>
原文连接:https://www.cnblogs.com/HaoPengZhang/p/11542406.html</div><br>
    <p>最近在读C++ primer的时候，发现p32上写道：当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。因此，把-1赋值给8比特大小的unsigned char所得的结果是255。</p>
<h1 id="怎么取模">-1怎么取模？</h1>
<p>  这里先明确一下取模和取余的区别：（百度百科）<br />
  取模运算（“Module Operation”）和取余运算（“Complementation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中。取余则更多是数学概念。模运算在数论和程序设计中都有着广泛的应用。<br />
  对于整型数a，b来说，取模运算或者求余运算的方法都是：<br />
1.求 整数商： c = a/b;<br />
2.计算模或者余数： r = a - c<em>b.<br />
  求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模运算在计算c的值时，向负无穷方向舍入(floor()函数)。<br />
例如计算：-7 Mod 4<br />
那么：a = -7；b = 4；<br />
  第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）；<br />
  第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。<br />
  归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。<br />
  当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。<br />
  那么-1对256取模的过程就是：<br />
  c=-1/256=-1；<br />
  r =-1 -(-1 </em>256) =255(如果是取余，r=-1)</p>
<h1 id="从计算机存储的角度">从计算机存储的角度</h1>
<p>  在计算机中数值按补码存储的，-1的原码是10000001(有符号8位)，补码：11111111。所以直接赋值给unsigned char, 11111111等于255。其实相当于类型转换的时候什么都没干，直接意义就转换成了255，但是从数学的角度上就是对256取模。</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>