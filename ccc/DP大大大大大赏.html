<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修DP大大大大大赏' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>DP大大大大大赏</center></div><div class='banquan'>原文出处:本文由博客园博主Sweetness提供。<br/>
原文连接:https://www.cnblogs.com/zhuier-xquan/p/11203643.html</div><br>
    <p>还是前置：</p>
<p>动态规划的三种实现方法：</p>
<p>递推，递归，记忆化搜索</p>
<p>然后还是从斐波那契数列开始引入：</p>
<p>两种求斐波那契数列的方法：</p>
<p><img src="./images/DP大大大大大赏0.png" alt="" /></p>
<p>1.用其他位置的结果得到自己的结果：</p>
<p><img src="./images/DP大大大大大赏1.png" alt="" /></p>
<p>&nbsp;2.用自己的结果算其他的结果；</p>
<p><img src="./images/DP大大大大大赏2.png" alt="" width="217" height="104" /></p>
<p>&nbsp;以上两种方法都需要掌握，不同的题对应不同的写法；</p>
<p>3.记忆化搜索（虽然zhx说不是特别重要但lz比较喜欢写的）</p>
<p>没有记忆化之前：O（f[n]）与2^n差不多是一个级别的；</p>
<p><img src="./images/DP大大大大大赏3.png" alt="" /></p>
<p>记忆化之后：</p>
<p><img src="./images/DP大大大大大赏4.png" alt="" /></p>
<p>DP的一些一些要求：</p>
<p>无后效性：所有状态之间组成了一个DAG</p>
<p>阶段性：</p>
<p>转移方程：怎么算这个东西</p>
<p>状态：要算的东西对应的东西</p>
<p>乱序转移：</p>
<p>把所有状态当做点，所有转移当做边，然后进行拓扑排序；</p>
<p>要讲的几种DP：</p>
<p>l&nbsp; 数位DP</p>
<p>l&nbsp; 树形DP</p>
<p>l&nbsp; 状压DP</p>
<p>l&nbsp; 博弈论DP</p>
<p>l&nbsp; 区间DP</p>
<p>l&nbsp; 背包</p>
<p>乱序宣讲：</p>
<p>1.背包问题：</p>
<p>先看一个最简单的问题：</p>
<p>problem 1：</p>
<p>N个物品，M容量，每个物品都有体积和价值，最大化价值和；</p>
<p>典型的01背包问题，比较经典的例题是采药；</p>
<p>两种方法：1.用自己更新别人：</p>
<p>不选第i个物品，体积不变：f[i+1][j]=f[i][j]</p>
<p>选择第i+1个物品，体积增加：f[i+1][j+v<sub>i+1</sub>]=f[i][j]+w<sub>i+1</sub></p>
<p><img src="./images/DP大大大大大赏5.png" alt="" /></p>
<p>2.别人更新自己：</p>
<p>f[i][j]=max(f[i-1][j],f[i-1][j-vi]+wi)分别对应不选/选第i个物品；</p>
<p><img src="./images/DP大大大大大赏6.png" alt="" width="309" height="184" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fe3a6f29-dc69-4c1e-a86d-1e0a9162c808')"><img id="code_img_closed_fe3a6f29-dc69-4c1e-a86d-1e0a9162c808" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_fe3a6f29-dc69-4c1e-a86d-1e0a9162c808" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fe3a6f29-dc69-4c1e-a86d-1e0a9162c808',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_fe3a6f29-dc69-4c1e-a86d-1e0a9162c808" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">int</span> n,m,w[<span style="color: #800080;">233</span>],v[<span style="color: #800080;">233</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> f[<span style="color: #800080;">233</span>][<span style="color: #800080;">233</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    cin </span>&gt;&gt; n &gt;&gt;<span style="color: #000000;"> m;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a=<span style="color: #800080;">1</span>;a&lt;=n;a++<span style="color: #000000;">)
        cin </span>&gt;&gt; v[a] &gt;&gt;<span style="color: #000000;"> w[a];
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;=m;j++<span style="color: #000000;">)
        {
            f[i][j] </span>= f[i-<span style="color: #800080;">1</span><span style="color: #000000;">][j];
            </span><span style="color: #0000ff;">if</span> (j &gt;= v[i]) f[i][j] = max(f[i][j],f[i-<span style="color: #800080;">1</span>][j-v[i]]+<span style="color: #000000;">w[i]);
        }
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a=<span style="color: #800080;">0</span>;a&lt;=m;a++<span style="color: #000000;">)
        ans </span>=<span style="color: #000000;"> max(ans,f[n][a]);
    cout </span>&lt;&lt; ans &lt;&lt;<span style="color: #000000;"> endl;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>problem 2：（完全背包）</p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">每个物品可以用无限次：</span></p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">朴素的想法：</span></p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">枚举第</span><span lang="EN-US">i</span><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">个物品放了多少个；</span></p>
<p class="MsoNormal">&nbsp;<img src="./images/DP大大大大大赏9.png" alt="" width="319" height="20" /></p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">但是显然O（n^3）不够优；</span></p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">考虑优化：</span></p>
<p class="MsoNormal"><span style="font-family: 宋体; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-fareast-font-family: 宋体; mso-fareast-theme-font: minor-fareast; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin;">f[i][j]来说，上面的思路是有i-1行的某个数转移过来的，但实际上我们并不需要这样枚举转移，我们可以从左侧转移，假设当前已经选了一个x物品了，如果我们由左边更新过来，那可能我们算到的正是已经选择过一个x物品的状态，这样，背包就变成无限的啦；</span></p>
<p>修改代码：</p>
<p>变成了可以由同一行转移过来，横着转移x次&lt;=&gt;我用了x个第i个物品；</p>
<p><img src="./images/DP大大大大大赏10.png" alt="" /></p>
<p>problem 3：（多重背包）</p>
<p>如果每个物品可以用有限次？</p>
<p>考虑像完全背包一样枚举使用物品个数：</p>
<p><img src="./images/DP大大大大大赏11.png" alt="" /></p>
<p>尝试优化：</p>
<p>vi*13：</p>
<p>造物品：</p>
<ol>
<li>体积为vi只能用1次的物品，</li>
<li>体积为2vi只能用1次的物品；</li>
<li>体积为4vi只能用1次的物品；</li>
<li>体积为6vi只能用1次的物品；</li>
<li>可以把所有1~13内的体积表示出来</li>
</ol>
<p><img src="./images/DP大大大大大赏12.png" alt="" /></p>
<p>=&gt;转化为01背包；</p>
<p>O（n^2*k）</p>
<p>怎么变成若干捆绑包？</p>
<p>先用二进制表示，不足二进制的再用总的减去</p>
<p>发现k&asymp;logn</p>
<p>复杂度O(nmlogn)</p>
<p class="MsoNormal">&nbsp;<img src="./images/DP大大大大大赏13.png" alt="" /></p>
<p>绿框即为凑不够一个二进制然后减下来的</p>
<p>为什么可以把所有数表示出来？</p>
<p>恰好可以表示为x个二进制数：</p>
<p><img src="./images/DP大大大大大赏14.png" alt="" /></p>
<p>这样对于每一位都有0/1两种情况，1~31的每个数，都可以写成5位内的二进制，然后每一位只有0和1嘛，显然都可以通过上面算出来，对于不是恰好拆分成二进制的，可以先不看最后的数，然后看成1~31+x；</p>
<p>造捆绑包：</p>
<p><img src="./images/DP大大大大大赏15.png" alt="" /></p>
<p>基础DP：</p>
<p>problem 1：</p>
<ul>
<li>数字三角形</li>
<li>给你一个三角形</li>
<li>问从怎么走能够取得最大代价</li>
</ul>
<p>每次可以向下或向右下走，使得走过的这条路，所有数字之和最大；</p>
<p>&nbsp;<img src="./images/DP大大大大大赏16.png" alt="" /></p>
<p>正着推：f[i][j]=max(f[i-1][j],f[i-1][j-1])+a[i][j];最后要枚举最后一行哪一guo最大；</p>
<p><strong><span style="color: #ff0000;">突然安利的oj：joyoi</span></strong></p>
<p>数字三角形2：</p>
<p align="left">&nbsp;<img src="./images/DP大大大大大赏17.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏18.png" alt="" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fa8cd013-0ff4-4c87-8a88-4dead7f7ee6c')"><img id="code_img_closed_fa8cd013-0ff4-4c87-8a88-4dead7f7ee6c" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_fa8cd013-0ff4-4c87-8a88-4dead7f7ee6c" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fa8cd013-0ff4-4c87-8a88-4dead7f7ee6c',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_fa8cd013-0ff4-4c87-8a88-4dead7f7ee6c" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">#define</span> mod 100

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

inline </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> read(){
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> last=<span style="color: #800000;">'</span> <span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>||ch&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) last=ch,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;ch&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) ans=(ans&lt;&lt;<span style="color: #800080;">1</span>)+(ans&lt;&lt;<span style="color: #800080;">3</span>)+ch-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">if</span>(last==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) ans=-<span style="color: #000000;">ans;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ans;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">30</span>][<span style="color: #800080;">30</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> f[<span style="color: #800080;">30</span>][<span style="color: #800080;">30</span>][<span style="color: #800080;">110</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    n</span>=<span style="color: #000000;">read();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=i;j++<span style="color: #000000;">)
            a[i][j]</span>=<span style="color: #000000;">read();
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>][a[<span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>]%mod]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=i;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>;k&lt;<span style="color: #800080;">100</span>;k++<span style="color: #000000;">){
                f[i][j][k]</span>=(f[i-<span style="color: #800080;">1</span>][j-<span style="color: #800080;">1</span>][(k-a[i][j]+mod)%mod]|f[i-<span style="color: #800080;">1</span>][j][(k-a[i][j]+mod)%<span style="color: #000000;">mod]);
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> bj=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">99</span>;k&gt;=<span style="color: #800080;">0</span>;k--<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(f[n][i][k]){
                printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,k);
                bj</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span>(bj==<span style="color: #800080;">1</span><span style="color: #000000;">) 
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><img src="./images/DP大大大大大赏21.png" alt="" /></p>
<p align="left">自己更新别人，因此只需要算到n-1行；</p>
<p align="left">当状态是可行的我们才用它更新别人；</p>
<p align="left">转移啊：</p>
<p align="left"><img src="./images/DP大大大大大赏22.png" alt="" /></p>
<p align="left">最后计算答案：</p>
<p align="left">枚举最后一行走到哪一列，然后枚举走出来的和%100是多少。</p>
<p><img src="./images/DP大大大大大赏23.png" alt="" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fcc37c21-1c65-4b9c-83df-e9b413dcba01')"><img id="code_img_closed_fcc37c21-1c65-4b9c-83df-e9b413dcba01" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_fcc37c21-1c65-4b9c-83df-e9b413dcba01" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fcc37c21-1c65-4b9c-83df-e9b413dcba01',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_fcc37c21-1c65-4b9c-83df-e9b413dcba01" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;
<span style="color: #0000ff;">#define</span> mod 100

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

inline </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> read(){
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> last=<span style="color: #800000;">'</span> <span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>||ch&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) last=ch,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;ch&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) ans=(ans&lt;&lt;<span style="color: #800080;">1</span>)+(ans&lt;&lt;<span style="color: #800080;">3</span>)+ch-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">if</span>(last==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) ans=-<span style="color: #000000;">ans;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ans;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">30</span>][<span style="color: #800080;">30</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">bool</span> f[<span style="color: #800080;">30</span>][<span style="color: #800080;">30</span>][<span style="color: #800080;">110</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    n</span>=<span style="color: #000000;">read();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=i;j++<span style="color: #000000;">)
            a[i][j]</span>=<span style="color: #000000;">read();
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>][a[<span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>]%mod]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">1</span>;j&lt;=i;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>;k&lt;<span style="color: #800080;">100</span>;k++<span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(f[i][j][k]){
                    f[i</span>+<span style="color: #800080;">1</span>][j][(k+a[i+<span style="color: #800080;">1</span>][j])%mod]=<span style="color: #800080;">1</span><span style="color: #000000;">;
                    f[i</span>+<span style="color: #800080;">1</span>][j+<span style="color: #800080;">1</span>][(k+a[i+<span style="color: #800080;">1</span>][j+<span style="color: #800080;">1</span>])%mod]=<span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
    }
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> k=<span style="color: #800080;">0</span>;k&lt;<span style="color: #800080;">100</span>;k++<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(f[n][i][k])
                ans</span>=<span style="color: #000000;">max(ans,k);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,ans);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p align="left">最长上升子序列；</p>
<p align="left">当n&gt;=10^5，第二层j的枚举可以用线段树来做；</p>
<p align="left">有时可以用数据结构优化DP</p>
<p align="left">f[i]表示以第i个数结尾的最长上升子序列的长度，那么f[i]=max(f[j])+1,其中1&lt;=j&lt;i;</p>
<p align="left"><img src="./images/DP大大大大大赏26.png" alt="" width="454" height="235" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('01c5f808-d750-4892-9db5-0ee4ea2d35b9')"><img id="code_img_closed_01c5f808-d750-4892-9db5-0ee4ea2d35b9" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_01c5f808-d750-4892-9db5-0ee4ea2d35b9" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('01c5f808-d750-4892-9db5-0ee4ea2d35b9',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_01c5f808-d750-4892-9db5-0ee4ea2d35b9" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

inline </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> read(){
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> last=<span style="color: #800000;">'</span> <span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>||ch&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) last=ch,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;ch&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) ans=(ans&lt;&lt;<span style="color: #800080;">1</span>)+(ans&lt;&lt;<span style="color: #800080;">3</span>)+ch-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">if</span>(last==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) ans=-<span style="color: #000000;">ans;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ans;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,ans;
</span><span style="color: #0000ff;">int</span> p[<span style="color: #800080;">1010</span>],f[<span style="color: #800080;">1010</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    n</span>=<span style="color: #000000;">read();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        p[i]</span>=<span style="color: #000000;">read();
    }
    f[</span><span style="color: #800080;">1</span>]=<span style="color: #800080;">1</span>;p[<span style="color: #800080;">0</span>]=-<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;i;j++<span style="color: #000000;">){
            </span><span style="color: #0000ff;">if</span>(p[i]&gt;p[j]) f[i]=<span style="color: #000000;">max(f[i],f[j]);
        }
        f[i]</span>+=<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++) ans=<span style="color: #000000;">max(ans,f[i]);
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span><span style="color: #000000;">,ans);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p align="left">区间DP：</p>
<p align="left">区间DP特征：给n个东西，每次只能合并两个相邻的东西；</p>
<p align="left">最最最最最典型的例子，<a href="https://www.cnblogs.com/zhuier-xquan/p/11112216.html" target="_blank">石子合并</a></p>
<p align="left">合并的顺序不同，代价也不同；</p>
<p align="left">f[l][r]把第l堆石子到第r堆石子合并成一堆的最小代价是多少；</p>
<p align="left">f[l][l]=0；</p>
<p align="left">合并[l,r]</p>
<p align="left">我们可以找到一个分界线，先将分界线左边的石子合并为一堆，然后右边的合并成一堆，最后再将这两堆合并成一堆（将这两堆合并的代价是这一段石子的区间和）：</p>
<p align="left">然后维护前缀和来计算区间和；</p>
<p align="left"><img src="./images/DP大大大大大赏29.png" alt="" width="393" height="162" /></p>
<p align="left">注意要枚举区间长度，然后枚举左端点，计算右端点；</p>
<p align="left">切不可两层循环枚举左右端点；</p>
<p align="left"><img src="./images/DP大大大大大赏30.png" alt="" /></p>
<p align="left">一个有关矩阵乘法的问题：</p>
<p align="left">矩阵乘法</p>
<p align="left">自定义顺序</p>
<p align="left">使得运算次数最少</p>
<p align="left">矩阵乘法结合律：</p>
<p><img src="./images/DP大大大大大赏31.png" alt="" width="207" height="59" /></p>
<p align="left">N个矩阵， M1&nbsp; ,&nbsp; M2,&nbsp;&nbsp; M3&hellip;&hellip;Mn</p>
<p align="left">大小为： a1*a2 &nbsp;a2*a3 &nbsp;a3*a4&nbsp; an*an+1</p>
<p align="left"><img src="./images/DP大大大大大赏32.png" alt="" width="473" height="105" /></p>
<p align="left">操作：合并两个相邻的矩阵；</p>
<p align="left">目标：合并成一个矩阵；</p>
<p align="left">f[l][r]把第l~第r个矩阵合并成一个矩阵；</p>
<p align="left">f[l][r]=min(f[l][p]+f[p+1][r]+al*a<sub>p+1</sub>*a<sub>r+1</sub>)；</p>
<p align="left"><span style="color: #ff0000;">能量项链的说</span></p>
<p align="left"><img src="./images/DP大大大大大赏33.png" alt="" width="396" height="111" /></p>
<p align="left">状压DP：</p>
<p align="left">n&lt;=20（22）&lt;=&gt;状压</p>
<p align="left">problem 1：p1171</p>
<p align="left"><img src="./images/DP大大大大大赏34.png" alt="" /></p>
<p align="left">第i个点坐标 xi，yi；</p>
<p align="left">f[s][i]</p>
<p align="left">s:n位的二进制数，已经走到过的点<img src="./images/DP大大大大大赏35.png" alt="" />：{1,2,4,6}说明已经走过1,2,4,6点，对应二进制=&gt;101011</p>
<p><img src="./images/DP大大大大大赏36.png" alt="" /></p>
<p align="left">转化为10进制：11=&gt;01011；</p>
<p align="left">常见压缩方法：把数组表示为k进制的数；</p>
<p align="left">转移：枚举一个j，表示第j个点，然后要求j是没走过的；</p>
<p align="left">因为是状压DP，为了方便二进制的表示，我们的循环从0开始。</p>
<p align="left">初始化f数组为为超级大的一个数，然后f[s][i]表示状态s（转化为二进制后1代表已经走了这个数，0代表没有走这个点）并且现在在点i时的最短路径，显然起点1-1时为0（注意点的下标从0开始因此最后都要-1）</p>
<p align="left">然后枚举状态，尝试转移：，j</p>
<p align="left">然后枚举当前走到了哪个点，判断这种状态有没有被更新过，如果被更新过了，我们用它更新其他的点；</p>
<p align="left">枚举接下来走哪个点，要注意判断这个点之前要没有走过，然后更新状态，将新状态赋值；</p>
<p align="left">最后答案是枚举最后走到哪个点，然后加上最后走到的点到起点的距离，取最小，就是最后的答案；</p>
<p align="left">伪代码：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('c9959204-25ce-4e07-8802-286761a18950')"><img id="code_img_closed_c9959204-25ce-4e07-8802-286761a18950" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_c9959204-25ce-4e07-8802-286761a18950" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('c9959204-25ce-4e07-8802-286761a18950',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_c9959204-25ce-4e07-8802-286761a18950" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

</span><span style="color: #0000ff;">double</span><span style="color: #000000;"> f[][];
</span><span style="color: #0000ff;">double</span> x[<span style="color: #800080;">233</span>],y[<span style="color: #800080;">233</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    cin </span>&gt;&gt;<span style="color: #000000;"> n;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a=<span style="color: #800080;">0</span>;a&lt;n;a++<span style="color: #000000;">)
        cin </span>&gt;&gt; x[a] &gt;&gt;<span style="color: #000000;"> y[a];
    f</span>=<span style="color: #000000;">&infin;
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>]=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> s=<span style="color: #800080;">0</span>;s&lt;(<span style="color: #800080;">1</span>&lt;&lt;n);s++<span style="color: #000000;">)
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
            </span><span style="color: #0000ff;">if</span> (f[s][i] &lt;<span style="color: #000000;"> &infin;)
            {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j=<span style="color: #800080;">0</span>;j&lt;n;j++<span style="color: #000000;">)
                    </span><span style="color: #0000ff;">if</span> ( ((s&gt;&gt;j) &amp; <span style="color: #800080;">1</span>) == <span style="color: #800080;">0</span><span style="color: #000000;">)
                    {
                        </span><span style="color: #0000ff;">int</span> news = s | (<span style="color: #800080;">1</span>&lt;&lt;<span style="color: #000000;">j);
                        f[news][j] </span>= min(f[news][j],f[s][i] +<span style="color: #000000;"> dis(i,j));
                    }
            }
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
        ans</span>=min(ans, f[(<span style="color: #800080;">1</span>&lt;&lt;n)-<span style="color: #800080;">1</span>][i] + dis(i,<span style="color: #800080;">0</span><span style="color: #000000;">));
        
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>problem 2：luogu1879</p>
<p><img src="./images/DP大大大大大赏39.png" alt="" /></p>
<p align="left">f[i][s]前i行草已经种完了，这一行的草长成s样时的方案数；</p>
<p align="left">用二进制的数来代表第i行每个位置有没有种草</p>
<p align="left">判断第i行S和第i+1行S&rsquo;没有相邻的草：S&amp;S&rsquo;==0；</p>
<p align="left">problem 3：p1896</p>
<p align="left"><img src="./images/DP大大大大大赏40.png" alt="" /></p>
<p align="left">n&lt;=8</p>
<p align="left">枚举怎么放国王，然后判断是否冲突，因为多了一个恰好，因此我们加一维：f[i][s][j]代表：i与s的表示同上题，j表示现在放了j国王了；</p>
<p align="left">然后判断需要修改一下；</p>
<p align="left">数位DP：</p>
<p align="left">什么是数位DP？难啊</p>
<p align="left">DP时按照数的每一位一位一位进行转移的；</p>
<p align="left">举个栗子：</p>
<p align="left">给定两个数l，r，问从了l~r有多少个数；</p>
<p align="left">显然是ans=r-l+1</p>
<ol>
<li>往往先进行前缀和转化；</li>
</ol>
<p align="left">从高位向低位</p>
<p align="left">f[i][1/0] 已经填好第i位&nbsp; j==0？ now&lt;x:无法确定now（其实就是目前和x长得一样）；</p>
<p align="left">在以上情况这种数有多少个；</p>
<p align="left">考虑下一位要填什么数；</p>
<p align="left"><img src="./images/DP大大大大大赏41.png" alt="" width="141" height="28" /></p>
<p align="left">x只有l位，那么y的l+1,l+2&hellip;&hellip;位（个位最小）只能填0，那么填第l+1位和x一样的方案数只有1中（全为0）</p>
<p><img src="./images/DP大大大大大赏42.png" alt="" /></p>
<p align="left">填了之后y&gt;x；</p>
<p align="left">problem2：</p>
<p align="left">求[l,r]中的数的数位之和</p>
<p align="left">仍然是维护一个前缀和：</p>
<p align="left"><img src="./images/DP大大大大大赏43.png" alt="" /></p>
<p align="left">problem 3：BZOJ1026 windy数</p>
<p align="left"><img src="./images/DP大大大大大赏44.png" alt="" /></p>
<p align="left">f[i][j][k]已经填好了第i位；j：&lt;/=；k：第i位填了k</p>
<p align="left">保证第i位和第i+1位的数字大小差至少2；</p>
<p align="left">差不多搞定了？</p>
<p align="left">problem 4：BZOJ2757</p>
<p><img src="./images/DP大大大大大赏45.png" alt="" />K&lt;=10^18;</p>
<p align="left">有一些位置永远不会用到，比如13，存在的只能是&lt;10的质数；</p>
<p align="left"><img src="./images/DP大大大大大赏46.png" alt="" /></p>
<p align="left">数组大小a：log210^18&nbsp; b：log310^18&nbsp; c：log510^18&nbsp; d：log710^18</p>
<p align="left">再优化：</p>
<p align="left">把所有以上形式<img src="./images/DP大大大大大赏47.png" alt="" /></p>
<p align="left">的数算出来，大概有30000多个，预处理出来，然后放到数组中，然后转移f[i][j][k]，表示是这三万多个数中第k个数qwq；</p>
<p align="left">树形DP：</p>
<p align="left">假设为有根树；</p>
<p align="left">从下到上</p>
<p align="left">在每个点，维护以其为根的子树的信息；</p>
<p align="left">problem 1：</p>
<p align="left">求树上有多少个点？</p>
<p align="left">f[i]表示以i为根的子树有多少个点？</p>
<p><img src="./images/DP大大大大大赏48.png" alt="" /></p>
<p align="left">problem 2：</p>
<p align="left">求树的直径；</p>
<p align="left">在树上找两个点，使他们距离最远；</p>
<p align="left">从每个点向下走，最长和次长是多少</p>
<p align="left">f[i][0]从i这个点向下走，最长的是多少；</p>
<p align="left">f[i][1]从i这个点向下走，次长的是多少；</p>
<p align="left">然后枚举在每个点转弯的最大值和次大值的和，求一个最大的；</p>
<p align="left">f[i][0]=max(f[p<sub>j</sub>][0]) +1 p<sub>j</sub>&isin;son(i);</p>
<p align="left">f[i][1]=max(f[pk][0])+1pk!=pj,pk&isin;son(i)避免和f[i][0]选到同一个位置去，那么f[p<sub>j</sub>][1]不能用了，其余的最长路显然大于次长路，因此只需要在剩余儿子中找一个最大的（总体次大的）；</p>
<p align="left"><img src="./images/DP大大大大大赏49.png" alt="" /></p>
<p align="left">problem 3：</p>
<p align="left">求树上路径总长度和</p>
<p align="left">f[i]表示以i为根的子树有多少个点；</p>
<p align="left">然后</p>
<p align="left">考虑一条边，会被多少条路径经过：</p>
<p align="left">只要保证一个点在子树中，一个点在子树外面选一个点，一定会经过这条边，然后路径可以正着走，也可以反着走，需要*2</p>
<p align="left"><img src="./images/DP大大大大大赏50.png" alt="" /></p>
<p align="left">problem 4：Poj2342</p>
<p align="left"><img src="./images/DP大大大大大赏51.png" alt="" /></p>
<p align="left">f[i][0/1] 以i为根的子树中，选出若干个点，权值最大是多少</p>
<p align="left">0=&gt; i没选 1=&gt;i选了；</p>
<p align="left">最后答案：max(f[1][0],f[1][1])</p>
<p align="left">f[i][1]=&Sigma;f[j][0]+a[i] j&isin;son(i)；</p>
<p align="left">f[i][0]=&Sigma;max(f[j][0],f[j][1]) j&isin;son(i)</p>
<p align="left"><img src="./images/DP大大大大大赏52.png" alt="" /></p>
<div class="cnblogs_code" onclick="cnblogs_code_show('fc18aa42-5e24-439d-8614-672036bccf95')"><img id="code_img_closed_fc18aa42-5e24-439d-8614-672036bccf95" class="code_img_closed" src="./images/DP大大大大大赏7.png" alt="" /><img id="code_img_opened_fc18aa42-5e24-439d-8614-672036bccf95" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fc18aa42-5e24-439d-8614-672036bccf95',event)" src="./images/DP大大大大大赏8.png" alt="" />
<div id="cnblogs_code_open_fc18aa42-5e24-439d-8614-672036bccf95" class="cnblogs_code_hide">
<pre>#include&lt;iostream&gt;<span style="color: #000000;">
#include</span>&lt;cstdio&gt;<span style="color: #000000;">
#include</span>&lt;algorithm&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

inline </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> read(){
    </span><span style="color: #0000ff;">int</span> ans=<span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> last=<span style="color: #800000;">'</span> <span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>||ch&lt;<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) last=ch,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">while</span>(ch&gt;=<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>&amp;&amp;ch&lt;=<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) ans=(ans&lt;&lt;<span style="color: #800080;">1</span>)+(ans&lt;&lt;<span style="color: #800080;">3</span>)+ch-<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>,ch=<span style="color: #000000;">getchar();
    </span><span style="color: #0000ff;">if</span>(last==<span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) ans=-<span style="color: #000000;">ans;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ans;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,k,l;
</span><span style="color: #0000ff;">int</span> f[<span style="color: #800080;">6010</span>][<span style="color: #800080;">2</span>];<span style="color: #008000;">//</span><span style="color: #008000;">1 choose this people/0 do not choose this people</span>
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> node{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> fa,cnt,r;
    </span><span style="color: #0000ff;">int</span> son[<span style="color: #800080;">3001</span><span style="color: #000000;">];
}p[</span><span style="color: #800080;">6001</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">void</span> dfs(<span style="color: #0000ff;">int</span><span style="color: #000000;"> node){
    </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">p[node].cnt) {
        f[node][</span><span style="color: #800080;">1</span>]=<span style="color: #000000;">p[node].r;
        f[node][</span><span style="color: #800080;">0</span>]=<span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }

    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=p[node].cnt;i++<span style="color: #000000;">){
        dfs(p[node].son[i]);
    }
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=p[node].cnt;i++<span style="color: #000000;">){
        f[node][</span><span style="color: #800080;">1</span>]+=f[p[node].son[i]][<span style="color: #800080;">0</span><span style="color: #000000;">];
        f[node][</span><span style="color: #800080;">0</span>]+=max(f[p[node].son[i]][<span style="color: #800080;">0</span>],f[p[node].son[i]][<span style="color: #800080;">1</span><span style="color: #000000;">]);
    }
    f[node][</span><span style="color: #800080;">1</span>]+=<span style="color: #000000;">p[node].r;
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main(){
    n</span>=<span style="color: #000000;">read();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++) p[i].r=<span style="color: #000000;">read();
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;n;i++<span style="color: #000000;">) {
        l</span>=read();k=<span style="color: #000000;">read();
        p[l].fa</span>=<span style="color: #000000;">k;
        p[k].son[</span>++p[k].cnt]=<span style="color: #000000;">l;
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> s;
    </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">1</span>;i&lt;=n;i++<span style="color: #000000;">){
        </span><span style="color: #0000ff;">if</span>(!p[i].fa) dfs(i),s=<span style="color: #000000;">i;
    }
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,max(f[s][<span style="color: #800080;">1</span>],f[s][<span style="color: #800080;">0</span><span style="color: #000000;">]));
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">迷之MLE，然后把son改小为原来的1/2，居然过了</span></div>
<p align="left">problem 5：poj1463</p>
<p align="left">&nbsp;<img src="./images/DP大大大大大赏55.png" alt="" /></p>
<p align="left">f[i][0/1] 以i为根的子树所有节点都被守护(0i没有士兵，1i有士兵)所需最少士兵数量</p>
<p align="left">f[i][0]=&Sigma;f[j][1] j&isin;son(i) //父亲不放士兵，所以儿子一定要放士兵</p>
<p align="left">f[i][1]=&Sigma;min(f[j][0],f[j][1])+1 j&isin;son(i) //父亲不放士兵，那么儿子放不放无所谓，取放与不放的最小值</p>
<p align="left">up：消防局的设立；luogu2279</p>
<p align="left">守护所有距离不超过2的节点：</p>
<p align="left">f[i][0/1/2]以i为根的子树已经全部覆盖的情况下，i这个点向下走，到达最近的士兵的距离是0/1/2的最小士兵数；</p>
<p align="left">相当于自己放士兵f[i][0]=&Sigma;min(f[j][0/1/2])+1; j&isin;son(i);</p>
<p align="left">相当于儿子放士兵f[i][1]再跑一个DP来求f[i][1]:</p>
<p align="left">用另一个数组g[j][1/0]；已经确定了前j个儿子的取值，其中这j个儿子中有（1）没有（0）拿出一个0值（到达最近士兵距离为0）来更新答案；</p>
<p align="left">相当于孙子放士兵f[i][2]</p>
<p align="left">另一种解法：</p>
<p>定根之后，找到这棵树中深度最深的叶子节点：</p>
<p>1.自己 2.兄弟 3.父亲 4.爷爷</p>
<p>应该选择哪一种？</p>
<p>显然是4，因为把士兵放在1 2 3位置能覆盖到的所有节点，放在4都可以被覆盖；</p>
<p>找出深度最深的节点，找到他的爷爷，在爷爷的位置放一个士兵，把它爷爷能覆盖到的所有节点直接从树中删掉；</p>
<p>重复直到没有节点；</p>
<p>&nbsp;</p>
<p align="left">N堆石子，可以合并任意两堆，合并的代价是两堆的异或和；</p>
<p align="left">状压dp。f[s]把s所对应的石子，合并为1堆的最小代价；</p>
<p align="left"><img src="./images/DP大大大大大赏56.png" alt="" /></p>
<p align="left">枚举0 2 3 5的一个子集，</p>
<p align="left"><img src="./images/DP大大大大大赏57.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏58.png" alt="" />枚举每个状态的石子总和</p>
<p><img src="./images/DP大大大大大赏59.png" alt="" /></p>
<p align="left">初始化，求最小，所以初始为无穷大。然后只合并一堆代价为0；</p>
<p align="left">枚举s的子集a：</p>
<p align="left">判断a为s的子集：</p>
<p align="left">&nbsp;<img src="./images/DP大大大大大赏60.png" alt="" /></p>
<p align="left">剩下那坨石子：a^s；</p>
<p>&nbsp;<img src="./images/DP大大大大大赏61.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏62.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏63.png" alt="" /></p>
<p align="left">但是，这个算法过不了n=16 O(4^n)</p>
<p align="left">改进：</p>
<p align="left"><img src="./images/DP大大大大大赏64.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏65.png" alt="" /></p>
<p align="left">O(3^n)</p>
<p align="left">博弈论DP：</p>
<p align="left">类型1：现在有一个游戏G，两个人玩，回合制，没有平局；胜负的区分方法：当某个人没办法进行操作时，这个人就输了；</p>
<p align="left">然后两个人都绝顶聪明，会做出对自己最最最最有利的操作。</p>
<p align="left">一般问的都是先手是否必胜，或者先手是否必败。</p>
<p align="left">当走到某个状态后，无法再走，则再此点的人一定会输，称为必败态；</p>
<p align="left">因为绝顶聪明，所以左上角的点是必胜态</p>
<p align="left"><img src="./images/DP大大大大大赏66.png" alt="" /></p>
<p align="left">f[s]=1/0 s是一个状态。状态s是否是必胜；</p>
<p align="left">s1~sm如果存在f[si]=0（必败态），则有f[s]=1；</p>
<p align="left">任意f[si]=1,则f[s]=0；</p>
<p align="left">problem 1：</p>
<p align="left"><img src="./images/DP大大大大大赏67.png" alt="" /></p>
<p align="left">f[i][j]原数还剩下i，对手上一次减了j，这种情况是必胜，还是必败；</p>
<p align="left"><img src="./images/DP大大大大大赏68.png" alt="" /></p>
<p align="left">建议用记忆化搜索；</p>
<p align="left">f[i][j]必胜or必败，g[i][j]i，j对应的状态算没算过；</p>
<p align="left"><img src="./images/DP大大大大大赏69.png" alt="" /></p>
<p align="left">第二类：n个游戏G1，G2&hellip;&hellip;Gn，两个人，回合制，分出胜负，在每个游戏中都不能动的输；</p>
<p align="left">取石子游戏：</p>
<p align="left">n堆石子，a1，a2，&hellip;&hellip;an；Alice and Bob，Alice先手。从某一堆石子中取走任意多个石子，当谁没法取石子，谁就输了</p>
<p align="left">SG函数：</p>
<p align="left">sg[必败态]=0;</p>
<p align="left">此题中：sg[1]=1;sg[2]=2;<br />
sg[x]所有可以转移到状态中的sg没有出现过的最小自然数；</p>
<p align="left"><img src="./images/DP大大大大大赏70.png" alt="" /><img src="./images/DP大大大大大赏71.png" alt="" /></p>
<p align="left">在本题中，sg[n]=n；</p>
<p align="left">如果一个游戏的sg!=0 先手必败；</p>
<p align="left">sg=0先手必败；</p>
<p align="left">SG定理：</p>
<p align="left">n个游戏组合在一起的SG值，等于每个游戏的SG值异或起来；</p>
<p>&nbsp;<img src="./images/DP大大大大大赏72.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏73.png" alt="" /></p>
<p>取石子-改：</p>
<p align="left">n堆石子，a1，a2，&hellip;&hellip;an；Alice and Bob，Alice先手。从某一堆石子中取走1~4个石子，当谁没法取石子，谁就输了</p>
<p>sg[ai]=ai%5;</p>
<p>problem 4：</p>
<p>&nbsp;<img src="./images/DP大大大大大赏74.png" alt="" /></p>
<p>博弈论问题一般：把题目转化为基本的取石子问题；</p>
<p>算出每堆是奇数个还是偶数个，1为奇数，2为偶数；把所有奇数堆的下标取出来，异或起来=0先手必败，！=0先手必胜</p>
<p>&nbsp;<img src="./images/DP大大大大大赏75.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏76.png" alt="" /></p>
<p>把所有下标为奇数的位置的石子异或起来就是答案：</p>
<p>&nbsp;<img src="./images/DP大大大大大赏77.png" alt="" /></p>
<p><img src="./images/DP大大大大大赏78.png" alt="" /></p>
<p>距离终点为奇数的格子上的棋子异或起来；</p>
<p>&nbsp;<img src="./images/DP大大大大大赏79.png" alt="" /></p>
<p>f[s] s:n位的二进制数，代表每个位置有没有被标记过，然后炸了。</p>
<p>考虑当做多个游戏</p>
<p>保证先手必胜，则先手涂色的左右两个都不能涂色，将剩余的拆成两个独立的游戏，再将其合并</p>
<p>sg[i]长度为i的横条，sg值是多少</p>
<p>BZOJ2789</p>
<p>&nbsp;<img src="./images/DP大大大大大赏80.png" alt="" /></p>
<p>f[x][y] =&gt;f[1][x+y]</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; =&gt;f[2x][y]</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; =&gt;f[3x][y]</p>
<p>f[a][b][y] x=2^a*3^b;</p>
<p>&nbsp;<img src="./images/DP大大大大大赏81.png" alt="" /></p>
<p>&nbsp;</p>
<p align="left"><br clear="all" />
</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>