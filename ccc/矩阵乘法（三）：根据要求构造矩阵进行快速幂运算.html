<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修矩阵乘法（三）：根据要求构造矩阵进行快速幂运算' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>矩阵乘法（三）：根据要求构造矩阵进行快速幂运算</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11449050.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 在应用矩阵的快速幂运算解决一些递推问题时，由于递推式不是一个直接的线性关系，这样不能直接简单地得到用于运算的矩阵，需要进行适当的构造。下面先看一道POJ 上的经典题目。</p>
<p>【例1】Matrix Power Series （POJ 3233）</p>
<p>Description</p>
<p>Given a n &times; n matrix A and a positive integer k, find the sum S = A + A2 + A3 + &hellip; + Ak.</p>
<p>Input</p>
<p>The input contains exactly one test case. The first line of input contains three positive integers n (n &le; 30), k (k &le; 109) and m (m &lt; 104). Then follow n lines each containing n nonnegative integers below 32,768, giving A&rsquo;s elements in row-major order.</p>
<p>Output</p>
<p>Output the elements of S modulo m in the same way as A is given.</p>
<p>Sample Input</p>
<p>2 2 4<br />0 1<br />1 1<br />Sample Output</p>
<p>1 2<br />2 3</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 题目的意思是：输入n*n矩阵A，求S=A + A^2 + A^3 + &hellip; + A^k的结果（两个矩阵相加就是对应位置分别相加），输出的数据mod m。</p>
<p>&nbsp; &nbsp; &nbsp; 显然不能将各个矩阵的2~k次幂均计算出来，会超时的。</p>
<p>&nbsp; &nbsp; &nbsp; 可以构造出一个2n*2n的矩阵P，采用分块的方法表示如下，，其中 A 为原矩阵，I 为单位矩阵，O 为0矩阵。</p>
<p>&nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算0.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;我们发现 P<sup>k+1&nbsp;</sup>右上角那一个分块n*n矩阵正是要求的&nbsp;A+A<sup>2</sup>+...+A<sup>k&nbsp;</sup>。</p>
<p>　　于是我们构造出 P矩阵，然后对它求矩阵快速幂，最后减去一个单位阵即可得到结果。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; int mat[61][61];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n,int m)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (i = 1; i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=1 ;j&lt;=n ; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (k = 1 ;k&lt;=n ;k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j]=(c.mat[i][j]+a.mat[i][k] * b.mat[k][j]) % m;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b,int m) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = matMul(c ,a ,n,m);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n,m);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,k,m,i,j;<br />&nbsp; &nbsp; &nbsp; Matrix p ;<br />&nbsp; &nbsp; &nbsp; scanf("%d%d%d",&amp;n,&amp;k,&amp;m);<br />&nbsp; &nbsp; &nbsp; memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=1;j&lt;=n;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d",&amp;p.mat[i][j]);<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[i][n+i]=1;&nbsp; &nbsp; &nbsp; &nbsp; // 右上角的单位矩阵<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[n+i][n+i]=1;&nbsp; &nbsp; // 右下角的单位矩阵<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; p = quickMatPow(p,2*n,k+1,m);<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++) <br />&nbsp; &nbsp; &nbsp; p.mat[i][i+n]--;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 减去单位矩阵<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=n+1;j&lt;=2*n;j++) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d ",(p.mat[i][j]+m)%m);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 由于构造的P矩阵中含有大量的0元素，因此可以考虑在矩阵相乘时进行优化，优化的方法是如果是0元素就不进行对应元素运算。优化后的矩阵相乘函数如下：</p>
<p style="margin-left: 30px;">Matrix matMul(Matrix a ,Matrix b,int n,int m)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % m;<br />&nbsp; &nbsp; &nbsp; return c;<br />}</p>
<p><span style="font-size: 16px;"><strong>【例2】另类斐波那契数列。</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; 已知斐波那契数列为：F(0) = 1，F(1) = 1，F(N) = F(N - 1) + F(N - 2)&nbsp; (N &gt;= 2)。现定义一个新的类斐波那契数列：&nbsp;A(0) = 1，A(1) = 1，A(N) = X * A(N - 1) + Y * A(N - 2) (N &gt;= 2)。</p>
<p>&nbsp; &nbsp; &nbsp; 输入x、y和n，求新定义数列的前n项的平方和，即S(n)=A(0)^2+A(1)^2+....+A(n)^2。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 根据数列递推式不能直观地得到用于递推的矩阵，需要进行分析、构造。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 因为&nbsp; S[ n ]&nbsp; = S[ n -1 ]&nbsp; + A[n]^2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A[n]=X*A[n-1]+Y*A[n-2]</p>
<p>&nbsp; &nbsp; &nbsp; 所以&nbsp; S[n]=S[n-1]+X^2*A[n-1]^2+Y^2*A[n-2]^2+2XYA[n-1]*A[n-2]</p>
<p>&nbsp; &nbsp; &nbsp; 等式的右边有四项，有变化的是S[ n-1]，A[n-1]^2，A[n-2]^2，A[n-1]*A[n-2]，各自的系数1，x^2，Y^2，2XY一经输入就确定了，不会再变化。</p>
<p>&nbsp; &nbsp; &nbsp; 而有变化的四项S[ n-1]，A[n-1]^2，A[n-2]^2，A[n-1]*A[n-2]向前推进一步应该为</p>
<p>S[ n]，A[n]^2，A[n-1]^2，A[n]*A[n-1]。</p>
<p>&nbsp; &nbsp; &nbsp; 这样，可以构造一个4*4的矩阵P。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算1.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;为什么这样构造呢？是因为&nbsp; &nbsp;（仔细体会一下哟!）</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算2.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 构造好矩阵P后，就可以采用矩阵快速幂运算求S(n)了。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算3.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MOD 10007<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; int mat[5][5];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % MOD;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; &nbsp;int n,x,y,ans;<br />&nbsp; &nbsp; &nbsp; &nbsp;Matrix p;<br />&nbsp; &nbsp; &nbsp; &nbsp;while(scanf("%d%d%d" ,&amp;n ,&amp;x ,&amp;y)!=EOF)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = x%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y = y%MOD ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n==2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n" ,(x*x%MOD+y*y%MOD+2*x*y%MOD+2)%MOD) ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[1][1]=p.mat[3][2]=1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[1][2]=p.mat[2][2]=(x*x)%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[1][3]=p.mat[2][3]=(y*y)%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[1][4]=p.mat[2][4]=(2*x*y)%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[4][2]=x;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[4][4]=y;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = quickMatPow(p,4,n-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans=(p.mat[1][1]*2%MOD+p.mat[1][2]+p.mat[1][3]+p.mat[1][4])%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n" ,ans);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;将此源程序提交给 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3306" target="_blank">HDU 3306 &ldquo;Another kind of Fibonacci&rdquo;</a>，可以Accepted。&nbsp;&nbsp;&nbsp;</p>
<p><strong><span style="font-size: 16px;">【例3】又一个非线性递推数列。</span></strong></p>
<p align="left">&nbsp; &nbsp; &nbsp; 设有数列F的定义如下：f[1] =a，f[2]=b，&nbsp; f(n)=f(n-1)+f(n-2)*2+n^4&nbsp; （n&gt;=3）。</p>
<p>&nbsp; &nbsp; &nbsp; 输入a、b和n的值， 求f[n] mod&nbsp;2147493647的结果。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 通过本题可以更进一步思考用于递推的矩阵的构造方法。</p>
<p>&nbsp; &nbsp; &nbsp; 因为&nbsp; f(n)=f(n-1)+f(n-2)*2+n^4</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f(n-1)=f(n-2)+f(n-3)*2+(n-1)^4</p>
<p>&nbsp; &nbsp; &nbsp; 因此，构造矩阵时的关键是找到怎样由(n-1)^4到n^4的递推。</p>
<p>&nbsp; &nbsp; &nbsp; 又由于 n^4=(n-1+1)^4=(n-1)^4 + 4 (n-1)^3 + 6 (n-1)^2 + 4 (n-1)^1 +1，因此，需要通过构造</p>
<p>矩阵维护好f(n-1)、f(n-2)、(n-1)^4、(n-1)^3、(n-1)^2、(n-1)^1和(n-1)^0这7个值。</p>
<p>&nbsp; &nbsp; &nbsp;可以构造P矩阵如下：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算4.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;为什么这样构造呢？是因为 （好好体会哟！）</p>
<p><img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算5.png" alt="" width="590" height="472" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 构造好矩阵P后，就可以采用矩阵快速幂运算求f(n)了。</p>
<p>&nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（三）：根据要求构造矩阵进行快速幂运算6.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MOD 2147493647<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; __int64 mat[8][8];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % MOD;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = matMul(c ,a ,n);    // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = matMul(a ,a ,n);        // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int t,n,a,b;<br />&nbsp; &nbsp; &nbsp; __int64 ans;<br />&nbsp; &nbsp; &nbsp; Matrix p;<br />&nbsp; &nbsp; &nbsp; scanf("%d" ,&amp;t);<br />&nbsp; &nbsp; &nbsp; while(t--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d%d%d" ,&amp;n ,&amp;a ,&amp;b);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (n==1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",a);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (n==2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",b);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][1]=p.mat[1][3]=p.mat[1][7]=1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[2][1]=p.mat[3][3]=p.mat[3][7]=1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[4][4]=p.mat[4][7]=p.mat[5][5]=1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[5][7]=p.mat[6][6]=p.mat[6][7]=p.mat[7][7]=1;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][2]=p.mat[5][6]=2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[4][5]=p.mat[4][6]=3;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][4]=p.mat[1][6]=p.mat[3][4]=p.mat[3][6]=4;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][5]=p.mat[3][5]=6;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = quickMatPow(p,7,n-2);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(b*p.mat[1][1])% MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+a*p.mat[1][2]) % MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+16*p.mat[1][3]) % MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+8*p.mat[1][4]) % MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+4*p.mat[1][5]) % MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+2*p.mat[1][6]) % MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans+p.mat[1][7])% MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%I64d\n" ,ans);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将此源程序提交给 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5950" target="_blank">HDU 5950 &ldquo;Recursive sequence&rdquo;</a>，可以Accepted。&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6470" target="_blank">&nbsp;HDU 6470 &ldquo;Count&rdquo;</a>与本题类似，其递推式为 f(1)=1，f(2)=2， f(n)=f(n-1)+2*f(n-2)+n^3 （n&gt;=3)。请体会本题的编程思路后，自行修改上面的程序，完成 HDU 6470。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>