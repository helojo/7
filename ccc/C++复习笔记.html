<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++复习笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++复习笔记</center></div><div class='banquan'>原文出处:本文由博客园博主AN_drew提供。<br/>
原文连接:https://www.cnblogs.com/an-drew/p/11222651.html</div><br>
    <p> 　　　　　　　　　　　　　　C++基本数据类型<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />char									1字节(8位) 　　　　取值范围 （-2^7）~（2^7-1）即-128~127<br />signed char								1字节(8位)　　　　取值范围 （-2^7）~（2^7-1）即-128~127<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />unsigned char                           1字节(8位)　　　　取值范围   0~（2^8-1）即0~255<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />short int（或short）					2字节(16位)　　　　取值范围（-2^15）~（2^15-1） 即-32768~32767<br />signed short int（或signed short）		2字节(16位)　　　　取值范围（-2^15）~（2^15-1） 即-32768~32767<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />unsigned short int（或unsigned short）	2字节(16位)　　　　取值范围 0~（2^16-1） 即0~65535<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />int                                   	4字节(32位)　　　　取值范围 （-2^31）~（2^31-1） 即-2147483648~2147483647<br />signed int（或signed）                 	4字节(32位)　　　　取值范围 （-2^31）~（2^31-1） 即-2147483648~2147483647<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />unsigned int（或unsigned）            	4字节(32位)　　　　取值范围 0~（2^32-1） 即0~4294967295<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />long int（或long）                      4字节(32位)　　　　取值范围 （-2^31）~（2^31-1） 即-2147483648~2147483647<br />signed long int（或signed long）        4字节(32位)　　　　取值范围 （-2^31）~（2^31-1） 即-2147483648~2147483647<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />unsigned long int（或unsigned long）	4字节(32位)　　　　取值范围 0~（2^32-1） 即0~4294967295<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />float                                 	4字节(32位)　　　　取值范围 （-3.4x10^38）~（3.4x10^38） ，约6位有效数字<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />double                                  8字节(64位)　　　　取值范围  （-1.7x10^308）~（1.7x10^308） ，约15位有效数字<br />long double                          	8字节(64位)　　　　取值范围  （-1.7x10^308）~（1.7x10^308） ，约15位有效数字<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<p>char，signed char 是等价的<br />short，short int，signed short，signed short int 都是等价的<br />int，signed，signed int，long，long int，signed long，signed long int 都是等价的<br />double，long double 是等价的</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>                                      C++<span style="color: #000000;">基本数据类型
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">char</span>                                    1字节(8位)        取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">7</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">7</span>-<span style="color: #800080;">1</span>）即-<span style="color: #800080;">128</span>~<span style="color: #800080;">127</span><span style="color: #000000;">
signed </span><span style="color: #0000ff;">char</span>                             1字节(8位)        取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">7</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">7</span>-<span style="color: #800080;">1</span>）即-<span style="color: #800080;">128</span>~<span style="color: #800080;">127</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
unsigned </span><span style="color: #0000ff;">char</span>                           1字节(8位)         取值范围   <span style="color: #800080;">0</span>~（<span style="color: #800080;">2</span>^<span style="color: #800080;">8</span>-<span style="color: #800080;">1</span>）即0~<span style="color: #800080;">255</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span>（或short）                     2字节(16位)       取值范围（-<span style="color: #800080;">2</span>^<span style="color: #800080;">15</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">15</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">32768</span>~<span style="color: #800080;">32767</span><span style="color: #000000;">
signed </span><span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span>（或signed <span style="color: #0000ff;">short</span>）       2字节(16位)       取值范围（-<span style="color: #800080;">2</span>^<span style="color: #800080;">15</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">15</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">32768</span>~<span style="color: #800080;">32767</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
unsigned </span><span style="color: #0000ff;">short</span> <span style="color: #0000ff;">int</span>（或unsigned <span style="color: #0000ff;">short</span>）   2字节(16位)       取值范围 <span style="color: #800080;">0</span>~（<span style="color: #800080;">2</span>^<span style="color: #800080;">16</span>-<span style="color: #800080;">1</span>） 即0~<span style="color: #800080;">65535</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">int</span>                                     4字节(32位)       取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">2147483648</span>~<span style="color: #800080;">2147483647</span><span style="color: #000000;">
signed </span><span style="color: #0000ff;">int</span>（或signed）                   4字节(32位)       取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">2147483648</span>~<span style="color: #800080;">2147483647</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
unsigned </span><span style="color: #0000ff;">int</span>（或unsigned）               4字节(32位)       取值范围 <span style="color: #800080;">0</span>~（<span style="color: #800080;">2</span>^<span style="color: #800080;">32</span>-<span style="color: #800080;">1</span>） 即0~<span style="color: #800080;">4294967295</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span>（或long）                       4字节(32位)      取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">2147483648</span>~<span style="color: #800080;">2147483647</span><span style="color: #000000;">
signed </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span>（或signed <span style="color: #0000ff;">long</span>）         4字节(32位)      取值范围 （-<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>）~（<span style="color: #800080;">2</span>^<span style="color: #800080;">31</span>-<span style="color: #800080;">1</span>） 即-<span style="color: #800080;">2147483648</span>~<span style="color: #800080;">2147483647</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
unsigned </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">int</span>（或unsigned <span style="color: #0000ff;">long</span>）     4字节(32位)      取值范围 <span style="color: #800080;">0</span>~（<span style="color: #800080;">2</span>^<span style="color: #800080;">32</span>-<span style="color: #800080;">1</span>） 即0~<span style="color: #800080;">4294967295</span><span style="color: #000000;">
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">float</span>                                   4字节(32位)      取值范围 （-<span style="color: #800080;">3</span>.4x10^<span style="color: #800080;">38</span>）~（<span style="color: #800080;">3</span>.4x10^<span style="color: #800080;">38</span><span style="color: #000000;">） ，约6位有效数字
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</span><span style="color: #0000ff;">double</span>                                  8字节(64位)      取值范围  （-<span style="color: #800080;">1</span>.7x10^<span style="color: #800080;">308</span>）~（<span style="color: #800080;">1</span>.7x10^<span style="color: #800080;">308</span><span style="color: #000000;">） ，约15位有效数字
</span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">double</span>                             8字节(64位)      取值范围  （-<span style="color: #800080;">1</span>.7x10^<span style="color: #800080;">308</span>）~（<span style="color: #800080;">1</span>.7x10^<span style="color: #800080;">308</span><span style="color: #000000;">） ，约15位有效数字
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br /><br />char，signed char 是等价的<br />short，short int，signed short，signed short int 都是等价的<br />int，signed，signed int，long，long int，signed long，signed long int 都是等价的<br />double，long double 是等价的<br /><br /></span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #800080;">3</span><span style="color: #000000;">.1函数地址
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
<span style="color: #000000;">下面三种均可表示函数地址
simple
</span>&amp;<span style="color: #000000;">simple
</span>*&amp;<span style="color: #000000;">simple


</span><span style="color: #800080;">3</span>.2函数调用    <span style="color: #008000;">//</span><span style="color: #008000;">注意，调用时是实参</span>
<span style="color: #000000;">调用方式：函数地址(实际参数表)
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
<span style="color: #000000;">simple(a,b)
(</span>&amp;simple)(a,b)    <span style="color: #008000;">//</span><span style="color: #008000;">因为小括号的运算符优先级最高，所以必须是(&amp;simple)</span>
(*&amp;simple)(a,b) <span style="color: #008000;">//</span><span style="color: #008000;">因为小括号的运算符优先级最高，所以必须是(*&amp;simple)</span>


<span style="color: #800080;">3</span><span style="color: #000000;">.3函数类型
定义形式： typedef 类型 函数类型名称(形式参数表);  </span><span style="color: #008000;">//</span><span style="color: #008000;">注意，typedef最后有分号
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
&mdash;&mdash; typedef <span style="color: #0000ff;">double</span> S(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">);  
上面的定义是一种自定义类型，它将double (</span><span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">)这种函数类型表达为S类型
既然是类型就可以定义相应的</span><span style="color: #800000;">"</span><span style="color: #800000;">变量</span><span style="color: #800000;">"</span><span style="color: #000000;">,typedef定义函数类型后，就可以按定义变量的形式写同类型函数的原型声明
&mdash;&mdash; S a,b;  </span><span style="color: #008000;">//</span><span style="color: #008000;">类比于int a,b;</span>
上面的函数类型定义相当于 <span style="color: #0000ff;">double</span> a(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>);和double b(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">);这两个函数声明


</span><span style="color: #800080;">3</span><span style="color: #000000;">.4函数指针
①（定义一个指针变量）
定义方式1：类型 (</span>*<span style="color: #000000;">指针变量名)(形式参数表); 
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
&mdash;&mdash; <span style="color: #0000ff;">double</span> (*pa)(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>); <span style="color: #008000;">//</span><span style="color: #008000;">pa就是函数指针</span>
&mdash;&mdash; <span style="color: #0000ff;">double</span> (*pb)(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>); <span style="color: #008000;">//</span><span style="color: #008000;">pb就是函数指针</span>
<span style="color: #000000;">并且可以与普通的double变量同时定义
&mdash;&mdash; </span><span style="color: #0000ff;">double</span> a, b, (*pa)(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>), (*pb)(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span><span style="color: #000000;">);

定义方式2：函数类型 </span>*<span style="color: #000000;">指针变量名;
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
<span style="color: #000000;">在上面typedef定义该函数类型为S类型后，可以直接按定义指针的形式定义函数指针
&mdash;&mdash;S </span>*pa,*pb;  <span style="color: #008000;">//</span><span style="color: #008000;">类比于int *pa,*pb;
</span><span style="color: #008000;">//</span><span style="color: #008000;">pa,pb就是函数指针</span>
<span style="color: #000000;">

②（定义一种指针类型）
还可以像定义函数类型一样，定义该函数类型的指针类型
定义形式1： typedef 类型 (指针类型名)(形式参数表); </span><span style="color: #008000;">//</span><span style="color: #008000;">注意，typedef最后有分号
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
&mdash;&mdash; typedef <span style="color: #0000ff;">double</span> (*Type)(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">Type就是指针类型</span>
&mdash;&mdash; Type pa,pb; <span style="color: #008000;">//</span><span style="color: #008000;">类比于typedef
</span><span style="color: #008000;">//</span><span style="color: #008000;">pa,pb就是函数指针</span>
<span style="color: #000000;">
定义形式2： typedef 函数类型 </span>*<span style="color: #000000;">指针类型名
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
<span style="color: #000000;">在上面typedef定义该函数类型为S类型后，可以定义该函数的指针类型
&mdash;&mdash; typedef S </span>*Type;  <span style="color: #008000;">//</span><span style="color: #008000;">Type就是指针类型</span>
&mdash;&mdash; Type pa,pb; <span style="color: #008000;">//</span><span style="color: #008000;">类比于typedef int* INTP;   INTP pa,pb;
</span><span style="color: #008000;">//</span><span style="color: #008000;">pa,pb就是函数指针</span>


<span style="color: #800080;">3</span>.5用函数指针调用函数    <span style="color: #008000;">//</span><span style="color: #008000;">注意，调用时是实参</span>
调用方式：(*<span style="color: #000000;">指针变量名)(实际参数表)
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
pa=a; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针pa获得函数地址a</span>
pb=b; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针pb获得函数地址b</span>
当然pa=b; pa=<span style="color: #000000;">b;都是可以的，因为它们都是是相同函数类型下的函数与函数指针
类比于 </span><span style="color: #0000ff;">int</span> a,b;  <span style="color: #0000ff;">int</span> *pa,*<span style="color: #000000;">pb;
pa</span>=a;  pa=<span style="color: #000000;">b;  它们都是int类型下的变量与指针

</span><span style="color: #0000ff;">double</span><span style="color: #000000;"> t,k;
t</span>=a(<span style="color: #800080;">1</span>,<span style="color: #800080;">4</span>);  t=pa(<span style="color: #800080;">1</span>,<span style="color: #800080;">4</span>);   t=(*pa)(<span style="color: #800080;">1</span>,<span style="color: #800080;">4</span>);是等价的  <span style="color: #008000;">//</span><span style="color: #008000;">但是t=(&amp;pa)是错误的，&amp;pa获得的是指针自身的地址，而不是函数a的地址</span>
k=b(<span style="color: #800080;">2</span>,<span style="color: #800080;">9</span>);  k=pb(<span style="color: #800080;">2</span>,<span style="color: #800080;">9</span>);   k=(*pb)(<span style="color: #800080;">2</span>,<span style="color: #800080;">9</span>)是等价的  <span style="color: #008000;">//</span><span style="color: #008000;">但是k=(&amp;pb)是错误的，&amp;pb获得的是指针自身的地址，而不是函数b的地址</span>

<span style="color: #800080;">3</span><span style="color: #000000;">.6函数指针数组
定义方式1：类型 (</span>*<span style="color: #000000;">指针数组名[ 整型表达式])(形式参数表); 
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
&mdash;&mdash;<span style="color: #0000ff;">double</span> (*pfun[<span style="color: #800080;">5</span>])(<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">定义double(int,int)函数类型下的 函数指针数组，每个数组元素都是一个函数指针</span>
pfun[<span style="color: #800080;">0</span>]=a; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[0]获取函数地址a</span>
pfun[<span style="color: #800080;">1</span>]=b; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[1]获取函数地址b</span>
<span style="color: #000000;">
定义方式2：函数类型 </span>*<span style="color: #000000;">指针数组名;
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
<span style="color: #000000;">在上面typedef定义该函数类型为S类型后，可以直接按定义指针的形式定义函数指针
&mdash;&mdash;S </span>*pfun[<span style="color: #800080;">5</span><span style="color: #000000;">];
pfun[</span><span style="color: #800080;">0</span>]=a; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[0]获取函数地址a</span>
pfun[<span style="color: #800080;">1</span>]=b; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[1]获取函数地址b</span>


<span style="color: #800080;">3</span><span style="color: #000000;">.7用函数指针数组调用函数
调用方式：(</span>*<span style="color: #000000;">指针数组元素)(实际参数表)
</span><span style="color: #008000;">//</span><span style="color: #008000;">以double simple(int,int);为例</span>
pfun[<span style="color: #800080;">0</span>]=a; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[0]获取函数地址a</span>
pfun[<span style="color: #800080;">1</span>]=b; <span style="color: #008000;">//</span><span style="color: #008000;">函数指针数组元素pfun[1]获取函数地址b</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> x,y;
</span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=<span style="color: #800080;">0</span>;i&lt;=<span style="color: #800080;">1</span>;i++<span style="color: #000000;">)
{
    cout</span>&lt;&lt;(*pfun[i])(x,y)&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">相当于调用a(x,y)和b(x,y)</span>
<span style="color: #000000;">}


</span><span style="color: #800080;">3</span><span style="color: #000000;">.8指针数组指向多个等长数组(二维数组)
</span><span style="color: #008000;">//</span><span style="color: #008000;">相当于4行6列的二维数组</span>
<span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">4</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">行向量</span>
<span style="color: #0000ff;">int</span> a[<span style="color: #800080;">6</span>],b[<span style="color: #800080;">6</span>],c[<span style="color: #800080;">6</span>],d[<span style="color: #800080;">6</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">列向量</span>
p[<span style="color: #800080;">0</span>]=<span style="color: #000000;">a;
p[</span><span style="color: #800080;">1</span>]=<span style="color: #000000;">b;
p[</span><span style="color: #800080;">2</span>]=<span style="color: #000000;">c;
p[</span><span style="color: #800080;">3</span>]=<span style="color: #000000;">d;

访问方式：二维:p[i][j]、</span>*(p[i]+j)、*(*(p+i)+j)  <span style="color: #008000;">//</span><span style="color: #008000;"> i :0~3，j :0~5</span>
        行向量:p[i]、*(p+i) <span style="color: #008000;">//</span><span style="color: #008000;"> i :0~3</span>
        一维:p[t] <span style="color: #008000;">//</span><span style="color: #008000;"> t :0~25</span>

<span style="color: #800080;">3</span><span style="color: #000000;">.9指针数组指向多个不等长的数组
</span><span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">4</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">12</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> b[<span style="color: #800080;">5</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> c[<span style="color: #800080;">24</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> d[<span style="color: #800080;">7</span><span style="color: #000000;">];
p[</span><span style="color: #800080;">0</span>]=<span style="color: #000000;">a;
p[</span><span style="color: #800080;">1</span>]=<span style="color: #000000;">b;
p[</span><span style="color: #800080;">2</span>]=<span style="color: #000000;">c;
p[</span><span style="color: #800080;">3</span>]=<span style="color: #000000;">d;


</span><span style="color: #800080;">3</span><span style="color: #000000;">.10指针数组
类型</span>*<span style="color: #000000;"> 数组名[整型表达式];
</span><span style="color: #0000ff;">int</span> *p[<span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">定义指针数组a[0]到a[9]，每个数组元素都是int * 指针，即10个指针</span>

<span style="color: #800080;">3</span><span style="color: #000000;">.10数组指针
类型 (</span>*<span style="color: #000000;">数组名)[整型表达式];
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">10</span><span style="color: #000000;">];
</span><span style="color: #0000ff;">int</span> (*p)[<span style="color: #800080;">10</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">定义数组指针*p，指针p指向 类型为int [10]的数组，即1个指针</span>
p=<span style="color: #000000;">a; 
cout</span>&lt;&lt;p[<span style="color: #800080;">4</span>]&lt;&lt;<span style="color: #000000;">endl;

</span><span style="color: #800080;">3.10</span><span style="color: #000000;">.1数组指针数组
</span><span style="color: #0000ff;">int</span> a[<span style="color: #800080;">7</span>][<span style="color: #800080;">8</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">7x8的二维数组</span>
<span style="color: #0000ff;">int</span> (*p[<span style="color: #800080;">5</span>])[<span style="color: #800080;">8</span>];  <span style="color: #008000;">//</span><span style="color: #008000;">定义数组指针数组p[0]到p[4]，每个数组元素都是指向类型为int [8]数组的指针，共5个数组指针</span>
<span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;<span style="color: #800080;">5</span>;i++) <span style="color: #008000;">//</span><span style="color: #008000;">仅访问前五行</span>
    p=a[i]; <span style="color: #008000;">//</span><span style="color: #008000;">数组指针获取行向量的地址</span>
<span style="color: #000000;">
cout</span>&lt;&lt;p[<span style="color: #800080;">3</span>][<span style="color: #800080;">6</span>]&lt;&lt;<span style="color: #000000;">endl;

</span><span style="color: #800080;">4</span><span style="color: #000000;">.1字符串处理函数
</span><span style="color: #800080;">1</span>. 字符串长度 strlen （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> length）
函数原型：</span><span style="color: #0000ff;">int</span> strlen( <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #0000ff;">string</span><span style="color: #000000;"> );
strlen(s); </span><span style="color: #008000;">//</span><span style="color: #008000;">统计有效字符长度，以\0结束，不包括\0</span>
<span style="color: #000000;">&mdash;&mdash;字符数组的strlen与sizeof比较
</span><span style="color: #0000ff;">char</span> s[<span style="color: #800080;">8</span>]=<span style="color: #800000;">"</span><span style="color: #800000;">abcde</span><span style="color: #800000;">"</span><span style="color: #000000;">;
cout</span>&lt;&lt;strlen(s);   <span style="color: #008000;">//</span><span style="color: #008000;">输出5，字符数组有效字符长度为5</span>
cout&lt;&lt;<span style="color: #0000ff;">sizeof</span>(s);  <span style="color: #008000;">//</span><span style="color: #008000;">输出8，字符数组字节数为8</span>


<span style="color: #800080;">2.1</span> 字符串复制 strcpy （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> copy）
函数原型：</span><span style="color: #0000ff;">char</span> * strcpy(<span style="color: #0000ff;">char</span> *s1, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">s2); 
strcpy(s1,s2); </span><span style="color: #008000;">//</span><span style="color: #008000;">把s2复制到s1中，类似于变量s1=s2;</span>

<span style="color: #800080;">2.2</span> 字符串复制 strcpy_s （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> copy safe）
函数原型：</span><span style="color: #0000ff;">char</span> * strcpy_s(<span style="color: #0000ff;">char</span> *s1, <span style="color: #0000ff;">int</span> s1_n, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *s2); <span style="color: #008000;">//</span><span style="color: #008000;">s1_n是字符数组s1的长度，保证复制时不会超出n个，增强安全性</span>
<span style="color: #0000ff;">char</span> s2=<span style="color: #800000;">"</span><span style="color: #800000;">zyxw</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span> len=<span style="color: #000000;">strlen(s2);
</span><span style="color: #0000ff;">char</span> *s1=<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span>[len+<span style="color: #800080;">1</span>]; <span style="color: #008000;">//</span><span style="color: #008000;">len+1是为了存储字符串结束符\0</span>
strcpy_s(s1,len+<span style="color: #800080;">1</span><span style="color: #000000;">,s); 
cout</span>&lt;&lt;<span style="color: #000000;">s1;

</span><span style="color: #800080;">2.3</span> 字符串前n个复制 strncpy （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> n copy）
函数原型：</span><span style="color: #0000ff;">char</span> * strncpy(<span style="color: #0000ff;">char</span> *s1, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *s2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> s2_n); 
strncpy(s1,s2,n); </span><span style="color: #008000;">//</span><span style="color: #008000;">将s2的前n个字符复制到s1中</span>



<span style="color: #800080;">3.1</span> 字符串连接 strcat （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> catenate）
函数原型：</span><span style="color: #0000ff;">char</span> * strcat(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">s2);
strcat(s1,s2) </span><span style="color: #008000;">//</span><span style="color: #008000;">在s1后面连接上s2，并且去掉s1最后的\0</span>

<span style="color: #800080;">3.2</span> 字符串连接 strcat_s （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> catenate safe）
函数原型：</span><span style="color: #0000ff;">char</span> * strcat(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">int</span> s1_n,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">s2);
strcat(s1,</span><span style="color: #0000ff;">sizeof</span>(s1),s2); <span style="color: #008000;">//</span><span style="color: #008000;">规定s1和s2连接后的长度为sizeof(s1)，防止溢出</span>

<span style="color: #800080;">3.3</span> 字符串连接 strncat （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> n catenate）
函数原型：</span><span style="color: #0000ff;">char</span> * strncat(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *s2,<span style="color: #0000ff;">int</span><span style="color: #000000;"> s2_n);
strncat(s1,s2,n); </span><span style="color: #008000;">//</span><span style="color: #008000;">将s2的前n个字符连接到s1后面</span>

<span style="color: #800080;">3.4</span> 字符串连接 strncat_s （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> n catenate safe）
函数原型：</span><span style="color: #0000ff;">char</span> * strncat(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">int</span> s1_n,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *s2,<span style="color: #0000ff;">int</span><span style="color: #000000;"> s2_n);
strncat_s(s1,</span><span style="color: #0000ff;">sizeof</span>(s1),s2,n); <span style="color: #008000;">//</span><span style="color: #008000;">将s2的前n个字符连接到s1后面，并且连接后s1的长度为sizeof(s1)，防止溢出</span>



<span style="color: #800080;">4.1</span> 字符串比较 strcmp （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> compare）
函数原型：</span><span style="color: #0000ff;">int</span> strcmp(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">s2);
strcmp(s1,s2); </span><span style="color: #008000;">//</span><span style="color: #008000;">逐个比较字符串中字符的ASCII码，如果字符串相等则返回0，如果s1的字符不等于s2的字符则返回ASCII码的差值(s1&gt;s2为正，s1&lt;s2位负)</span>

<span style="color: #800080;">4.2</span> 字符串比较 strncmp （=<span style="color: #0000ff;">string</span><span style="color: #000000;"> n compare）
函数原型：</span><span style="color: #0000ff;">int</span> strncmp(<span style="color: #0000ff;">char</span> *s1,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *s2,<span style="color: #0000ff;">int</span><span style="color: #000000;"> n); 
strncmp(s1,s2,n); </span><span style="color: #008000;">//</span><span style="color: #008000;">仅比较s1和s2的前n个字符</span>
<span style="color: #000000;">



构造函数和析构函数都没有返回值

</span><span style="color: #800080;">6</span><span style="color: #000000;">.1构造函数
</span><span style="color: #800080;">1</span><span style="color: #000000;">. 第一种：类内声明，类外定义
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span>:   <span style="color: #008000;">//</span><span style="color: #008000;">构造函数必须是公有的，因为对象在类外定义，构造对象时调用构造函数，如果是私有则无法在类外调用</span>
    类名(参数表); <span style="color: #008000;">//</span><span style="color: #008000;">构造函数的原型声明</span>
<span style="color: #000000;">};

类名::类名(参数表) </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数的类外定义</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">2</span><span style="color: #000000;">. 第二种：类内直接定义
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span>:   <span style="color: #008000;">//</span><span style="color: #008000;">构造函数必须是公有的，因为对象在类外定义，在对象构造时调用构造函数，如果是私有则无法在类外调用</span>
    类名(参数表) <span style="color: #008000;">//</span><span style="color: #008000;">构造函数的类内直接定义</span>
<span style="color: #000000;">    {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">    }
};


</span><span style="color: #800080;">6</span><span style="color: #000000;">.2析构函数
</span><span style="color: #800080;">1</span><span style="color: #000000;">. 第一种：类内声明，类外定义
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span>:  <span style="color: #008000;">//</span><span style="color: #008000;">析构函数必须是公有的，因为对象在类外定义，在对象销毁时调用析构函数，如果是私有则无法在类外调用</span>
    ~类名(); <span style="color: #008000;">//</span><span style="color: #008000;">析构函数一定没有参数，析构函数的原型声明</span>
<span style="color: #000000;">};

类名::</span>~类名() <span style="color: #008000;">//</span><span style="color: #008000;">析构函数一定没有参数，析构函数的类外定义</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">析构函数具体定义</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">2</span><span style="color: #000000;">. 第二种：类内直接定义
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span>~类名() <span style="color: #008000;">//</span><span style="color: #008000;">析构函数一定没有参数，析构函数的类内直接定义</span>
<span style="color: #000000;">    {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">析构函数具体定义</span>
<span style="color: #000000;">    }
};


构造函数有参数可以重载，析构函数没有参数不能重载

</span><span style="color: #800080;">6</span><span style="color: #000000;">.3重载构造函数
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    类名(); </span><span style="color: #008000;">//</span><span style="color: #008000;">无参构造函数的原型声明</span>
    类名(类型1 参数1); <span style="color: #008000;">//</span><span style="color: #008000;">带1个参数的构造函数的原型声明</span>
    类名(类型1 参数1,类型2 参数2); <span style="color: #008000;">//</span><span style="color: #008000;">带2个参数的构造函数的原型声明</span>
    
    <span style="color: #808080;">//////</span><span style="color: #008000;">//以此类推</span>
<span style="color: #000000;">    
};

类名::类名() </span><span style="color: #008000;">//</span><span style="color: #008000;">无参构造函数的类外定义</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">}

类名::类名(类型1 参数1) </span><span style="color: #008000;">//</span><span style="color: #008000;">带1个参数的构造函数的类外定义</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">}
类名::类名(类型1 参数1,类型2 参数2) </span><span style="color: #008000;">//</span><span style="color: #008000;">带2个参数的构造函数的类外定义</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">6.3</span><span style="color: #000000;">.1有默认参数的构造函数
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    类名(类型1 参数1</span>=<span style="color: #800080;">0</span>,类型2 参数2=<span style="color: #800080;">0</span>); <span style="color: #008000;">//</span><span style="color: #008000;">带2个默认参数的构造函数的原型声明</span>
<span style="color: #000000;">}

类名::类名(类型1 参数1,类型2 参数2) </span><span style="color: #008000;">//</span><span style="color: #008000;">带2个参数的构造函数的类外定义（注意，默认参数只在函数第一次出现时写出，一般在原型声明中写出）</span>


<span style="color: #800080;">6</span><span style="color: #000000;">.4复制构造函数 （是一种特殊的重载构造函数，其参数包含一个自身类类型的常引用参数）
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    类名(){}  </span><span style="color: #008000;">//</span><span style="color: #008000;">类内直接定义的无参且无函数体的构造函数</span>
    类名(<span style="color: #0000ff;">const</span> 类名&amp; 引用名); <span style="color: #008000;">//</span><span style="color: #008000;">复制构造函数的原型声明</span>
<span style="color: #000000;">};

类名::类名(</span><span style="color: #0000ff;">const</span> 类名&amp; 引用名) <span style="color: #008000;">//</span><span style="color: #008000;">复制构造函数的类外定义</span>
<span style="color: #000000;">{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">复制构造函数具体定义</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">6</span><span style="color: #000000;">.5常成员变量
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">const</span> 类型1 常量1; <span style="color: #008000;">//</span><span style="color: #008000;">变量1是类的常成员变量</span>
    类型2 变量2; <span style="color: #008000;">//</span><span style="color: #008000;">变量2是类的普通成员变量</span>
<span style="color: #000000;">    
    类名(类型1 变量3,类型2 变量4):常量1(变量3),变量2(变量4)  </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数初始化式，同类型变量给相应变量初始化，常量只能靠初始化式赋值</span>
<span style="color: #000000;">    {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">构造函数具体定义</span>
<span style="color: #000000;">    }
};

</span><span style="color: #800080;">6</span><span style="color: #000000;">.6常成员函数 （一类特殊的成员函数，其this指针被约束为指向常量的常指针）
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    返回值类型 函数名(参数表)</span><span style="color: #0000ff;">const</span>; <span style="color: #008000;">//</span><span style="color: #008000;">常成员函数的原型声明</span>
<span style="color: #000000;">};
类名::返回值类型 函数名(参数表)</span><span style="color: #0000ff;">const</span><span style="color: #000000;">
{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">常成员函数具体定义</span>
<span style="color: #000000;">}

调用方式:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
类名 对象1;
对象1.常成员函数名(参数表); </span><span style="color: #008000;">//</span><span style="color: #008000;">调用时不加const</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">6</span><span style="color: #000000;">.7常对象
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">类的具体定义</span>
<span style="color: #000000;">};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">const</span> 类名 T; <span style="color: #008000;">//</span><span style="color: #008000;">常对象T中所有的成员变量都被约束为const只读</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">6</span><span style="color: #000000;">.8静态成员变量
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    </span><span style="color: #0000ff;">static</span> 类型1 变量1;  <span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量，类内声明</span>
    <span style="color: #0000ff;">static</span><span style="color: #000000;"> 类型1 变量2;
};

</span><span style="color: #0000ff;">int</span> 类名::变量1=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量，类外定义和初始化</span>
<span style="color: #0000ff;">int</span> 类名::变量2=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">同类型静态成员变量可以同时定义</span>
<span style="color: #0000ff;">int</span> 类名::变量1=<span style="color: #800080;">0</span>,类名::变量2=<span style="color: #800080;">1</span><span style="color: #000000;">;

</span><span style="color: #800080;">6</span>.9静态成员函数 <span style="color: #008000;">//</span><span style="color: #008000;">没有this指针</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名 
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">static</span> 返回值类型 函数名(参数表); <span style="color: #008000;">//</span><span style="color: #008000;">静态成员函数的原型声明</span>
<span style="color: #000000;">};

类名::返回值类型 函数名(参数表) </span><span style="color: #008000;">//</span><span style="color: #008000;">静态成员函数的类外定义，不加static</span>
<span style="color: #000000;">{
        </span><span style="color: #008000;">//</span><span style="color: #008000;">静态成员函数的具体定义</span>
<span style="color: #000000;">}

调用方式:
</span><span style="color: #800080;">1</span><span style="color: #000000;">.定义对象调用
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    类名 对象1;
    对象1.静态成员函数名(参数表);
}

</span><span style="color: #800080;">2</span><span style="color: #000000;">.类作用域调用 （因为静态成员是不依赖于对象的，仅对应类）
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    类名::静态成员函数名(参数表);
}

</span>*<span style="color: #000000;">静态成员函数只能访问静态成员变量。
</span>*<span style="color: #000000;">但是静态成员变量可以被普通成员函数和静态成员函数访问。


</span><span style="color: #800080;">6</span>.10友元函数 <span style="color: #008000;">//</span><span style="color: #008000;">没有this指针</span>
<span style="color: #000000;">友元函数不属于类，它是类外的函数
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    friend 返回值类型1 函数名(类名</span>&amp;,......); <span style="color: #008000;">//</span><span style="color: #008000;">原型声明，友元函数通过类类型的   引用参数  来访问类中成员</span>
    friend 返回值类型2 函数名(类名*,........); <span style="color: #008000;">//</span><span style="color: #008000;">原型声明，友元函数通过类类型的   指针参数  来访问类中成员</span>
<span style="color: #000000;">};

返回值类型 函数名(类名</span>&amp;,.....) <span style="color: #008000;">//</span><span style="color: #008000;">友元函数类外定义时不加friend关键字</span>
<span style="color: #000000;">{

}
返回值类型2 函数名(类名</span>*,........); <span style="color: #008000;">//</span><span style="color: #008000;">友元函数类外定义时不加friend关键字</span>
<span style="color: #000000;">{

}


</span><span style="color: #800080;">6</span><span style="color: #000000;">.11友元类
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名1
{
    friend </span><span style="color: #0000ff;">class</span> 类名2;  <span style="color: #008000;">//</span><span style="color: #008000;">将类2声明为类1的友元</span>
<span style="color: #000000;">};

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名2
{
    类名1 对象1; </span><span style="color: #008000;">//</span><span style="color: #008000;">以类包含方式访问类1对象</span>
<span style="color: #000000;">    
    返回值类型 函数名(类1</span>&amp;,.....); <span style="color: #008000;">//</span><span style="color: #008000;">以引用参数方式访问类1对象</span>
<span style="color: #000000;">};








不能重载的运算符：
.    .</span>*    ::    ?:    <span style="color: #0000ff;">sizeof</span><span style="color: #000000;">

不能用友元函数重载的运算符：
</span>=    ()    []    -&gt;<span style="color: #000000;">



成员函数，友元函数，普通函数均可重载运算符，但是普通函数需要操纵公有成员实现重载，增加程序开销，所以通常用成员函数和友元函数重载运算符

</span><span style="color: #800080;">7</span><span style="color: #000000;">.1通过成员函数重载运算符   【左操作数是对象时，用成员函数重载】
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    返回值类型 </span><span style="color: #0000ff;">operator</span> op();  <span style="color: #008000;">//</span><span style="color: #008000;">函数声明，一元运算符重载</span>
    返回值类型 <span style="color: #0000ff;">operator</span> op(类名 对象名);  <span style="color: #008000;">//</span><span style="color: #008000;">函数声明，二元运算符重载</span>
<span style="color: #000000;">};

返回值类型  类名::</span><span style="color: #0000ff;">operator</span> op() <span style="color: #008000;">//</span><span style="color: #008000;">函数定义，一元运算符重载</span>
<span style="color: #000000;">{

}
返回值类型 类名::</span><span style="color: #0000ff;">operator</span> op(类名 对象名) <span style="color: #008000;">//</span><span style="color: #008000;">函数定义，二元运算符重载</span>
<span style="color: #000000;">{

}

调用方式
</span><span style="color: #800080;">1</span><span style="color: #000000;">.一元运算符
类名 对象1; 
对象1 op;</span><span style="color: #008000;">//</span><span style="color: #008000;">例如a++;</span>
op 对象1;  <span style="color: #008000;">//</span><span style="color: #008000;">例如++a;</span>
<span style="color: #000000;">
对象1.</span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> op();


</span><span style="color: #800080;">2</span><span style="color: #000000;">.二元运算符
类名 对象1,对象2;
对象1 op 对象2;  </span><span style="color: #008000;">//</span><span style="color: #008000;">例如a+b;</span>
<span style="color: #000000;">
对象1.</span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> op(对象2);


</span><span style="color: #800080;">7</span><span style="color: #000000;">.2通过友元函数重载运算符  【左右操作数类型不同时，用友元函数重载】
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    friend 返回值类型 </span><span style="color: #0000ff;">operator</span> op(类名 对象名); <span style="color: #008000;">//</span><span style="color: #008000;">函数声明，一元运算符重载</span>
    friend 返回值类型 <span style="color: #0000ff;">operator</span> op(类名 对象名1,类名 对象名2);  <span style="color: #008000;">//</span><span style="color: #008000;">函数声明，二元运算符重载</span>
<span style="color: #000000;">};

返回值类型 </span><span style="color: #0000ff;">operator</span> op(类名 对象名)  <span style="color: #008000;">//</span><span style="color: #008000;">函数定义，一元运算符重载</span>
<span style="color: #000000;">{

}
返回值类型 </span><span style="color: #0000ff;">operator</span> op(类名 对象名1,类名 对象名2) <span style="color: #008000;">//</span><span style="color: #008000;">函数定义，二元运算符重载</span>
<span style="color: #000000;">{

}

调用方式
</span><span style="color: #800080;">1</span><span style="color: #000000;">.一元运算符
类名 对象1;
</span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> op(对象1);

</span><span style="color: #800080;">2</span><span style="color: #000000;">.二元运算符
类名 对象1,对象2;
</span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> op(对象1,对象2);



</span><span style="color: #800080;">7</span>.3重载 前置++  <span style="color: #008000;">//</span><span style="color: #008000;">一元运算符重载</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    类名</span>&amp; <span style="color: #0000ff;">operator</span>++<span style="color: #000000;">();
    friend 类名</span>&amp; <span style="color: #0000ff;">operator</span>++(类名&amp;<span style="color: #000000;">);
};

类名</span>&amp;  类名::<span style="color: #0000ff;">operator</span>++<span style="color: #000000;">()
{

}

类名</span>&amp;  <span style="color: #0000ff;">operator</span>++(类名&amp;<span style="color: #000000;"> 对象名)
{

}

调用方式：
类名 对象1;
</span>++<span style="color: #000000;">对象1;

</span><span style="color: #800080;">7</span>.4重载 后置++  <span style="color: #008000;">//</span><span style="color: #008000;">二元运算符重载</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    类名</span>&amp; <span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">右操作数默认为0</span>
    friend 类名&amp; <span style="color: #0000ff;">operator</span>++(类名&amp;,<span style="color: #0000ff;">int</span>);  <span style="color: #008000;">//</span><span style="color: #008000;">右操作数默认为0</span>
<span style="color: #000000;">};

类名</span>&amp; 类名::<span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x)
{

}

类名</span>&amp; <span style="color: #0000ff;">operator</span>++(类名&amp; 对象名,<span style="color: #0000ff;">int</span><span style="color: #000000;"> x)
{

}
调用方式：
类名 对象1;
对象1</span>++<span style="color: #000000;">;


</span><span style="color: #800080;">7</span>.5重载 赋值运算符(=) <span style="color: #008000;">//</span><span style="color: #008000;">只能成员函数重载，且不能被继承</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名 
{
    类名</span>&amp; <span style="color: #0000ff;">operator</span>=<span style="color: #000000;">(类名);
};

类名</span>&amp; 类名::<span style="color: #0000ff;">operator</span>=<span style="color: #000000;">(类名)
{

}
调用方式：
类名 对象1,对象2,对象3;
对象3</span>=对象2=<span style="color: #000000;">对象1;


</span><span style="color: #800080;">7</span>.6重载 []运算符 <span style="color: #008000;">//</span><span style="color: #008000;">只能成员函数重载</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    类名</span>&amp; <span style="color: #0000ff;">operator</span>[](<span style="color: #0000ff;">int</span><span style="color: #000000;">);
    类名 </span><span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">int</span><span style="color: #000000;">);
};

类名</span>&amp; 类名::<span style="color: #0000ff;">operator</span>[](<span style="color: #0000ff;">int</span><span style="color: #000000;"> x)
{

}

类名 类名::</span><span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x)
{

}

调用方式：
类名 对象1;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x
对象1[x];
对象1(x);


</span><span style="color: #800080;">7</span>.7类类型转换 (非默认参数的构造函数)      【类/基本&mdash;&mdash;&gt;<span style="color: #000000;">类】
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    类名(类型1 变量1,......); </span><span style="color: #008000;">//</span><span style="color: #008000;">没有默认参数的构造函数</span>
<span style="color: #000000;">};

类名::类名(类型1 变量1,......)  </span><span style="color: #008000;">//</span><span style="color: #008000;">将 类型1&mdash;转换为&mdash;&gt;本类类型 </span>
<span style="color: #000000;">{
 
}

例:
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> complex
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    complex(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x;
}

complex::complex(</span><span style="color: #0000ff;">int</span> i)  <span style="color: #008000;">//</span><span style="color: #008000;">将 int&mdash;转换为&mdash;&gt;complex类型</span>
<span style="color: #000000;">{
    x</span>=<span style="color: #000000;">i;
}

显式调用:
complex d;
d</span>=complex(<span style="color: #800080;">6</span>); <span style="color: #008000;">//</span><span style="color: #008000;">显式调用构造函数，将常量6强制类型转换为complex类型</span>
<span style="color: #000000;">
隐式调用:
</span><span style="color: #800080;">1</span><span style="color: #000000;">.直接赋值
complex b;
b</span>=<span style="color: #800080;">5</span>;     <span style="color: #008000;">//</span><span style="color: #008000;">隐式调用构造函数，将常量5强制类型转换为complex类型</span>

<span style="color: #800080;">2</span><span style="color: #000000;">.函数传参
如果有函数声明 </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> fun(complex);
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    fun(</span><span style="color: #800080;">38</span>);      <span style="color: #008000;">//</span><span style="color: #008000;">隐式调用构造函数，将常量38强制类型转换为complex类型</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">3</span><span style="color: #000000;">.算术运算
complex h;
h</span>=h+<span style="color: #800080;">8</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">隐式调用构造函数，将常量8强制类型转换为complex类型，而且必须用友元函数重载运算符(+)</span>



<span style="color: #800080;">7</span>.8类型转换函数 【类&mdash;&mdash;&gt;基本/<span style="color: #000000;">类】<span style="color: #008000;"> //强制类型转换
</span></span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    </span><span style="color: #0000ff;">operator</span> 类型();  <span style="color: #008000;">//</span><span style="color: #008000;">成员函数，没有参数，没有返回值</span>
<span style="color: #000000;">};

类名::</span><span style="color: #0000ff;">operator</span><span style="color: #000000;"> 类型()
{
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> 类型值;
}<br />例：</span></pre>
<p><span style="color: #0000ff;">class</span> complex<br />{<br /><span style="color: #0000ff;">public</span>:<br />    　　<span style="color: #0000ff;">operator&nbsp;</span> <span style="color: #0000ff;">int</span>();<br />    　　complex(<span style="color: #0000ff;">int</span> i){x=i;}<br />    　　<span style="color: #0000ff;">int</span> x;<br />};</p>
<p>complex::<span style="color: #0000ff;">operator&nbsp;</span> <span style="color: #0000ff;">int</span>() <span style="color: #008000;">//类型转换函数</span><br />{<br />    　　return x;          <span style="color: #008000;">//x是类的成员变量，类型是int</span><br />}</p>
<p><span style="color: #0000ff;">int</span> main()</p>
<p>{</p>
<p>	　complex a(5);&nbsp;<br />    　<span style="color: #0000ff;">int</span> b=2+<span style="color: #0000ff;">int</span>(a); <span style="color: #008000;">//调用类型转换函数，将complex对象强制类型转换为int，完成加法2+5</span><br />	　cout&lt;&lt;b&lt;&lt;endl;&nbsp; <span style="color: #008000;">//输出7</span><em id="__mceDel"><br /></em>}</p>
<p>&nbsp;</p>
<pre><code><span style="color: #800080;">8</span><span style="color: #000000;">.1继承语句
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 派生类名:基类名表
{
    
};

基类名表格式: 访问控制   基类1,访问控制   基类2

例：
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
};
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B
{
};

</span><span style="color: #0000ff;">class</span> C: <span style="color: #0000ff;">public</span> A, <span style="color: #0000ff;">public</span> B  <span style="color: #008000;">//</span><span style="color: #008000;">基类名表用逗号隔开</span>
<span style="color: #000000;">{
};

</span><span style="color: #800080;">8</span><span style="color: #000000;">.2公有继承
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A

</span><span style="color: #0000ff;">public</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">public</span>
<span style="color: #0000ff;">protected</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">protected</span>
<span style="color: #0000ff;">private</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">private</span> <span style="color: #008000;">//</span><span style="color: #008000;">派生类中不可见，但有内存空间</span>


<span style="color: #800080;">8</span><span style="color: #000000;">.3保护继承
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">protected</span><span style="color: #000000;"> A

</span><span style="color: #0000ff;">public</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">protected</span>
<span style="color: #0000ff;">protected</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">protected</span>
<span style="color: #0000ff;">private</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">private</span> <span style="color: #008000;">//</span><span style="color: #008000;">派生类中不可见，但有内存空间</span>


<span style="color: #800080;">8</span><span style="color: #000000;">.4私有继承
</span><span style="color: #0000ff;">class</span> b:<span style="color: #0000ff;">private</span><span style="color: #000000;"> A

</span><span style="color: #0000ff;">public</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">private</span>
<span style="color: #0000ff;">protected</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">private</span>
<span style="color: #0000ff;">private</span> &mdash;&mdash;&gt;<span style="color: #0000ff;">private</span> <span style="color: #008000;">//</span><span style="color: #008000;">派生类中不可见，但有内存空间</span>
<span style="color: #000000;">
在派生类的成员函数中可以用    基类::基类成员函数(参数表);   方式来调用基类成员函数
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        A::print();    </span><span style="color: #008000;">//</span><span style="color: #008000;">调用基类A的成员函数print()</span>
<span style="color: #000000;">    }
}

在保护继承，私有继承中，可以使用访问声明让某些成员变量和成员函数恢复原本的访问控制（但是不可以提升或降低可访问性）
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">private</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    A::print;     </span><span style="color: #008000;">//</span><span style="color: #008000;">让基类基类A的成员函数print()恢复public访问。
                  </span><span style="color: #008000;">//</span><span style="color: #008000;">注意，此访问声明仅写函数名或变量名，没有返回值和参数，和上面的基类成员函数调用是不同的</span>
<span style="color: #000000;">};


</span><span style="color: #800080;">8.5</span><span style="color: #000000;">.1重名成员变量
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a;
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a;
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A m1;  </span><span style="color: #008000;">//</span><span style="color: #008000;">成员变量有A::a</span>
    B m2;  <span style="color: #008000;">//</span><span style="color: #008000;">成员变量有A::a和B::a</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">8.5</span><span style="color: #000000;">.2重名成员函数（派生类重载函数）
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">A</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">B</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A a;
    a.print(); </span><span style="color: #008000;">//</span><span style="color: #008000;">输出A</span>
<span style="color: #000000;">    B b;
    b.priint(); </span><span style="color: #008000;">//</span><span style="color: #008000;">输出B</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">8</span><span style="color: #000000;">.6派生类访问基类静态成员
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> i; <span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量，类内声明</span>
    <span style="color: #0000ff;">void</span><span style="color: #000000;"> add()
    {
        i</span>++<span style="color: #000000;">;
    }
};
</span><span style="color: #0000ff;">int</span> A::i=<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">静态成员变量，类外定义和初始化</span>

<span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">private</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f() 
    {
        add();  </span><span style="color: #008000;">//</span><span style="color: #008000;">i 自增</span>
        add();  <span style="color: #008000;">//</span><span style="color: #008000;">i 自增</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show()
    {
        cout</span>&lt;&lt;A::i&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    B b;
    b.f(); </span><span style="color: #008000;">//</span><span style="color: #008000;">i 自增两次</span>
    b.f(); <span style="color: #008000;">//</span><span style="color: #008000;">i 自增两次</span>
<span style="color: #000000;">    
    b.show(); </span><span style="color: #008000;">//</span><span style="color: #008000;">i 总共自增四次，i=5</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">8</span><span style="color: #000000;">.7基类初始化
构造函数名(参数表) : 基类1(变元表1),基类2(变元表2)

构造参数初始式不仅能初始化基类，还能初始化派生类的成员变量
构造函数先声明后定义的情况，只能在定义时使用参数初始式

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    A(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x);
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a;
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;">B(int x,int y):A(x),b(y){}  </span><span style="color: #008000;">//</span><span style="color: #008000;">用参数初始式简化定义的派生类构造函数</span>
    B(<span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span> y); <span style="color: #008000;">//</span><span style="color: #008000;">派生类构造函数声明</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> b
}; 
B::B(</span><span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y):A(x)
{
    b</span>=<span style="color: #000000;">y;
}

构造时：先基类，后派生类 
析构时：先派生，类后基类 
（早出晚归和迟到早退）

</span><span style="color: #800080;">8</span><span style="color: #000000;">.8类继承和类包含的比较
类继承
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
    A(</span><span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y)
    {
        a</span>=<span style="color: #000000;">x;
        b</span>=<span style="color: #000000;">y;
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a,b;
};
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
    B(</span><span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span> y,<span style="color: #0000ff;">int</span> z):A(x,y) <span style="color: #008000;">//</span><span style="color: #008000;">参数初始式是基类</span>
<span style="color: #000000;">    {
        c</span>=<span style="color: #000000;">z;
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> c;
};

类包含
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    A(</span><span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> y):a(x),b(y){} 
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a,b;
};

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    B(</span><span style="color: #0000ff;">int</span> x,<span style="color: #0000ff;">int</span> y,<span style="color: #0000ff;">int</span> z):pp(x,y),c(z){} <span style="color: #008000;">//</span><span style="color: #008000;">参数初始式是类类型的成员变量</span>
<span style="color: #000000;">    A pp;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> c
};


</span><span style="color: #800080;">8</span><span style="color: #000000;">.9多继承
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> 派生类 : 访问控制 基类1 , 访问控制 基类2 &hellip;&hellip;

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
};
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B
{
};

</span><span style="color: #0000ff;">class</span> C: <span style="color: #0000ff;">public</span> A, <span style="color: #0000ff;">public</span> B  <span style="color: #008000;">//</span><span style="color: #008000;">基类名表用逗号隔开</span>
<span style="color: #000000;">{
};

构造顺序是按照基类名表的顺序来，比如上面的例子，顺序是A&mdash;</span>&gt;B&mdash;&gt;<span style="color: #000000;">C。（注意，只与基类名表的继承顺序有关，与参数初始式无关）
析构顺序与构造顺序相反


</span><span style="color: #800080;">8</span><span style="color: #000000;">.10非虚继承
菱形继承的问题
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
};

</span><span style="color: #0000ff;">class</span> B1:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
};
</span><span style="color: #0000ff;">class</span> B2:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
};

</span><span style="color: #0000ff;">class</span> C:<span style="color: #0000ff;">public</span> B1,<span style="color: #0000ff;">public</span><span style="color: #000000;"> B2
{
};

此时C会同时生成间接基类A的两个副本，造成访问的二义性


</span><span style="color: #800080;">8</span><span style="color: #000000;">.11虚继承
虚继承为了解决菱形继承的问题
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
};

</span><span style="color: #0000ff;">class</span> B1:<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">public</span> A <span style="color: #008000;">//</span><span style="color: #008000;">虚继承</span>
<span style="color: #000000;">{
};
</span><span style="color: #0000ff;">class</span> B2:<span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">public</span> A <span style="color: #008000;">//</span><span style="color: #008000;">虚继承</span>
<span style="color: #000000;">{
};

</span><span style="color: #0000ff;">class</span> C:<span style="color: #0000ff;">public</span> B1,<span style="color: #0000ff;">public</span><span style="color: #000000;"> B2
{
};

此时C只会生成间接基类A的一个副本，没有二义性


创建派生类对象时，构造函数的执行顺序是
基类构造函数&mdash;&mdash;</span>&gt;对象成员构造函数(类包含时)&mdash;&mdash;&gt;<span style="color: #000000;">派生类本身的构造函数

派生类初始化时，初始化顺序与构造函数参数初始式无关
多继承初始化时仅调用间接基类自身的构造函数
派生类成员变量初始化式按类中的定义顺序初始化


</span><span style="color: #800080;">9</span>.1基类指针访问派生类对象 <span style="color: #008000;">//</span><span style="color: #008000;">正确</span>
<span style="color: #000000;">动态联编依赖 虚函数 和 基类指针 实现
基类指针仅能访问派生类中继承的基类成员
基类指针强制转换为派生类指针才能访问派生类本身的成员

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f1();
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a1;
};
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f2();
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> b2;
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*p; <span style="color: #008000;">//</span><span style="color: #008000;">基类指针</span>
    B b; <span style="color: #008000;">//</span><span style="color: #008000;">派生类对象</span>
<span style="color: #000000;">    
    p</span>=&amp;<span style="color: #000000;">b;
    p</span>-&gt;f1(); <span style="color: #008000;">//</span><span style="color: #008000;">A::f1()</span>
    cout&lt;&lt;( p-&gt;a1 )&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">A::a1</span>
<span style="color: #000000;">    
    ((B</span>*)p)-&gt;f2(); <span style="color: #008000;">//</span><span style="color: #008000;">B::f2()</span>
    cout&lt;&lt;( ((B*)p)-&gt;b2 )&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">B::b2</span>
<span style="color: #000000;">}

将基类A的指针强制类型转换为派生类B的指针 ( (B</span>*)p )-&gt;f2(); <span style="color: #008000;">//</span><span style="color: #008000;">p的外层括号不能丢，因为成员运算符优先级高于强制类型转换运算符</span>

<span style="color: #800080;">9</span>.2派生类指针访问基类对象 <span style="color: #008000;">//</span><span style="color: #008000;">不安全</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f1();
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a1;
};
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f2();
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> b2;
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A a;
    B b;
    B </span>*<span style="color: #000000;">p;
    
    ((A)b).f1(); </span><span style="color: #008000;">//</span><span style="color: #008000;">A::f1()，派生类对象强制转换为基类对象访问</span>
    cout&lt;&lt;((A)b).a1&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">A::a1，派生类对象强制转换为基类对象访问</span>
<span style="color: #000000;">    b.f2();
    cout</span>&lt;&lt;b.b2&lt;&lt;<span style="color: #000000;">endl;
    
    p</span>=&amp;<span style="color: #000000;">a;
    ((A</span>*)p)-&gt;f1(); <span style="color: #008000;">//</span><span style="color: #008000;">A::f1()，派生类指针强制转换为基类指针访问</span>
    cout&lt;&lt;( ((A*)p)-&gt;a1 )&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">A::a1，派生类指针强制转换为基类指针访问</span>
    p-&gt;<span style="color: #000000;">f2();
    cout</span>&lt;&lt;( p-&gt;b2 )&lt;&lt;<span style="color: #000000;">endl;
}

</span><span style="color: #800080;">9</span><span style="color: #000000;">.3派生类成员函数调用基类同名成员函数
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print(){}
};
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> :
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        A::print(); </span><span style="color: #008000;">//</span><span style="color: #008000;">作用域运算符调用基类print()函数</span>
        ( (A*)<span style="color: #0000ff;">this</span> )-&gt;print(); <span style="color: #008000;">//</span><span style="color: #008000;">将this指针强制类型转换为基类指针，调用基类print()函数</span>
        ( (A)(*<span style="color: #0000ff;">this</span>) ).print(); <span style="color: #008000;">//</span><span style="color: #008000;">将this对象强制类型转换为基类对象，调用基类print()函数</span>
<span style="color: #000000;">    }
};

</span><span style="color: #800080;">9</span><span style="color: #000000;">.4虚函数与派生类普通重载函数比较
派生类普通重载函数
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">A::print()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B 
{
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">B::print()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*p; <span style="color: #008000;">//</span><span style="color: #008000;">基类指针</span>
<span style="color: #000000;">    
    A a;
    p</span>=&amp;<span style="color: #000000;">a;
    p</span>-&gt;print(); <span style="color: #008000;">//</span><span style="color: #008000;">A::print()</span>
<span style="color: #000000;">    
    B b;
    p</span>=&amp;<span style="color: #000000;">b;
    p</span>-&gt;print(); <span style="color: #008000;">//</span><span style="color: #008000;">A::print() 基类指针只能访问继承的基类成员print()</span>
<span style="color: #000000;">}


虚函数
一般把virtual关键字写在基类的虚函数中，派生类中可省略
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A 
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> print()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">A::print()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> print() <span style="color: #008000;">//</span><span style="color: #008000;">也可写为virtual void print()，派生类中virtual可省略</span>
<span style="color: #000000;">    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">B::print()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*p; <span style="color: #008000;">//</span><span style="color: #008000;">基类指针</span>
<span style="color: #000000;">    
    A a;
    p</span>=&amp;<span style="color: #000000;">a;
    p</span>-&gt;print(); <span style="color: #008000;">//</span><span style="color: #008000;">A::print()</span>
<span style="color: #000000;">    
    B b;
    p</span>=&amp;<span style="color: #000000;">b;
    p</span>-&gt;print(); <span style="color: #008000;">//</span><span style="color: #008000;">B::print() 虚函数多态性</span>
<span style="color: #000000;">}

注意，虚函数重载时返回值类型，函数名，参数个数，参数类型必须完全相同
如果函数原型不同，仅函数名相同，就是派生类普通函数重载了
如果仅返回值类型不同，则是错误重载，编译不通过

</span><span style="color: #800080;">9</span><span style="color: #000000;">.4虚析构函数
普通析构函数的问题
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    A()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">构造A::A()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span>~<span style="color: #000000;">A()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">析构A::~A()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    B()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">构造B::B()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span>~<span style="color: #000000;">B()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">析构B::~B()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*<span style="color: #000000;">p;
    
    p</span>=<span style="color: #0000ff;">new</span> B; <span style="color: #008000;">//</span><span style="color: #008000;">调用A::A(),B::B()，基类指针动态建立派生类对象 </span>
    <span style="color: #0000ff;">delete</span> B; <span style="color: #008000;">//</span><span style="color: #008000;">调用A::~A()，仅调用了基类析构函数，不能释放派生类对象的内存空间，造成内存泄露</span>
    p=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">基类指针置空</span>
<span style="color: #000000;">}

虚析构
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    A()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">构造A::A()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span><span style="color: #0000ff;">virtual</span> ~<span style="color: #000000;">A()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">析构A::~A()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    B()
    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">构造B::B()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
    </span>~B() <span style="color: #008000;">//</span><span style="color: #008000;">或写为virtual ~B()，派生类中virtual可省略</span>
<span style="color: #000000;">    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">析构B::~B()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*<span style="color: #000000;">p;
    
    p</span>=<span style="color: #0000ff;">new</span> B; <span style="color: #008000;">//</span><span style="color: #008000;">调用A::A()，B::B()，基类指针动态建立派生类对象 </span>
    <span style="color: #0000ff;">delete</span> B; <span style="color: #008000;">//</span><span style="color: #008000;">调用B::~B()，A::~A()，释放基类成员和派生类成员的内存空间</span>
    p=NULL; <span style="color: #008000;">//</span><span style="color: #008000;">基类指针置空</span>
<span style="color: #000000;">}


</span><span style="color: #800080;">9</span><span style="color: #000000;">.5纯虚函数
提取一般概念或公共属性，具体实现由派生类完成。
有纯虚函数的基类叫抽象类，具体实现该函数的派生类叫具体类
</span><span style="color: #0000ff;">virtual</span> 类型 函数名(参数表)=<span style="color: #800080;">0</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">class</span> A <span style="color: #008000;">//</span><span style="color: #008000;">A是抽象类</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">virtual</span> <span style="color: #0000ff;">void</span> show()=<span style="color: #800080;">0</span><span style="color: #000000;">;
};

</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span> A  <span style="color: #008000;">//</span><span style="color: #008000;">B是具体类</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> show() <span style="color: #008000;">//</span><span style="color: #008000;">派生类中实现show()函数</span>
<span style="color: #000000;">    {
        cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">B::show()</span><span style="color: #800000;">"</span>&lt;&lt;<span style="color: #000000;">endl;
    }
};


</span><span style="color: #800080;">9</span><span style="color: #000000;">.6异质链表
在基类中定义基类指针，建立一条由不同派生类组成的单链表
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A 
{
};
</span><span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
};
</span><span style="color: #0000ff;">class</span> C:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
};
</span><span style="color: #0000ff;">class</span> D:<span style="color: #0000ff;">public</span><span style="color: #000000;"> A
{
};

</span><span style="color: #0000ff;">void</span> add(A *head,A *<span style="color: #000000;">p)
{
    p</span>-&gt;next=<span style="color: #000000;">head;
    head</span>=<span style="color: #000000;">p;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A </span>*head=NULL,*<span style="color: #000000;">p;
    p</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> B;
    add(head,p);
    p</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> C;
    add(head,p);
    p</span>=<span style="color: #0000ff;">new</span><span style="color: #000000;"> D;
    add(head,p);
}

</span><span style="color: #800080;">10</span><span style="color: #000000;">.1模板声明
template</span>&lt;typename T1,typename T2,typename T3.....&gt;<span style="color: #000000;">
T1，T2，T3是自定义的形式类型参数，可以实例化为任何类型

</span><span style="color: #800080;">10</span><span style="color: #000000;">.2函数模板 (函数的模板)      注：模(m&uacute;)板
【 先写模板声明，再定义函数模板 】

template</span>&lt;typename 形式类型名&gt;<span style="color: #000000;">
返回类型 函数名(参数表)
{
}

例:
template</span>&lt;typename T&gt;<span style="color: #000000;"> 
T max(T a,T b) </span><span style="color: #008000;">//</span><span style="color: #008000;">类属参数可以作参数，也可以作返回值</span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">return</span> a&gt;b?<span style="color: #000000;">a:b;
}

</span><span style="color: #800080;">10</span><span style="color: #000000;">.3模板函数 (通过模板生成的函数)         注：模(m&uacute;)板
在运行时根据参数类型自动实例化为对应类型的模板函数
t</span>=max(<span style="color: #800080;">5</span>,<span style="color: #800080;">6</span>); <span style="color: #008000;">//</span><span style="color: #008000;">生成模板函数 int max(int a,int b);</span>

<span style="color: #800080;">10</span><span style="color: #000000;">.4重载函数模板
</span><span style="color: #800080;">10.4</span><span style="color: #000000;">.1通过模板函数重载
例:
template</span>&lt;typename T&gt;<span style="color: #000000;">
T max(T a,T b);

template</span>&lt;typename T&gt;<span style="color: #000000;">
T max(</span><span style="color: #0000ff;">const</span> T *a,<span style="color: #0000ff;">int</span> n); <span style="color: #008000;">//</span><span style="color: #008000;">模板函数重载max</span>

<span style="color: #800080;">10.4</span><span style="color: #000000;">.1通过普通函数重载
例:
template</span>&lt;typename T&gt;<span style="color: #000000;">
T max(T a,T b);

</span><span style="color: #0000ff;">int</span> max(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> a,<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> b); <span style="color: #008000;">//</span><span style="color: #008000;">普通函数重载max</span>


<span style="color: #800080;">10</span><span style="color: #000000;">.5类模板
类模板中的成员函数都是模板函数
成员函数在类外定义时，每个都要有模板声明

template</span>&lt;typename 类属参数名&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> 类名
{
    类属参数名  变量名; </span><span style="color: #008000;">//</span><span style="color: #008000;">类属参数在类说明中至少出现一次</span>
<span style="color: #000000;">    返回类型  函数名(参数表);
};

返回类型 类名</span>&lt;T&gt;<span style="color: #000000;">::函数名(参数表)
{
}

例:
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> stu
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f1(T a);
    T x;
};

template</span>&lt;typename T&gt; 
<span style="color: #0000ff;">void</span> stu&lt;T&gt;<span style="color: #000000;">::f1(T a)
{
}

类模板实例化为模板类时，成员函数(函数模板)实例化为模板函数



</span><span style="color: #800080;">10</span><span style="color: #000000;">.6类模板作为函数的参数
template</span>&lt;typename 类属参数名&gt;<span style="color: #000000;">
返回类型 函数名(类属参数 变量1,类型2 变量2....);

例:
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> array
{
};

template</span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> fun(array&lt;T&gt; x,<span style="color: #0000ff;">int</span><span style="color: #000000;"> n)
{
}

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    array</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">  ban;
    fun(ban,</span><span style="color: #800080;">5</span><span style="color: #000000;">);
}


</span><span style="color: #800080;">10</span><span style="color: #000000;">.7类模板派生类模板
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    T x;
    A(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a);
};

template</span>&lt;typename T&gt;<span style="color: #000000;">
A</span>&lt;T&gt;::A(<span style="color: #0000ff;">int</span> a) <span style="color: #008000;">//</span><span style="color: #008000;">A类构造函数的类外定义</span>
<span style="color: #000000;">{
}


template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span> A&lt;T&gt; <span style="color: #008000;">//</span><span style="color: #008000;">继承时，类模板A&lt;T&gt; 派生出 类模板b&lt;T&gt;</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    B(</span><span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
};

template</span>&lt;typename T&gt;<span style="color: #000000;">
B</span>&lt;T&gt;::B(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b) : A&lt;T&gt;(a) <span style="color: #008000;">//</span><span style="color: #008000;">构造函数参数初始式，类模板A&lt;T&gt; 派生出 类模板b&lt;T&gt;</span>
<span style="color: #000000;">{
};

调用:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A</span>&lt;<span style="color: #0000ff;">int</span>&gt; a(<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">类模板A&lt;T&gt;实例化为模板类A&lt;int&gt;，生成对象a</span>
    B&lt;<span style="color: #0000ff;">int</span>&gt; b(<span style="color: #800080;">3</span>,<span style="color: #800080;">7</span>); <span style="color: #008000;">//</span><span style="color: #008000;">类模板B&lt;T&gt;实例化为模板类B&lt;int&gt;，生成对象b</span>
<span style="color: #000000;">}

</span><span style="color: #800080;">10</span><span style="color: #000000;">.8类模板派生模板类(普通类)
在继承时实例化类模板
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    T x;
    A(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> a);
};

template</span>&lt;typename T&gt;<span style="color: #000000;">
A</span>&lt;T&gt;::A(<span style="color: #0000ff;">int</span> a) <span style="color: #008000;">//</span><span style="color: #008000;">A类构造函数的类外定义</span>
<span style="color: #000000;">{
}


template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span> B:<span style="color: #0000ff;">public</span> A&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #008000;">//</span> <span style="color: #008000;">//</span><span style="color: #008000;">继承时，类模板A&lt;T&gt;实例化为模板类A&lt;int&gt;，然后模板类A&lt;int&gt;派生出 模板类b&lt;int&gt;</span>
<span style="color: #000000;">{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    B(</span><span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span><span style="color: #000000;"> b);
};

template</span>&lt;typename T&gt;<span style="color: #000000;">
B</span>&lt;T&gt;::B(<span style="color: #0000ff;">int</span> a,<span style="color: #0000ff;">int</span> b) : A&lt;<span style="color: #0000ff;">int</span>&gt;(a) <span style="color: #008000;">//</span><span style="color: #008000;">构造函数参数初始式，类模板A&lt;T&gt;实例化为模板类A&lt;int&gt;，然后模板类A&lt;int&gt;派生出 模板类b&lt;int&gt;</span>
<span style="color: #000000;">{
};

调用:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    A</span>&lt;<span style="color: #0000ff;">int</span>&gt; a(<span style="color: #800080;">2</span>); <span style="color: #008000;">//</span><span style="color: #008000;">类模板A&lt;T&gt;实例化为类模板A&lt;int&gt;，生成对象a</span>
    B b(<span style="color: #800080;">3</span>,<span style="color: #800080;">7</span>); <span style="color: #008000;">//</span><span style="color: #008000;">模板类B&lt;int&gt;生成对象b</span>
<span style="color: #000000;">}


</span><span style="color: #800080;">10</span><span style="color: #000000;">.9类模板的友元函数
①一般函数     
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    friend </span><span style="color: #0000ff;">void</span> f1(); <span style="color: #008000;">//</span><span style="color: #008000;">类内声明</span>
<span style="color: #000000;">};
</span><span style="color: #0000ff;">void</span> f1() <span style="color: #008000;">//</span><span style="color: #008000;">类外定义</span>
<span style="color: #000000;">{
}

②函数模板     
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    template</span>&lt;typename T&gt;<span style="color: #000000;">
    friend </span><span style="color: #0000ff;">void</span> f2( X&lt;T&gt;  &amp;a ); <span style="color: #008000;">//</span><span style="color: #008000;">类内声明</span>
<span style="color: #000000;">};
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">void</span> f2(X&lt;T&gt; &amp;a) <span style="color: #008000;">//</span><span style="color: #008000;">类外定义</span>
<span style="color: #000000;">{
}

③普通类的成员函数    
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    friend </span><span style="color: #0000ff;">void</span> A::f3(); <span style="color: #008000;">//</span><span style="color: #008000;">类内声明  f3()函数是A类的成员函数</span>
<span style="color: #000000;">};
</span><span style="color: #0000ff;">void</span> A::f3() <span style="color: #008000;">//</span><span style="color: #008000;">类外定义</span>
<span style="color: #000000;">{
}

④类模板的成员函数    
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    template</span>&lt;typename T&gt;<span style="color: #000000;">
    friend </span><span style="color: #0000ff;">void</span> B&lt;T&gt;::f4( X&lt;T&gt;  &amp;a ); <span style="color: #008000;">//</span><span style="color: #008000;">类内声明</span>
<span style="color: #000000;">};
template</span>&lt;typename T&gt;<span style="color: #000000;">
friend </span><span style="color: #0000ff;">void</span> B&lt;T&gt;::f4(X&lt;T&gt;  &amp;a) <span style="color: #008000;">//</span><span style="color: #008000;">类外定义</span>
<span style="color: #000000;">{
}


</span><span style="color: #800080;">10</span><span style="color: #000000;">.10类模板的友元类
①普通类
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    friend </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> A;
};

②类模板
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> X
{
    template</span>&lt;typename T1&gt;<span style="color: #000000;">
    friend </span><span style="color: #0000ff;">class</span> B;    <span style="color: #008000;">//</span><span style="color: #008000;">类模板B&lt;T&gt;不加类属参数</span>
<span style="color: #000000;">};


</span><span style="color: #800080;">10.11</span><span style="color: #000000;">.1类模板的静态成员变量
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> num; <span style="color: #008000;">//</span><span style="color: #008000;">类内声明</span>
<span style="color: #000000;">};
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">int</span> A&lt;T&gt;::num=<span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;">类外定义和初始化</span>

<span style="color: #800080;">10.11</span><span style="color: #000000;">.2类模板的静态成员函数
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">class</span><span style="color: #000000;"> A
{
    </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> show();    <span style="color: #008000;">//</span><span style="color: #008000;">类内声明</span>
<span style="color: #000000;">};
template</span>&lt;typename T&gt;
<span style="color: #0000ff;">int</span> A&lt;T&gt;::show()    <span style="color: #008000;">//</span><span style="color: #008000;">类外定义</span>
<span style="color: #000000;">{
}


</span><span style="color: #800080;">10</span><span style="color: #000000;">.12标准模版(STL)
标准模板库由 容器、迭代器、算法组成</span></pre>
</div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>