<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++语法笔记（上）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++语法笔记（上）</center></div><div class='banquan'>原文出处:本文由博客园博主拦截短信提供。<br/>
原文连接:https://www.cnblogs.com/lanjieduanxin/p/11461200.html</div><br>
    <p align="left">客观事物中任何一个事物都可以看成一个对象，对象是由一组属性和一组行为构成的。<br />
c++中，每个对象都是由<strong>数据</strong>与<strong>函数</strong>这两部分构成，数据就是对象的属性，函数就是对象的行为。<br />
c++中对象的类型称为类，类是一批对象的共性和特征。类是对象的抽象，对象是类的具体实例。</p>
<p align="left"><br />
<span style="font-size: 18pt;">如何声明一个类：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Time 
{
</span><span style="color: #0000ff;">public</span> :                          <span style="color: #008000;">//</span><span style="color: #008000;">成员访问限定符</span>
<span style="color: #000000;">公有数据和成员函数
</span><span style="color: #0000ff;">private</span> :                        <span style="color: #008000;">//</span><span style="color: #008000;">成员访问限定符</span>
<span style="color: #000000;">私有数据和成员函数
</span><span style="color: #0000ff;">protected</span><span style="color: #000000;">: 
受保护数据和成员函数
};</span></pre>
</div>
<p align="left">&nbsp;</p>
<p>&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><span style="font-size: 18pt;">如何定义对象：</span><br />
1. 先声明类类型，然后定义对象</p>
<p align="left">2. 在声明类的同时定义对象</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Time 
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> :
Time ();
</span><span style="color: #0000ff;">void</span> set_time ();           <span style="color: #008000;">//</span><span style="color: #008000;">成员函数说明 </span>
<span style="color: #0000ff;">void</span><span style="color: #000000;"> show_time ();
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> :
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> hour;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minute;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sec; 
} tim1,tim2;</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><br />
类的成员函数：在类体中定义的函数，同一个类的不同对象，其成员函数是共用的<br />
，每个对象所占用的存储空间只是该对象的数据成员所占用的存储空间。</p>
<p align="left"><br />
<span style="font-size: 18pt;">如何访问对象的中的成员：</span><br />
1.对象名.对象成员<br />
2.通过对象指针访问对象成员<br />
Time *p t1;<br />
p=&amp;t1;<br />
p-&gt;hour;<br />
3.通过对象应用访问对象成员<br />
Time t1;<br />
Time &amp;t2=t1;<br />
t2.hour;</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><br />
<span style="font-size: 18pt;">怎样使用类和对象</span><br />
利用<strong>构造函数</strong>对类进行初始化：<br />
构造函数的名字必须与类名同名，它不具有任何类型，没有返回值。<br />
在建立类对象时会自动调用构造函数。在建立对象时系统为该对象分配存储单元，此时执行构造函数，赋予初始值。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Time 
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> :
Time ();
</span><span style="color: #0000ff;">void</span> set_time (); <span style="color: #008000;">//</span><span style="color: #008000;">成员函数说明 </span>
<span style="color: #0000ff;">void</span><span style="color: #000000;"> show_time ();
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> :
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> hour;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> minute;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> sec; 
};
Time::Time ()                       </span><span style="color: #008000;">//</span><span style="color: #008000;">定义构造成员函数 </span>
{                                        <span style="color: #008000;">//</span><span style="color: #008000;">利用构造成员函数进行初始化 </span>
hour =<span style="color: #800080;">0</span><span style="color: #000000;">;
minute </span>=<span style="color: #800080;">0</span><span style="color: #000000;">;
sec </span>=<span style="color: #800080;">0</span><span style="color: #000000;">; 
}</span></pre>
</div>
<p>&nbsp;</p>
<p align="left">这种方式使该类的每一个对象的数据成员都得到同一组初值。</p>
<p align="left"><br />
如何对不同对象赋予不同初值？使用<strong>带参数的构造函数</strong>。<br />
构造函数名（类型1 形参1 ）<br />
类名 对象名（实参1 实参2 实参3...）</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Box
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
Box(</span><span style="color: #0000ff;">int</span> ,<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span> ); <span style="color: #008000;">//</span><span style="color: #008000;">对不同的对象赋予不同的初始值 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> volume ();
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> width;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> length;
};
Box::Box(</span><span style="color: #0000ff;">int</span> h,<span style="color: #0000ff;">int</span> w,<span style="color: #0000ff;">int</span><span style="color: #000000;"> len)
{
height </span>=<span style="color: #000000;">h;
width </span>=<span style="color: #000000;">w;
length </span>=<span style="color: #000000;">len;
}</span></pre>
</div>
<p>&nbsp;</p>
<p align="left"><br />
用<strong>参数初始化表</strong>对数据成员初始化（在函数首部初始化，而不是在函数体内对数据成员初始化）<br />
Box::Box(int h,int w,int len)：height(h),width(w),length(len){}
//用参数的初始化表法可以减少函数体长度<br />
如果数据成员是数组，则应当在构造函数的函数体中用语句对其赋值，而不能在参数初始化表中对其初始化。<br />
class student<br />
{public:<br />
student(int n,char s,nam[]):num(n),sex(s){strcpy(name,nam)}<br />
private:<br />
int num;<br />
char sex;<br />
char name[20];<br />
};</p>
<p align="left"><br />
<strong>构造函数的重载</strong><br />
在一个类中可以定义多个构造函数，以便为对象提供不同的初始化的方法，这些构造函数名字相同，二参数的个数或参数的类型不同，这称为构造函数的重载。<br />
使用默认参数的构造函数</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Box
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
Box(</span><span style="color: #0000ff;">int</span> h=<span style="color: #800080;">10</span> ,<span style="color: #0000ff;">int</span> w=<span style="color: #800080;">10</span>, <span style="color: #0000ff;">int</span> len=<span style="color: #800080;">10</span> ); <span style="color: #008000;">//</span><span style="color: #008000;">也可以写成Box(int =10 ,int =10, int =10 ); </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> volume ();
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> width;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> length;
};
 
Box::Box(</span><span style="color: #0000ff;">int</span> h,<span style="color: #0000ff;">int</span> w,<span style="color: #0000ff;">int</span><span style="color: #000000;"> len)
{
height </span>=<span style="color: #000000;">h;
width </span>=<span style="color: #000000;">w;
length </span>=<span style="color: #000000;">len;
}</span></pre>
</div>
<p>&nbsp;</p>
<p align="left">　　</p>
<p align="left"><strong>注意：</strong><br />
1 如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参。<br />
2 在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。</p>
<p align="left">&nbsp;</p>
<p align="left"><strong>析构函数</strong>，其作用与构造函数相反<br />
在下列4中情况中，程序会自动执行析构函数。<br />
1 如果在一个函数中定义了一个对象，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。<br />
2 静态(static)局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只有在main 函数结束或者调用exit函数结束程序时，才调用static局部对象的析构函数。<br />
3 定义了一个全局对象，<br />
4 用new运算符动态建立了一个对象，用delete运算符释放该对象时调用析构函数。<br />
析构函数用例：</p>
<div class="cnblogs_code">
<pre>#include&lt;iostream&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Box
{      
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
Box(</span><span style="color: #0000ff;">int</span> ,<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span> ); <span style="color: #008000;">//</span><span style="color: #008000;">对不同的对象赋予不同的初始值 </span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> volume ();
</span>~<span style="color: #000000;">Box()
{cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">construct called</span><span style="color: #800000;">"</span>&lt;&lt;volume()&lt;&lt;<span style="color: #000000;">endl;}
 
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> width;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> length;
};
 
Box::Box(</span><span style="color: #0000ff;">int</span> h,<span style="color: #0000ff;">int</span> w,<span style="color: #0000ff;">int</span><span style="color: #000000;"> len)
{
height </span>=<span style="color: #000000;">h;
width </span>=<span style="color: #000000;">w;
length </span>=<span style="color: #000000;">len;
} 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> Box::volume()
{
</span><span style="color: #0000ff;">return</span> (height*width*<span style="color: #000000;">length);
} 
 
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
Box box1(</span><span style="color: #800080;">12</span>,<span style="color: #800080;">25</span>,<span style="color: #800080;">30</span><span style="color: #000000;">);
cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">The volume of box1</span><span style="color: #800000;">"</span>&lt;&lt;box1.volume()&lt;&lt;<span style="color: #000000;">endl;
Box box2(</span><span style="color: #800080;">1</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span><span style="color: #000000;">);
cout</span>&lt;&lt;<span style="color: #800000;">"</span><span style="color: #800000;">The volume of box1</span><span style="color: #800000;">"</span>&lt;&lt;box2.volume()&lt;&lt;<span style="color: #000000;">endl;
</span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
 
}      </span></pre>
</div>
<p>&nbsp;</p>
<p align="left">　　</p>
<p align="left">上面程序运行结果显示，先构造的后析构，后构造的先析构。相当与一个栈。<br />
但是，并不是在任何情况都按这一原则处理的。<br />
1 在全局范围中定义对象，它的构造函数在文本模块中所有函数执行前调用。<br />
2 如果定义的是局部自动变量，则在建立对象时调用其构造函数，在函数调用结束时、对象释放时先调用析构函数。<br />
3 在函数中定义静态局部对象，只在第一次调用此函数定义对象时调用构造函数一次，在main函数结束或调用exit 函数结束程序时，才调用析构函数。</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left"><strong>对象数组</strong>（数组中每一个元素都是同类的对象）<br />
例如：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> student
{...
};
student stud[</span><span style="color: #800080;">3</span>]=<span style="color: #000000;">{
student(</span><span style="color: #800080;">12</span>,<span style="color: #800080;">34</span>,<span style="color: #800080;">45</span>,<span style="color: #800080;">56</span><span style="color: #000000;">),
student(</span><span style="color: #800080;">23</span>,<span style="color: #800080;">45</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">3</span><span style="color: #000000;">)
student(</span><span style="color: #800080;">2</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">556</span>,<span style="color: #800080;">3</span><span style="color: #000000;">)
};</span></pre>
</div>
<p>&nbsp;</p>
<p align="left">　　</p>
<p align="left"><br />
<strong>对象指针</strong><br />
student *st;&nbsp;<br />
student stud1;<br />
st=&amp;stud1;</p>
<p align="left">指向对象成员的指针<br />
对象有地址，存放对象的起始地址的指针变量就是指向对象的指针变量。<br />
对象中的成员也有地址，存放对象成员地址的指针变量就是指向对象成员的指针变量。<br />
1.指向对象数据成员的指针<br />
数据类型名 *指针变量名<br />
2.指向对象成员函数的指针<br />
数据类型名（类名：：*指针变量名）（参数表名）<br />
void(Time::*p)();<br />
指针变量名=&amp;类名：：成员函数名；</p>
<p align="left"><br />
<strong>常对象成员</strong>：<br />
1.常数据成员（其值是不能改变的，只能通过构造函数的参数初始化表对常数据成员进行初始化，任何其他函数都不能对常成员赋值）<br />
Time::Time(int h)<br />
{hour=h;} //非法，不能对其赋值<br />
Time::Time(int h):hour(h){}</p>
<p align="left">2.常成员函数<br />
一般的成员函数可以引用本类中的非const数据成员,也可以修改他们。如果将数据成员函数声明为常成员函数，则只能引用本类中的数据成员，而不能修改他们。<br />
void get_time() const;&nbsp;<br />
类型名 函数名 （参数表） const;<br />
const 是函数类型的一部分，在声明函数和定义函数的时都要有const关键字，在调用时不必加const</p>
<p align="left">指向对象的常指针（指针常量）<br />
类名*const 指针变量名； //指向对象的常指针的值不能改变，始终指向同一个对象，但可以改变其所指向的对象的值。<br />
往往用常指针作为函数的形参，目的是不允许在函数执行过程中改变指针变量的值，使其始终指向原来的对象。</p>
<p align="left">指向常对象的指针变量(常量指针)<br />
const 类型名*指针变量&nbsp;<br />
const char* ptr; //指针变量ptr指向的char 变量是常变量，不能通过ptr改变其值。<br />
说明：<br />
1 .如果一个变量以被声明为常变量，只能用指向常变量的指针变量指向它<br />
2 .如果函数的形参是指向普通变量的指针变量，实参只能用指向普通变量的指针，而不能用指向const 变量的指针，这样在执行函数的过程中可以改变改变形参所指向的变量。<br />
当希望在调用函数时对象的值不被修改，就应当把形参定义为指向常对象的指针变量，同时用对象的地址作为实参（对象可以是const或者非const型）</p>
<p align="left">对象的常引用<br />
一个变量的引用就是变量的别名。实质上，变量名和引用名都指向同一段内存地单元。</p>
<p align="left"><br />
<strong>对象的动态建立和释放</strong><br />
有时人们希望在需要用到对象时在建立对象，在不需要用该对象时就撤销它，释放它所占用的内存空间，这样可以提高内存空间的利用率<br />
用new运算符动态分配内存后，将返回一个指向新对象的指针，即所分配的内存空间的起始地址。<br />
用户可以获得这个地址，并通过这个地址来访问这个对象。<br />
Box *pt;<br />
pt=new Box;</p>
<p align="left">在执行new运算时，如果内存量不足，无法开辟所需的内存空间，编译系统会放回一个NULL。</p>
<p align="left">在不需要使用由new建立的对象时，可以用delete运算符予以释放。<br />
delete pt;</p>
<p align="left"><br />
<strong>对象的赋值与复制</strong><br />
对象1=对象2；<br />
对象的赋值只对其中数据成员赋值，而不对成员函数赋值。<br />
类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现严重后果。</p>
<p align="left">对象的复制<br />
类名 对象2（对象1）； //用对象1复制出对象2<br />
括号中的参数是对象，在建立对象时调用一个特殊的构造函数--复制构造函数<br />
类名 对象2=对象1； //另一种方便用户的复制形式</p>
<p align="left"><br />
对象的赋值时对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。<br />
对象的赋值是从无中到有的建立一个新对象，并使它与一个已有的对象完全相同的过程。<br />
<br />
<strong>静态成员</strong>（在同类的多个对象之间实现数据共享）<br />
1.静态数据成员<br />
是一种特殊的数据成员，以关键字static开头<br />
如果希望各对象中数据成员的值是一样的，就可以把它定义为静态数据成员<br />
1. 静态数据成员在内存中只占一份内存空间，每个对象都可以引用这个静态数据成员<br />
2. 静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。（静态数据成员并不是属于对象的，而是属于类的，但类的对象可以引用）<br />
静态数据成员在程序开始运行时被分配空间，到程序结束时才释放空间。<br />
3. 静态数据成员可以初始化，但是只能在类体外进行。不能用参数初始化列表对静态成员初始化<br />
4. 静态数据成员尽既可以通过对象名引用，又可以通过类名来引用。</p>
<p align="left"><br />
2.静态成员函数 (是类的一部分，而不是对象的一部分)<br />
static int volume();<br />
静态成员函数作用不是为了对象之间的沟通，而是为了能够处理静态数据成员。<br />
静态成员函数不属于某一对象，与任何对象都无关，因此静态成员函数没有this指针，<br />
也无法指定某个对象，也就无法访问本类中的非静态成员。<br />
只用静态成员函数引用静态成员，而不引用非静态数据成员。</p>
<p align="left"><strong>友元</strong><br />
1.友元函数<br />
如果在本类以外的其他地方定义了一个函数（这个函数可以属于任何类的非成员函数，也可以是其他类的成员函数），在类体中用friend对其进行声明此函数就称为本类的友元函数。<br />
友元函数可以访问这个类中中的私有成员。<br />
<br />
2.友元类<br />
将一个类声明为另一个类的朋友，<br />
class A<br />
{...<br />
friend B; //在类A中声明B为其友元<br />
...<br />
}；<br />
<br />
关于友元类的说明：<br />
1. 友元的关系是单向的，上面的例子中B类是A类的友元，不等于A类是B类的友元<br />
2. 友元的关系不能传递</p>
<p align="left"><strong>类模板</strong><br />
函数模板（对于功能相同而数据类型不同的一些函数，不必一一定义各函数，可以定义一个可对于任何类型变量进行操作的函数模板，<br />
在调用函数时，系统会根据实参类型，取代函数模板中的类型参数，得到具体函数）<br />
template&lt;class 类型参数名&gt; //声明模板类</p>
<p align="left">template&lt;class
numtype&gt;</p>
<p align="left">class compare</p>
<p align="left">{</p>
<p align="left">public:</p>
<p align="left">compare(numtype
a,numtype b);</p>
<p align="left">{x=a;y=b;}</p>
<p align="left">numtype max()</p>
<p align="left">{return
(x&gt;y)?x:y;}</p>
<p align="left">numtype min()</p>
<p align="left">{return
(x&lt;y)?x:y;}</p>
<p align="left">private:</p>
<p align="left">numtype x,y;&nbsp;&nbsp;&nbsp; </p>
<p align="left">};</p>
<p align="left">　　</p>
<p align="left">compare&lt;int&gt;cmp(4,6);
//变成一个实际的类</p>
<p align="left">&nbsp;</p>
<p align="left">template &lt;class
numtype&gt; //在类模板外定义方式<br />
numtype compare&lt;numtype&gt;::max()<br />
{return (x&gt;y)?x:y;}</p>
<p align="left"><br />
可以这样声明和使用类模板<br />
1. 先写出一个实际的类<br />
2.将此类准备改变的类型名（如int要改变成float或char）改用一个自己指定的虚拟类型名<br />
3.在类声明前加入一行，格式为<br />
template&lt;class 虚拟类型参数&gt;<br />
4. 在类模板定义对象时用以下形式<br />
类模板名&lt;实际类型名&gt;对象名；<br />
类模板名&lt;实际类型名&gt;对象名（实参表）；</p>
<p align="left">compare&lt;int&gt;cmp;<br />
compare&lt;int&gt;cmp(5,3);<br />
5.如果在类模板外定义成员函数，应写出如下形式<br />
template&lt;class 虚拟类型参数&gt;<br />
函数类型 类模板名&lt;虚拟类型参数&gt;：：成员函数名（函数参数表）{...}</p>
<p align="left">&nbsp;</p>
<p align="left"><strong>参考书目</strong><strong>:</strong><strong>《</strong><strong>c++</strong><strong>程序设计》谭浩强</strong></p>
<p align="left"><strong>2019-09-04&nbsp;
&nbsp; &nbsp;&nbsp;19:37:17</strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>