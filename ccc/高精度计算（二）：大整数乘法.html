<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修高精度计算（二）：大整数乘法' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>高精度计算（二）：大整数乘法</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11194167.html</div><br>
    <p>【例1】两个大整数乘法。</p>
<p>&nbsp; &nbsp; &nbsp; 输入两个不超过200位的非负大整数a和b，求a&times;b的值。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 用 unsigned num1[200]和num2[200]分别存放两个乘数，用result[400]来存放积。计算的中间结果也都存在result 中。result 长度取400 是因为两个200 位的数相乘，积最多会有400 位。num1[0], num2[0], result[0]都表示个位。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;计算的过程基本上和小学生列竖式做乘法相同。为编程方便，并不急于处理进位，而将<br />进位问题留待最后统一处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;图1给出了753&times;68的计算过程。描述如下：</p>
<p style="text-align: center;"><img src="./images/高精度计算（二）：大整数乘法0.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; 1）先依次计算753的各位数字与8的乘积，并加到result数组的相应单元中。result数组的全部元素的初始值均为0。</p>
<p>&nbsp; &nbsp; &nbsp; 2）再依次计算753的各位数字与6的乘积，并加到result数组的相应单元中。</p>
<p>&nbsp; &nbsp; &nbsp; 3）乘法过程完毕。从 result[0]开始向高位逐位处理进位问题。result[0]留下4，</p>
<p>把2 加到result[1]上，result[1]变为60 后，应留下0，把6 加到result[2]上&hellip;&hellip;最终使<br />得result 里的每个元素都是1 位数，结果就算出来了。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;在乘法过程中，num1的第i 位和num2的第j 位相乘所得的数，一定是要累加到<br />result的第i+j 位上。这里i, j 都是从右往左，从0 开始数。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。（将此源程序提交给POJ 2389 <span style="font-family: 宋体;">&ldquo;<span style="font-family: 'times new roman', times;">Bull Math</span>&rdquo;，可以<span style="font-family: 'times new roman', times;">Accepted</span></span>）</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MAX_LEN 201<br />void bigNumMul(char a[],char b[],char c[])<br />{<br />&nbsp; &nbsp; &nbsp; int i,j,n1,n2;<br />&nbsp; &nbsp; &nbsp; int num1[MAX_LEN]={0},num2[MAX_LEN]={0},result[2*MAX_LEN]={0};<br />&nbsp; &nbsp; &nbsp; // 将a和b中存储的字符串形式的整数转换到num1和num2中去，<br />&nbsp; &nbsp; &nbsp; // num1[0]对应于个位、num1[1]对应于十位、&hellip;&hellip;<br />&nbsp; &nbsp; &nbsp; n1 = strlen(a);<br />&nbsp; &nbsp; &nbsp; j = 0;<br />&nbsp; &nbsp; &nbsp;for (i = n1 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; num1[j++] = a[i] - '0';<br />&nbsp; &nbsp; &nbsp;n2 = strlen(b);<br />&nbsp; &nbsp; &nbsp;j = 0;<br />&nbsp; &nbsp; for (i = n2 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; num2[j++] = b[i] - '0';<br />&nbsp; &nbsp; for (i=0;i &lt; n2; i++ )<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; for (j=0; j&lt;n1; j++) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i+j] += num2[i]*num1[j];&nbsp; &nbsp;// 两数第i, j 位相乘，累加到结果的第i+j 位<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp;//&nbsp; 统一处理进位问题<br />&nbsp; &nbsp; for( i = 0; i &lt; MAX_LEN * 2; i ++ ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (result[i] &gt;= 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i+1] += result[i] / 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i] %= 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; bool isBeginZero = false;<br />&nbsp; &nbsp; j=0;<br />&nbsp; &nbsp; for (i=n1+n2-1; i&gt;=0; i--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (isBeginZero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; else if (result[i]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isBeginZero = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; if (!isBeginZero)  c[j++]='0';<br />&nbsp; &nbsp; c[j]='\0';<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp;char a[MAX_LEN],b[MAX_LEN],c[2*MAX_LEN];<br />&nbsp; &nbsp; &nbsp;scanf("%s",a);<br />&nbsp; &nbsp; &nbsp;scanf("%s",b);<br />&nbsp; &nbsp; &nbsp;bigNumMul(a,b,c);<br />&nbsp; &nbsp; &nbsp;printf("%s\n",c);<br />&nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p style="margin-left: 30px;">（3）问题扩展。</p>
<p style="margin-left: 30px;">下面我们来讨论如何完成一个大整数a和一个int型整型变量b的相乘。</p>
<p style="margin-left: 30px;">图2给出了753&times;68的另一种计算过程。描述如下：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="./images/高精度计算（二）：大整数乘法1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;1）先依次计算753的各位数字与68的乘积，并存入到result数组的相应单元中。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;2）乘法过程完毕。从 result[0]开始向高位逐位处理进位问题。result[0]留下4，</p>
<p>把20 加到result[1]上，result[1]变为360 后，应留下0，把36 加到result[2]上&hellip;&hellip;最终使<br />得result 里的每个元素都是1 位数，结果就算出来了。&nbsp;</p>
<p><em>&nbsp; &nbsp; &nbsp; &nbsp;</em>按这个思路可以实现一个大整数与int型整型变量相乘。源程序如下：</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MAX_LEN 201<br />void bigNumMul(char a[],int b,char c[])<br />{<br />&nbsp; &nbsp; &nbsp; int i,j,n1,n2,t;<br />&nbsp; &nbsp; &nbsp; int num[MAX_LEN]={0},result[MAX_LEN+10]={0};<br />&nbsp; &nbsp; &nbsp; // 将a和b中存储的字符串形式的整数转换到num1和num2中去，<br />&nbsp; &nbsp; &nbsp; // num1[0]对应于个位、num1[1]对应于十位、&hellip;&hellip;<br />&nbsp; &nbsp; &nbsp; n1 = strlen(a);<br />&nbsp; &nbsp; &nbsp; j = 0;<br />&nbsp; &nbsp; &nbsp; for (i = n1 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num[j++] = a[i] - '0';<br />&nbsp; &nbsp; &nbsp; n2 =0;<br />&nbsp; &nbsp; &nbsp; t=b;<br />&nbsp; &nbsp; &nbsp; do {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n2++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t=t/10;<br />&nbsp; &nbsp; &nbsp; &nbsp;} while (t!=0);<br />&nbsp; &nbsp; &nbsp; &nbsp;for (i=0;i &lt; n1; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i] = num[i]*b; <br />&nbsp; &nbsp; &nbsp; &nbsp;//&nbsp; &nbsp;统一处理进位问题<br />&nbsp; &nbsp; &nbsp; &nbsp;for (i = 0; i &lt; n1+n2; i++) <br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result[i] &gt;= 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i+1] += result[i] / 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i] %= 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; bool isBeginZero = false;<br />&nbsp; &nbsp; &nbsp; j=0;<br />&nbsp; &nbsp; &nbsp; for (i=n1+n2-1; i&gt;=0; i--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isBeginZero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (result[i]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isBeginZero = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;if (!isBeginZero)  c[j++]='0';<br />&nbsp; &nbsp; &nbsp; &nbsp;c[j]='\0';<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; char a[MAX_LEN],c[MAX_LEN+10];<br />&nbsp; &nbsp; &nbsp; &nbsp;int b;<br />&nbsp; &nbsp; &nbsp; scanf("%s",a);<br />&nbsp; &nbsp; &nbsp; &nbsp;scanf("%d",&amp;b);<br />&nbsp; &nbsp; &nbsp; &nbsp;bigNumMul(a,b,c);<br />&nbsp; &nbsp; &nbsp; &nbsp;printf("%s\n",c);<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p>&nbsp;<strong>【例2】Exponentiation&nbsp; （POJ 1001）。</strong></p>
<p><strong>Description</strong></p>
<p>Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems. </p>
<p>This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25.<br /><strong>Input</strong></p>
<p>The input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.<br /><strong>Output</strong></p>
<p>The output will consist of one line for each line of input giving the exact value of R^n. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don't print the decimal point if the result is an integer.<br /><strong>Sample Input</strong></p>
<p>95.123 12<br />0.4321 20<br />5.1234 15<br />6.7592  9<br />98.999 10<br />1.0100 12<br /><strong>Sample Output</strong></p>
<p>548815620517731830194541.899025343415715973535967221869852721<br />.00000005148554641076956121994511276767154838481760200726351203835429763013462401<br />43992025569.928573701266488041146654993318703707511666295476720493953024<br />29448126.764121021618164430206909037173276672<br />90429072743629540498.107596019456651774561044010001<br />1.126825030131969720661201</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 由于输入的R可能是一个小数，因此先求出R的小数点后有多少位小数（pos），然后将小数点去掉，使得R变成一个整数，然后采用例1中的函数void bigNumMul(char a[],char b[],char c[])用循环求得R<sup>n&nbsp;</sup>。之后，在结果中正确插入小数点即可。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MAX_LEN 201<br />void bigNumMul(char a[],char b[],char c[])<br />{<br />&nbsp; &nbsp; &nbsp; int i,j,n1,n2;<br />&nbsp; &nbsp; &nbsp; int num1[MAX_LEN]={0},num2[MAX_LEN]={0},result[2*MAX_LEN]={0};<br />&nbsp; &nbsp; &nbsp; // 将a和b中存储的字符串形式的整数转换到num1和num2中去，<br />&nbsp; &nbsp; &nbsp; // num1[0]对应于个位、num1[1]对应于十位、&hellip;&hellip;<br />&nbsp; &nbsp; &nbsp; n1 = strlen(a);<br />&nbsp; &nbsp; &nbsp; j = 0;<br />&nbsp; &nbsp; &nbsp;for (i = n1 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num1[j++] = a[i] - '0';<br />&nbsp; &nbsp; &nbsp;n2 = strlen(b);<br />&nbsp; &nbsp; &nbsp;j = 0;<br />&nbsp; &nbsp; &nbsp;for (i = n2 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num2[j++] = b[i] - '0';<br />&nbsp; &nbsp; &nbsp;for (i=0;i &lt; n2; i++ )<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=0; j&lt;n1; j++) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i+j] += num2[i]*num1[j];&nbsp;<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;for( i = 0; i &lt; MAX_LEN * 2; i ++ ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result[i] &gt;= 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i+1] += result[i] / 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] %= 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; bool isBeginZero = false;<br />&nbsp; &nbsp; &nbsp; j=0;<br />&nbsp; &nbsp; &nbsp; for (i=n1+n2-1; i&gt;=0; i--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (isBeginZero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (result[i]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isBeginZero = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp;if (!isBeginZero) c[j++]='0';<br />&nbsp; &nbsp; c[j]='\0';<br />}<br />void insertPoint(char s[],int pos,int n)<br />{<br />&nbsp; &nbsp; &nbsp; int  len,i,j; <br />&nbsp; &nbsp; &nbsp; if (pos==0) return;<br />&nbsp; &nbsp; &nbsp; len = strlen(s);<br />&nbsp; &nbsp; &nbsp; if (len&lt;=pos*n)   // 乘积全为小数部分<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s[pos*n+1]='\0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=len-1,j=pos*n;i&gt;=0;i--,j--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[j]=s[i];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=j;i&gt;0;i--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i]='0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s[0]='.';<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; else         // 小数点位于乘积中间<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s[len+1]='\0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=len,j=1; j&lt;=pos*n; i--,j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s[i]=s[i-1];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i]='.';<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; for (i=strlen(s)-1; i&gt;=0; i--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (s[i]=='0')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i] ='\0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;if (s[strlen(s)-1]=='.') s[strlen(s)-1]='\0';<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; char s[MAX_LEN],result[2*MAX_LEN];<br />&nbsp; &nbsp; &nbsp; int n,i,flag,pos,len;<br />&nbsp; &nbsp; &nbsp; while(scanf("%s%d",s,&amp;n)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = strlen(s);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0; i&lt;len;i++) // 寻找小数点位置，并去掉小数点<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(s[i]=='.')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flag = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pos = len - i - 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s[i] = s[i+flag];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;strcpy(result,s);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bigNumMul(result,s,result);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertPoint(result,pos,n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%s\n",result);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p><span style="font-size: 16px;"><strong>【例3】The Idiot of the Year Contest! （POJ 3331）。</strong></span></p>
<p><strong>Description</strong></p>
<p>There is just one basic rule in the Idiot of the Year Contest (IYC)! The contestant picks a random digit between 0 and 9, computes the factorial of the day of the year he/she is born, and counts the how many times the digit picked appears in the factorial. The contestant with highest count is the Idiot of the Year! For example, if you are born on 5th of Mordad which is the 129th day of the year, and you pick the digit 6, your score will be the number of times the digit 6 appears in 129! (that is 1 &times; 2 &times; 3 &times; ... &times; 129).</p>
<p>The chief judge of IYC wants you to write a program to get an integer which is the day of the year a contestant is born on and a digit and report the number of times the digit appears in the factorial of the first number.</p>
<p><strong>Input</strong></p>
<p>The first line of the input contains a single integer T which is the number of test cases, followed by T lines each containing the data for a test case having two numbers. The first number is the day of the year a contestant is born and the second one is the digit he/she has picked.</p>
<p><strong>Output</strong></p>
<p>The output contains T lines, each having one integer which is the number of times the digit appears in the factorial of the first number.</p>
<p><strong>Sample Input</strong></p>
<p>2<br />5 2<br />7 0<br /><strong>Sample Output</strong></p>
<p>1<br />2</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 设输入两个整数day和d，求day的阶乘中有多少个数字d。由于day!可能是一个非常大的数，因此采用大整数乘法。调用例1中的函数void bigNumMul(char a[],int b,char c[])即可。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MAX_LEN 1001<br />void bigNumMul(char a[],int b,char c[])<br />{<br />&nbsp; &nbsp; &nbsp;int i,j,n1,n2,t;<br />&nbsp; &nbsp; &nbsp;int num[MAX_LEN]={0},result[MAX_LEN+10]={0};<br />&nbsp; &nbsp; &nbsp;// 将a和b中存储的字符串形式的整数转换到num1和num2中去，<br />&nbsp; &nbsp; &nbsp;// num1[0]对应于个位、num1[1]对应于十位、&hellip;&hellip;<br />&nbsp; &nbsp; &nbsp;n1 = strlen(a);<br />&nbsp; &nbsp; &nbsp;j = 0;<br />&nbsp; &nbsp; &nbsp;for (i = n1 - 1;i &gt;= 0 ; i --)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num[j++] = a[i] - '0';<br />&nbsp; &nbsp; &nbsp;n2 =0;<br />&nbsp; &nbsp; &nbsp;t=b;<br />&nbsp; &nbsp; &nbsp;do {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n2++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t=t/10;<br />&nbsp; &nbsp; &nbsp;} while (t!=0);<br />&nbsp; &nbsp; &nbsp;for (i=0;i &lt; n1; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[i] = num[i]*b; <br />&nbsp; &nbsp; &nbsp;//   统一处理进位问题<br />&nbsp; &nbsp; &nbsp;for (i = 0; i &lt; n1+n2; i++) <br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (result[i] &gt;= 10)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i+1] += result[i] / 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] %= 10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;bool isBeginZero = false;<br />&nbsp; &nbsp; &nbsp;j=0;<br />&nbsp; &nbsp; &nbsp;for (i=n1+n2-1; i&gt;=0; i--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (isBeginZero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (result[i]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[j++]=result[i]+'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isBeginZero = true;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; if (!isBeginZero) c[j++]='0';<br />&nbsp; &nbsp; c[j]='\0';<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp;char a[MAX_LEN];<br />&nbsp; &nbsp; &nbsp;int t,day,digit,i,cnt;<br />&nbsp; &nbsp; &nbsp;scanf("%d",&amp;t);<br />&nbsp; &nbsp; &nbsp;while (t--)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d%d",&amp;day,&amp;digit);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[0]='1', a[1]='\0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=2;i&lt;=day;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bigNumMul(a,i,a);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=0;a[i]!='\0';i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (a[i]==digit+'0') cnt++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",cnt);<br />&nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>