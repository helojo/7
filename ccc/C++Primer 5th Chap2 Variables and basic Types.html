<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++Primer 5th Chap2 Variables and basic Types' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++Primer 5th Chap2 Variables and basic Types</center></div><div class='banquan'>原文出处:本文由博客园博主Dragonsburg提供。<br/>
原文连接:https://www.cnblogs.com/hfut-freshguy/p/11487218.html</div><br>
    <p>wchar_t,char16_t,char32_t用于拓展字符集</p>
<p>char和signed char并不一样，由编译器决定类型char表现上述两种中的哪一种</p>
<p>一般long的大小和int无二，如果超过int的范围直接使用long long类型</p>
<p>float比较鸡肋，精度和速度都不如double（在某些机器上），所以小数索性都用double</p>
<p>若值超过无符号类型最大值，则获得的实际值=value%MaxValueOfType；若值超过有符号类型最大值，结果无法预知</p>
<p>算数表达式中若存在无符号类型，则其他运算数自动转化为无符号型，造成错误，而且结果也不可能小于0</p>
<p>以0开头表示八进制数，以0x或0X开头表示十六进制数</p>
<p>字符串等价于字符数组（末尾带有编译器赋予的'\0'）,多行表示格式：</p>
<p>　　std::cout&lt;&lt;"a really, really long string literal "</p>
<p>　　　　　　　"that spans two lines."&lt;&lt;std::endl;</p>
<p><strong>转义字符</strong>：</p>
<p>　　换行符：\n　　横向制表符：\t　　响铃符：\a　　纵向制表符：\v　　退格符：\b　　双引号：\"　　反斜线：\\　　问号：\?　　回车符：\r　　进纸符：\f</p>
<p>字面值常量的前缀和后缀：</p>
<p>　　前缀：u 指定类型 char16_t</p>
<p>　　　　　U 指定类型 char32_t</p>
<p>　　　　　L&nbsp; 指定类型 wchar_t</p>
<p>　　　　　u8 指定类型 char（此前缀仅可用于字符串字面值常量，表示UTF-8）</p>
<p>　　后缀:&nbsp; u或U 指定类型 unsigned及更大</p>
<p>　　　　　l或L 指定类型&nbsp; long及更大</p>
<p>　　　　　ll或LL&nbsp; 指定类型&nbsp; long long及更大</p>
<p>　　　　　f或F&nbsp; 指定类型 float（浮点数字面值）</p>
<p>　　　　　l或L 指定类型 long double（浮点数字面值）</p>
<p>初始化的形式也可以是：int i={0};(c++11)　　int i (0);　　int i {0};(c++11)</p>
<p>　　其中的花括号初始化法可以确保不存在数据因转化类型造成的丢失（一旦有丢失的风险就会报错）</p>
<p>基本类型的值如果在函数体之外未被初始化，其值为0；</p>
<p>　　基本类型的值如果在函数体之内未被初始化，其值不可知，任意对此值的访问将引发错误</p>
<p>仅想声明一个变量而不定义它，使用关键字extern: extern int i;(不定义意味着不申请存储空间且不赋予初始值）</p>
<p>此类名字不可用：fuck__drug,&nbsp; &nbsp;_Grug,&nbsp; &nbsp;_drug(函数体外）</p>
<p>允许内层作用域中重新定义外层作用域的名字，反之不可</p>
<p><strong>引用</strong>：（通常指左值引用，c++11引入了右值引用的概念）</p>
<p>　　例如：int ival=1024;</p>
<p>　　　　　int &amp;refVal=ival;(refVal指向ival，认为refVal是ival的一个别名，而且不能再转而指向其他元素，即绑定在一起：你就是我，我就是你）</p>
<p>　　　　　若如：int &amp;refVal2；则发生错误，引用声明后必立即初始化，即指向一个对象（字面值不可）</p>
<p><strong>指针</strong>：（本身即是对象）</p>
<p>　　例如：int *ip1,*ip2;(这里类型是int*，即int型指针，ip1和ip2仅是名字)</p>
<p>　　　　　int *p=&amp;ival;(获取ival的地址赋予p，p存放ival的地址）</p>
<p>　　　　　int ivalValue=*p(使用解引用符*能访问对象)</p>
<p>　　　　　*p=100;(此举使得ival的值为100,&nbsp; &nbsp;指针指向了对象，也就获得了对对象的操作权)</p>
<p>　　　　　int *p3=nullptr;(c++11)(等效于int *p3=0;等效于int *p3=NULL;p3为空指针，不指向任何对象）</p>
<p><strong>void*指针</strong>：（可用于存放任意对象的地址，然而不能利用void*指针直接访问对象）</p>
<p><strong>指向指针的<span style="text-decoration: underline;">引用</span></strong>：int *&amp;r=p;(修饰符从右往左读）</p>
<p><strong>const限定符</strong>：</p>
<p>　　例如：const int buffSize=512;(由于const的修饰，之后禁止再对buffSize赋值）</p>
<p>　　　　　<span style="color: #ff0000;">const int conExp;</span>（此表达式不合法，必须初始化）</p>
<p><span style="color: #000000;">　　默认const对象仅在文件内有效，若希望const对象也能在其他文件中使用，则加上extern关键字：</span></p>
<p><span style="color: #000000;">　　　　　<strong>extern</strong> const int bufSize=fcn();<br /></span></p>
<p>　　　　　其他文件调用时：extern const int bufSize;</p>
<p>　　对常量的引用必须也是常量，自然地，其值不能变更：</p>
<p>　　　　　<strong>const</strong> int &amp;bufSize1=buffSize;</p>
<p>　　然而对一般量的引用也可以是常量,只是不能再通过此常量引用修改其值：</p>
<p>　　　　　int i=12;　　const int &amp;integ=i;　　　　　</p>
<p>&nbsp;　　类似地，也有指向常量的指针，用来存放常量的地址而无法通过指针进行更改，而且此种指针可以指向一般量，但也不能借此指针更改其值：</p>
<p>　　　　　const int *ptr=&amp;buffSize;</p>
<p>　　　　　const int *prt1=&amp;i;</p>
<p>　　与一般对象一样，指针自身也可以是常量（除去指针本身的性质外，其常量的特性与一般常量无二）：</p>
<p>　　　　　int *const ptr2=&amp;i;</p>
<p>　　　　　const int *const ptr3=&amp;buffSize;</p>
<p>　　　　　(注意，这里第一个const（即底层const）使得ptr3<strong>能够</strong>指向常量buffSize,而第二个const（即顶层const）则决定指针自身即为常量）</p>
<p><strong>constexpr和常量表达式</strong>：</p>
<p>　　　const int A=20;(等号的左边和右边都必须是const值才是常量表达式）</p>
<p>　　　声明为constexpr的变量必定是常量而且仅能通过常量表达式进行初始化,而且constexpr指针只能指向地址固定的对象或nullptr</p>
<p>　　　　constexpr int mf=20;(c++11)</p>
<p><strong>定义类型别名typedef</strong>:</p>
<p>　　　例如：typedef double wages；（wages是double的同义名）</p>
<p>　　　　　　typedef wages bunble，*p；（bunble是double的同义名，p是double*的同义名）</p>
<p>　　　　　　<strong>(注意：const p *p1=0；表示p1是常量指针（顶层常量），const double *p2=&amp;i;表示p2是指向常量的指针（底层常量））</strong></p>
<p>　　　也可以: using SI=Sales_items;(c++11)(SI是Sales_items的同义名）</p>
<p><strong>auto类型说明符</strong>：（c++11）（让编译器分析所属的类型）</p>
<p>　　　例如：auto item=val1+val2;</p>
<p>　　　　　　<span style="color: #ff0000;">auto sz=0,pi=3.14;</span>(不可行，一条语句只能是一种类型）</p>
<p>　　　　　　auto *p1=&amp;i,&amp;prf=i;(注意将*，&amp;连结在声明符上）</p>
<p>　　　<span style="color: #000000;">（注意：auto会忽略顶层const，如果强调顶层const则需要明示：<strong>const</strong> auto f=ci；）</span></p>
<p><strong>decltype类型指示符</strong>：（c++11）</p>
<p>　　　例如：decltype( f ( ) ) sum = x;(sum的类型为f()的类型）</p>
<p>　　　　　　decltype(*p) p2=i;(*p<strong>解引用后的类型是int&amp;</strong>,故必须初始化）</p>
<p>　　　　　　decltype( ( i ) ) p3=j;(<strong>多一层括号后的类型是int&amp;</strong>）</p>
<p>c++11允许为数据成员提供类内初始值　</p>
<p><strong>预处理器可以使头文件多次包含仍能正常工作</strong>：</p>
<p>　　#ifndef SALES_DATA_H</p>
<p>　　#define SALES_DATA_H</p>
<p>　　/*........*/</p>
<p>　　#endif</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>