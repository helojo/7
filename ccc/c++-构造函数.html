<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修c++-构造函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>c++-构造函数</center></div><div class='banquan'>原文出处:本文由博客园博主跌倒的小黄瓜提供。<br/>
原文连接:https://www.cnblogs.com/ygjzs/p/12076497.html</div><br>
    <h2 id="构造函数">构造函数</h2>
<ul>
<li>构造和析构概念语法</li>
<li>构造函数的分类</li>
<li>有参构造函数3种调用方法</li>
<li>拷贝构造函数4种调用时机
<ul>
<li>场景1和2：A a(b); A a = b;</li>
<li>场景3：形参是一个元素，实参传递给形参</li>
<li>场景4：函数返回值返回一个元素，匿名对象</li>
<li>匿名对象的去和留</li>
<li>对象的初始化 和 对象的=操作 是两个不同的概念</li>
</ul></li>
<li>构造和析构
<ul>
<li>构造和析构概念语法</li>
<li>构造函数的分类</li>
<li>有参构造函数3种调用方法</li>
<li>拷贝构造函数4种调用时机
<ul>
<li>场景1和2：A a(b); A a = b;</li>
<li>场景3：形参是一个元素，实参传递给形参</li>
<li>场景4：函数返回值返回一个元素，匿名对象</li>
<li>匿名对象的去和留</li>
<li>对象的初始化 和 对象的=操作 是两个不同的概念</li>
</ul></li>
<li>构造函数调用规则研究（写了构造函数则必须调用）</li>
<li>多个对象的构造 构造函数初始化列表</li>
<li>构造函数和析构函数的调用顺序（先组合对象的构造、自己构造；析构和构造相反）</li>
<li>深拷贝和浅拷贝
<ul>
<li>问题抛出 显示的编写拷贝构造函数</li>
<li>默认的=号操作 也是浅拷贝，解决方案重载=操作符</li>
<li>总结：C++编译给提供的默认的拷贝构造和=操作都是浅拷贝</li>
</ul></li>
<li>构造和析构综合练习
<ul>
<li>匿名对象：直接调用构造函数</li>
<li>匿名对象：构造中调用构造</li>
</ul></li>
</ul></li>
<li>构造函数调用规则研究（写了构造函数则必须调用）</li>
<li>多个对象的构造 构造函数初始化列表</li>
<li>构造函数和析构函数的调用顺序（先组合对象的构造、自己构造；析构和构造相反）</li>
<li>深拷贝和浅拷贝
<ul>
<li>问题抛出 显示的编写拷贝构造函数</li>
<li>默认的=号操作 也是浅拷贝，解决方案重载=操作符</li>
<li>总结：C++编译给提供的默认的拷贝构造和=操作都是浅拷贝</li>
</ul></li>
</ul>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;string.h&gt;


using namespace std;

class Test
{
public:
#if 0
    void init(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
#endif

    //test类的构造函数
    //在对象被创建的时候，用来初始化对象的函数
    Test()//无参数的构造函数
    {
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        m_x = x;
        m_y = y;
        // name = (char*)malloc(100);
        strcpy(name, &quot;zhang3&quot;);
    }
    Test(int x)
    {
        m_x = x;
        m_y = 0;
    }

    void printT()
    {
        cout &lt;&lt; &quot;x = &quot; &lt;&lt; m_x &lt;&lt; &quot;  y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }


    //析构函数和构造函数都没有返回值，
    //析构函数没有形参
    ~Test() {
        cout &lt;&lt; &quot;~Test()....&quot; &lt;&lt; endl;
        if (name != NULL) {
            // free(name);
            cout &lt;&lt; &quot;free succ!&quot; &lt;&lt; endl;
        }
    }
private:
    int m_x;
    int m_y;
    char *name;
};

void test1()
{
    Test t1(10, 20);
    t1.printT();

    //在一个对象临死之前，要自定调用析构函数
}

int main(void)
{
#if 0
    Test t1(10, 20);
    t1.printT();
    //t1.init(10, 20);

    Test t2(100);
    t2.printT();

    Test t3;//就是调用类的无参数构造函数

    t3.printT();

#endif

    test1();
    return 0;
}
</code></pre>
<h2 id="拷贝构造函数">拷贝构造函数</h2>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Test
{
public:
    Test()
    {
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        m_x = x;
        m_y = y;
    }

    void printT()
    {
        cout &lt;&lt; &quot;x =&quot; &lt;&lt; m_x &lt;&lt; &quot;, y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }

#if 1
    //显示的拷贝构造函数
    Test(const Test &amp;another)
    {
        cout &lt;&lt; &quot;Test(const Test &amp;)...&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }
#endif
#if 0
    //? 会有一个默认的拷贝构造函数
    Test(const Test &amp;another)
    {
        m_x = another.m_x;
        m_y = another.m_y;
    }
#endif

    //=赋值操作符
    void operator=(const Test &amp;another)
    {
        m_x = another.m_x;
        m_y = another.m_y;
    }
private:
    int m_x;
    int m_y;
};

int main(void)
{
    Test t1(100, 200); 

    Test t2(t1); 

    t2.printT();



    //构造函数是对象初始化的时候调用
    Test t3; //依然是初始化t3的时候调用t3构造函数，依然是调用t3的拷贝构造函数

    t3 = t1; //调用的不是t3拷贝构造函数，而是t3的赋值操作符函数

    return 0;
}</code></pre>
<h2 id="默认的构造函数和解析构造函数">默认的构造函数和解析构造函数</h2>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Test
{
public:
    //默认的无参构造函数
#if 0
    Test()
    {

    }
#endif
    //显示提供一个有参数的构造函数，默认的构造函数就不复存在
    Test(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
    Test() {
        m_x = 0;
        m_y = 0;
    }

    void printT()
    {
        cout &lt;&lt; &quot;x = &quot; &lt;&lt; m_x &lt;&lt; &quot;  y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }

    //默认的析构函数
#if 0
    ~Test()
    {

    }
#endif
    ~Test() {
        cout &lt;&lt; &quot;~Test()...&quot; &lt;&lt; endl;
    }


private:
    int m_x;
    int m_y;
};

int main(void)
{
    Test t1;//调用Test无参构造
    t1.printT();
    
    return 0;
}</code></pre>
<h2 id="默认的拷贝构造函数">默认的拷贝构造函数</h2>
<ul>
<li>类中 会有个默认的无参构造函数：</li>
</ul>
<p>当没有任何<strong><em>显示的构造函数（显示的无参构，显示有参，显示拷贝构造）</em></strong> 的时候，默认无参构造函数就会出现。</p>
<ul>
<li><p>会有默认的拷贝构造函数：<br />
--&gt;当没有 <strong>显示的拷贝构造 </strong>* 的函数，默认的拷贝构造就会出现。</p></li>
<li><p>会有默认的析构函数<br />
--&gt; 当没有<strong><em>显示的析构函数</em></strong>的时候， 默认的析构函数就会出现</p></li>
</ul>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;

using namespace std;

class A
{
public:
#if 0
    A()
    {
        
    }
#endif
#if 0
    A(const A &amp;another)
    {
        m_a = another.m_a;
        m_b = another.m_b;
    }
#endif
    A()
    {

    }
    A(int a, int b)
    {

    }
#if 0
    ~A()
    {

    }
#endif
    ~A()
    {
        cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl;
    }
private:
    int m_a;
    int m_b;
};

//类中 会有个默认的无参构造函数：  、
//      --&gt;当没有任何***显示的构造函数（显示的无参构，显示有参，显示拷贝构造）*** 的时候，默认无参构造函数就会出现。

//      会有默认的拷贝构造函数：
//      --&gt;当没有 **显示的拷贝构造 ***  的函数，默认的拷贝构造就会出现。

//     会有默认的析构函数
//      --&gt; 当没有***显示的析构函数***的时候，  默认的析构函数就会出现。


int main(void)
{
    A a;
    
    A a1(a);
    
    return 0;
}</code></pre>
<h2 id="拷贝构造函数的应用场景">拷贝构造函数的应用场景</h2>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;

using namespace std;

class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;test()...&quot; &lt;&lt; endl;
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        cout &lt;&lt; &quot;Test(int x, int y)...&quot; &lt;&lt; endl;

        m_x = x;
        m_y = y;
    }
    Test(const Test &amp; another)
    {
        cout &lt;&lt; &quot;Test(const Test &amp;)...&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void operator=(const Test &amp;another)
    {
        cout &lt;&lt; &quot;operatoer = (const Test &amp;)&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void printT() {
        cout &lt;&lt; &quot;x = &quot; &lt;&lt; m_x &lt;&lt; &quot;, m_y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }

    ~Test() {
        cout &lt;&lt; &quot;~Test()...&quot; &lt;&lt; endl;
    }
private:
    int m_x;
    int m_y;
};


//析构函数调用的顺序， 跟构造相反， 谁先构造的，谁后析构。
//场景1
void test1()
{
    Test t1(10, 20);
    Test t2(t1);//Test t2 = t1;
}

//场景2
void test2()
{
    Test t1(10, 20);
    Test t2;

    t2 = t1;//=操作符
}


void func(Test t)//Test t = t1; //Test t 的拷贝构造函数
{
    cout &lt;&lt; &quot;func begin...&quot; &lt;&lt; endl;
    t.printT();
    cout &lt;&lt; &quot;func end...&quot; &lt;&lt; endl;
}

//场景3
void test3()
{
    cout &lt;&lt; &quot;test3 begin...&quot; &lt;&lt; endl;
    Test t1(10, 20);

    func(t1);

    cout &lt;&lt; &quot;test3 end...&quot; &lt;&lt; endl;
}


//场景4
Test func2()
{
    cout &lt;&lt; &quot;func2 begin...&quot; &lt;&lt; endl;
    Test temp(10, 20);
    temp.printT();

    cout &lt;&lt; &quot;func2 end...&quot; &lt;&lt; endl;

    return temp;
}//匿名的对象 = temp  匿名对象.拷贝构造(temp)

void test4()
{
    cout &lt;&lt; &quot;test4 being.. &quot; &lt;&lt; endl;
    func2();// 返回一个匿名对象。 当一个函数返回一个匿名对象的时候，函数外部没有任何
            //变量去接收它， 这个匿名对象将不会再被使用，（找不到）， 编译会直接将个这个匿名对象
            //回收掉，而不是等待整改函数执行完毕再回收.
    //匿名对象就被回收。
    
    cout &lt;&lt; &quot;test4 end&quot; &lt;&lt; endl;
}

void test5()
{
    cout &lt;&lt; &quot;test 5begin.. &quot; &lt;&lt; endl;
    Test t1 = func2(); //会不会触发t1拷贝构造来   t1.拷贝(匿名）？
                        //并不会触发t1拷贝，而是 将匿名对象转正 t1，
                        //把这个匿名对象 起了名字就叫t1.

    cout &lt;&lt; &quot;test 5 end..&quot; &lt;&lt; endl;
}

//场景6
void test6()
{
    cout &lt;&lt; &quot;test6 begin...&quot; &lt;&lt; endl;
    Test t1;//t1已经被初始化了。

    t1 = func2(); //t1已经被初始化了，所以func2返回的匿名对象不会再次转正，而依然是匿名对象。
                    //所以t1会调用等号操作符，t1.operator=(匿名对象), 然后编译器会立刻回收掉匿名对象

    t1.printT();

    cout &lt;&lt; &quot;test6 end..&quot; &lt;&lt; endl;
}


int main(void)
{
    //test1();
    //test2();
    //test3();
    //test4();
    //test5();
    test6();

    return 0;
}</code></pre>
<h2 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h2>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;

using namespace std;

class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;test()...&quot; &lt;&lt; endl;
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        cout &lt;&lt; &quot;Test(int x, int y)...&quot; &lt;&lt; endl;

        m_x = x;
        m_y = y;
    }
    Test(const Test &amp; another)
    {
        cout &lt;&lt; &quot;Test(const Test &amp;)...&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void operator=(const Test &amp;another)
    {
        cout &lt;&lt; &quot;operatoer = (const Test &amp;)&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void printT() {
        cout &lt;&lt; &quot;x = &quot; &lt;&lt; m_x &lt;&lt; &quot;, m_y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }

    ~Test() {
        cout &lt;&lt; &quot;~Test()...&quot; &lt;&lt; endl;
    }
private:
    int m_x;
    int m_y;
};


//析构函数调用的顺序， 跟构造相反， 谁先构造的，谁后析构。
//场景1
void test1()
{
    Test t1(10, 20);
    Test t2(t1);//Test t2 = t1;
}

//场景2
void test2()
{
    Test t1(10, 20);
    Test t2;

    t2 = t1;//=操作符
}


void func(Test t)//Test t = t1; //Test t 的拷贝构造函数
{
    cout &lt;&lt; &quot;func begin...&quot; &lt;&lt; endl;
    t.printT();
    cout &lt;&lt; &quot;func end...&quot; &lt;&lt; endl;
}

//场景3
void test3()
{
    cout &lt;&lt; &quot;test3 begin...&quot; &lt;&lt; endl;
    Test t1(10, 20);

    func(t1);

    cout &lt;&lt; &quot;test3 end...&quot; &lt;&lt; endl;
}


//场景4
Test func2()
{
    cout &lt;&lt; &quot;func2 begin...&quot; &lt;&lt; endl;
    Test temp(10, 20);
    temp.printT();

    cout &lt;&lt; &quot;func2 end...&quot; &lt;&lt; endl;

    return temp;
}//匿名的对象 = temp  匿名对象.拷贝构造(temp)

void test4()
{
    cout &lt;&lt; &quot;test4 being.. &quot; &lt;&lt; endl;
    func2();// 返回一个匿名对象。 当一个函数返回一个匿名对象的时候，函数外部没有任何
            //变量去接收它， 这个匿名对象将不会再被使用，（找不到）， 编译会直接将个这个匿名对象
            //回收掉，而不是等待整改函数执行完毕再回收.
    //匿名对象就被回收。
    
    cout &lt;&lt; &quot;test4 end&quot; &lt;&lt; endl;
}

void test5()
{
    cout &lt;&lt; &quot;test 5begin.. &quot; &lt;&lt; endl;
    Test t1 = func2(); //会不会触发t1拷贝构造来   t1.拷贝(匿名）？
                        //并不会触发t1拷贝，而是 将匿名对象转正 t1，
                        //把这个匿名对象 起了名字就叫t1.

    cout &lt;&lt; &quot;test 5 end..&quot; &lt;&lt; endl;
}

//场景6
void test6()
{
    cout &lt;&lt; &quot;test6 begin...&quot; &lt;&lt; endl;
    Test t1;//t1已经被初始化了。

    t1 = func2(); //t1已经被初始化了，所以func2返回的匿名对象不会再次转正，而依然是匿名对象。
                    //所以t1会调用等号操作符，t1.operator=(匿名对象), 然后编译器会立刻回收掉匿名对象

    t1.printT();

    cout &lt;&lt; &quot;test6 end..&quot; &lt;&lt; endl;
}


int main(void)
{
    //test1();
    //test2();
    //test3();
    //test4();
    //test5();
    test6();

    return 0;
}</code></pre>
<h2 id="构造函数的初始化列表">构造函数的初始化列表</h2>
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;

using namespace std;

class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;test()...&quot; &lt;&lt; endl;
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        cout &lt;&lt; &quot;Test(int x, int y)...&quot; &lt;&lt; endl;

        m_x = x;
        m_y = y;
    }
    Test(const Test &amp; another)
    {
        cout &lt;&lt; &quot;Test(const Test &amp;)...&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void operator=(const Test &amp;another)
    {
        cout &lt;&lt; &quot;operatoer = (const Test &amp;)&quot; &lt;&lt; endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }

    void printT() {
        cout &lt;&lt; &quot;x = &quot; &lt;&lt; m_x &lt;&lt; &quot;, m_y = &quot; &lt;&lt; m_y &lt;&lt; endl;
    }

    ~Test() {
        cout &lt;&lt; &quot;~Test()...&quot; &lt;&lt; endl;
    }
private:
    int m_x;
    int m_y;
};


//析构函数调用的顺序， 跟构造相反， 谁先构造的，谁后析构。
//场景1
void test1()
{
    Test t1(10, 20);
    Test t2(t1);//Test t2 = t1;
}

//场景2
void test2()
{
    Test t1(10, 20);
    Test t2;

    t2 = t1;//=操作符
}


void func(Test t)//Test t = t1; //Test t 的拷贝构造函数
{
    cout &lt;&lt; &quot;func begin...&quot; &lt;&lt; endl;
    t.printT();
    cout &lt;&lt; &quot;func end...&quot; &lt;&lt; endl;
}

//场景3
void test3()
{
    cout &lt;&lt; &quot;test3 begin...&quot; &lt;&lt; endl;
    Test t1(10, 20);

    func(t1);

    cout &lt;&lt; &quot;test3 end...&quot; &lt;&lt; endl;
}


//场景4
Test func2()
{
    cout &lt;&lt; &quot;func2 begin...&quot; &lt;&lt; endl;
    Test temp(10, 20);
    temp.printT();

    cout &lt;&lt; &quot;func2 end...&quot; &lt;&lt; endl;

    return temp;
}//匿名的对象 = temp  匿名对象.拷贝构造(temp)

void test4()
{
    cout &lt;&lt; &quot;test4 being.. &quot; &lt;&lt; endl;
    func2();// 返回一个匿名对象。 当一个函数返回一个匿名对象的时候，函数外部没有任何
            //变量去接收它， 这个匿名对象将不会再被使用，（找不到）， 编译会直接将个这个匿名对象
            //回收掉，而不是等待整改函数执行完毕再回收.
    //匿名对象就被回收。
    
    cout &lt;&lt; &quot;test4 end&quot; &lt;&lt; endl;
}

void test5()
{
    cout &lt;&lt; &quot;test 5begin.. &quot; &lt;&lt; endl;
    Test t1 = func2(); //会不会触发t1拷贝构造来   t1.拷贝(匿名）？
                        //并不会触发t1拷贝，而是 将匿名对象转正 t1，
                        //把这个匿名对象 起了名字就叫t1.

    cout &lt;&lt; &quot;test 5 end..&quot; &lt;&lt; endl;
}

//场景6
void test6()
{
    cout &lt;&lt; &quot;test6 begin...&quot; &lt;&lt; endl;
    Test t1;//t1已经被初始化了。

    t1 = func2(); //t1已经被初始化了，所以func2返回的匿名对象不会再次转正，而依然是匿名对象。
                    //所以t1会调用等号操作符，t1.operator=(匿名对象), 然后编译器会立刻回收掉匿名对象

    t1.printT();

    cout &lt;&lt; &quot;test6 end..&quot; &lt;&lt; endl;
}


int main(void)
{
    //test1();
    //test2();
    //test3();
    //test4();
    //test5();
    test6();

    return 0;
}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>