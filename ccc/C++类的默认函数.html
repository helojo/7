<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++类的默认函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++类的默认函数</center></div><div class='banquan'>原文出处:本文由博客园博主KeepHopes提供。<br/>
原文连接:https://www.cnblogs.com/yuwanxian/p/10924835.html</div><br>
    <p>　　在C++中，一个类有八个默认函数：</p>
<ol>
<li><span style="font-family: 'Microsoft YaHei';">默认构造函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认拷贝构造函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认析构函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认重载赋值运算符函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认重载取址运算符函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认重载取址运算符const函数；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认移动构造函数（C++11）；</span></li>
<li><span style="font-family: 'Microsoft YaHei';">默认重载移动赋值操作符函数（C++11）。</span></li>
</ol>
<p>&nbsp;　&nbsp; 只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个默认拷贝构造函数、一个默认重载赋值操作符函数和一个默认析构函数。这些函数只有在第一次被调用时，才会被编译器创建，当然这几个生成的默认函数的实现就是什么都不做。所有这些函数都是inline和public的。</p>
<p>　　我们不希望对象被显示构造（单列模式）或赋值，可以将对应函数声明为private，或者写一个基类，开放部分默认函数，子类去继承就可以了。C++11新增标识符default和delete,控制这些默认函数是否使用。</p>
<p>　　default：被标识的默认函数将使用类的默认行为，如：A() = default;</p>
<p>　　delete：被标识的默认函数将禁用，如：A() = delete;<code><br /></code></p>
<p>&nbsp;　&nbsp; override：被标识的函数需要强制重写基类虚函数；</p>
<p>　&nbsp; &nbsp;final：被标识的函数禁止重写基类虚函数；</p>
<div>
<div class="cnblogs_code">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> A
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">{
</span><span style="color: #008080;"> 3</span> <span style="color: #0000ff;">public</span><span style="color: #000000;">:
</span><span style="color: #008080;"> 4</span> 
<span style="color: #008080;"> 5</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认构造函数;</span>
<span style="color: #008080;"> 6</span> <span style="color: #000000;">    A();
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认拷贝构造函数</span>
<span style="color: #008080;"> 9</span>     A(<span style="color: #0000ff;">const</span> A&amp;<span style="color: #000000;">);
</span><span style="color: #008080;">10</span> 
<span style="color: #008080;">11</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认析构函数</span>
<span style="color: #008080;">12</span>     ~<span style="color: #000000;">A();
</span><span style="color: #008080;">13</span> 
<span style="color: #008080;">14</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认重载赋值运算符函数</span>
<span style="color: #008080;">15</span>     A&amp; <span style="color: #0000ff;">operator</span> = (<span style="color: #0000ff;">const</span> A&amp;<span style="color: #000000;">);
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认重载取址运算符函数</span>
<span style="color: #008080;">18</span>     A* <span style="color: #0000ff;">operator</span> &amp;<span style="color: #000000;"> ();
</span><span style="color: #008080;">19</span> 
<span style="color: #008080;">20</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认重载取址运算符const函数</span>
<span style="color: #008080;">21</span>     <span style="color: #0000ff;">const</span> A* <span style="color: #0000ff;">operator</span> &amp; () <span style="color: #0000ff;">const</span><span style="color: #000000;">;
</span><span style="color: #008080;">22</span> 
<span style="color: #008080;">23</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认移动构造函数</span>
<span style="color: #008080;">24</span>     A(A&amp;&amp;<span style="color: #000000;">);
</span><span style="color: #008080;">25</span> 
<span style="color: #008080;">26</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 默认重载移动赋值操作符</span>
<span style="color: #008080;">27</span>     A&amp; <span style="color: #0000ff;">operator</span> = (<span style="color: #0000ff;">const</span> A&amp;&amp;<span style="color: #000000;">);
</span><span style="color: #008080;">28</span> 
<span style="color: #008080;">29</span> };</pre>
</div>
<p>　　下面就每个函数分别详细讨论学习，有不对之处，欢迎评论指正，您的批评指正就是在下前进的不竭动力！</p>
<h2>一、构造函数（Constructor）</h2>
<p>1.构造函数作用是对对象进行初始化，在堆上new一个对象或在栈上定义一个临时对象时，会自动调用对象的构造函数。有<strong>初始化列表</strong>和<strong>构造函数体内赋值</strong>两种方式，初始化列表在初始化对象时更高效（每个成员在初始化列表中只能出现一次），减少了一次赋值操作，推荐此方法；以下成员变量必须在初始化列表中初始化：<strong>常量成员变量</strong>、<strong>引用类型成员变量</strong>、<strong>没有缺省构造函数的成员变量</strong>（如果构造函数的参数列表中有一个类的对象，并且该对象的类里没有缺省参数的构造函数时，要是不使用初始化列表，参数中会调用无参或者全缺省的构造函数，而那个类中又没有）；</p>
<p>2.函数名与类名相同，可以重载，不能为虚函数，不能有返回值，连void也不行；</p>
<p>3.如果没有显式定义，编译器会自动生成一个默认的构造函数，默认的构造函什么都不会做；</p>
<p>4.无参构造函数和带有缺省值的构造函数（全缺省）都认为是缺省的构造函数，并且缺省的构造函数只能有一个；</p>
<p>5.函数体内可以使用this指针，但不可以用于初始化列表。因为构造函数只是初始化对象，初始化之前此对象已经存在了，所以可以有this，函数体里面是进行赋值，初始化列表是对类中的各个成员变量进行初始化，初始化的位置对象不完整，所以不能使用this用于初始化列表；</p>
<p>6.对于出现单参数的构造函数需要注意，C++会默认将参数对应的类型转换为该类类型，有时候这种隐式的转换是我们不想要的，需要使用explicit关键字来限制这种转换；</p>
<p>7.构造顺序：虚拟基类的构造函数（如果有多个虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；</p>
<p>　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;非虚拟基类的构造函函（如果有多个非虚拟基类，按照它们被继承的顺序构造，而不是它们在成员初始化列表中的顺序）；<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;成员对象的构造函数（如果有多个成员类对象，按照它们声明的顺序调用，而不是它们在成员初始化列表中的顺序）；<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;本类构造函数。构造的过程是递归的。</p>
<h2>二、拷贝构造函数（Copy Constructor）</h2>
<p>1.拷贝构造函数实际上是构造函数的重载，具有一般构造函数的所有特性，用此类已有的对象创建一个新的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。用类的一个已知的对象去初始化该类的另一个对象时，会自动调用对象的拷贝构造函数；</p>
<p>2.函数名与类名相同，第一个参数是对某个同类对象的引用，且没有其他参数或其他参数都有默认值，返回值是类对象的引用，通过返回引用值可以实现连续构造，即类似A(B(C))这样；</p>
<p>3.如果没有显式定义，编译器会自动生成一个默认的拷贝构造函数，默认的拷贝构造函数会依次拷贝类的数据成员完成初始化；</p>
<p>4.浅拷贝和深拷贝：编译器创建的默认拷贝构造函数只会执行"浅拷贝"，也就是通过赋值完成，如果该类的数据成员中有指针成员，也只是地址的拷贝，会使得新的对象与拷贝对象该指针成员指向的地址相同，delete该指针时则会导致两次重复delete而出错，如果指针成员是new出来就是&ldquo;深拷贝&rdquo;。</p>
<h2>三、析构函数（Destructor）</h2>
<p>1.析构函数作用是做一些清理工作，delete一个对象或对象生命周期结束时，会自动调用对象的析构函数；</p>
<p>2.函数名在类名前加上字符~，没有参数（可以有void类型的参数），也没有返回值，可以为虚函数（通过基类的指针去析构子类对象时候），不能重载，故析构函数只有一个；</p>
<p>3.如果没有显式定义，编译器会自动生成一个默认的析构函数，默认的析构函什么都不会做；</p>
<p>4.析构顺序：和构造函数顺序相反。析构的过程也是递归的。</p>
<h2>四、重载赋值运算符函数（Copy Assignment operator）</h2>
<p>1.它是两个已有对象，一个给另一个赋值的过程。当两个对象之间进行赋值时，会自动调用重载赋值运算符函数，它不同于拷贝构造函数，拷贝构造函数是用已有对象给新生成的对象赋初值的过程；</p>
<p>2.赋值运算符重载函数参数中const和&amp;没有强制要求，返回值是类对象的引用，通过返回引用值可以实现连续赋值，即类似a=b=c这样，返回值类型也不是强制的，可以返回void，使用时就不能连续赋值；</p>
<p>3.赋值运算符重载函只能定义为类的成员函数，不能是静态成员函数，也不能是友元函数，赋值运算符重载函数不能被继承，要避免自赋值；</p>
<p>4.如果没有显式定义，编译器会自动生成一个默认的赋值运算符重载函数，默认的赋值运算符重载函数实现将数据成员逐一赋值的一种浅拷贝，会导致指针悬挂问题。</p>
<h2>五、重载取址运算符（const）函数</h2>
<p>1.重载取址运算符函数没有参数；</p>
<p>2.如果没有显式定义，编译器会自动生成默认的重载取址运算符函数，函数内部直接return this，一般使用默认即可。</p>
<h2>六、移动构造函数和重载移动赋值操作符函数</h2>
<p>1.C++11 新增move语义：源对象资源的控制权全部交给目标对象，可以将原对象移动到新对象，&nbsp;用于a初始化b后，就将a析构的情况；</p>
<p>2.移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用；</p>
<p>3.临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候就可以使用移动构造。移动构造可以减少不必要的复制，带来性能上的提升。</p>
<h2>七、讨论</h2>
<p>1.构造函数为什么不能有返回值？</p>
<p>&nbsp; (1).C++语言规定构造函数没有返回值；</p>
<p>&nbsp; (2).构造函数不作为右值使用，返回值也没有用；</p>
<p>&nbsp; (3).就算有返回值，从基本语义角度来讲，也应该返回的是所构造的对象，所以没必要多此一举来指定返回类型了；</p>
<p>&nbsp; (4).假如有返回值，讨论下面代码</p>
<div style="margin-left: 30px;">class A</div>
<div style="margin-left: 30px;">{</div>
<div style="margin-left: 30px;">public:</div>
<div style="margin-left: 60px;">A():m_iTest(0) { }</div>
<div style="margin-left: 60px;">A(int i):m_iTest(i) {&nbsp;}</div>
<div style="margin-left: 30px;">private:</div>
<div style="margin-left: 60px;">int m_iTest;</div>
<div style="margin-left: 30px;">};</div>
<p>　　按照C++的规定，A a = A();是用默认构造函数创建一个临时对象，并用这个临时对象初始化a，此时，a.m_iTest的值应该是0。现在如果A::A()有返回值，并且返回了1（表示构造成功），则C++会用1去初始化a，即调用有参数构造函数A::A(int i)，得到的a.m_iTest便会是1。于是，语义产生了歧义，使得C++原本已经非常复杂的语法，进一步混乱不堪。</p>
<div>　　构造函数的调用之所以不设返回值，是因为构造函数的特殊性决定的。当然，上面的讨论，也是基于C++语言规定，如果规定构造函数可以有返回值，上面用法也许就不一样了。是先有鸡还是先有蛋，这是一个神奇的问题。总之，现在C++语法体系是这样的，如果设计构造函数可以有返回值，可能整个C++语言更难实现了。</div>
<p>2.对象创建和销毁过程是怎样的？</p>
<p>&nbsp; <strong>对象创建（new）过程：</strong></p>
<p>&nbsp; (1).通过operator new申请内存；<br />&nbsp; (2).使用placement new调用构造函数（简单类型忽略此步）；<br />&nbsp; (3).返回内存指针。</p>
<p>&nbsp; <strong>new和malloc的比较：</strong></p>
<p>&nbsp; (1).new失败时会调用new_handler处理函数,malloc不会,失败时返回NULL；<br />&nbsp; (2).new能通过placement new自动调用对象的构造函数，malloc不会；<br />&nbsp; (3).new出来的东西是带类型的，malloc是void*，需要强制转换；<br />&nbsp; (4).new是C++运算符，malloc是C标准库函数。</p>
<p>&nbsp; <strong>new的三种形态：new operator，operator new，placement new</strong></p>
<p>&nbsp; (1).new operator：上面所说的new就是new operator，共有三个步骤组成（申请内存，调用构造函数，返回内存指针），对于申请内存步骤是通过运算符new(operator new)完成的，对于调用什么构造函数，可以由placement new决定；</p>
<p>&nbsp; (2).operator new：像普通运算符一样可以被重载，operator new会去申请内存，申请失败的时候会调用new_handler处理，这是一个循环的过程，如果new_handler不抛出异常，会一直循环申请内存，直到成功；</p>
<p>&nbsp; (3).placement new：用于定位构造函数，在指定的内存地址上用指定类型的构造函数构造对象。</p>
<p>&nbsp; <strong>对象销毁（delete）过程：</strong></p>
<p>&nbsp; (1).调用析构函数（简单类型忽略此步）；</p>
<p>&nbsp; (2).释放内存。</p>
<p><strong>&nbsp; delete和free比较</strong></p>
<p>&nbsp; (1).delete能自动调用对象的析构函数，free不会；<br />&nbsp; (2).delete是C++运算符，free是C标准库函数。</p>
<p>3.拷贝构造函数参数为什么必须使用类类型对象引用传递？</p>
<p>　传参的位置如果一直调用拷贝构造函数，也就是会递归引用，导致栈溢出。</p>
<p>4.赋值运算符重载函数为什么要避免自赋值？</p>
<p>　(1).提高效率。自赋值无意义，如果自赋值，可以立即return *this；</p>
<p>&nbsp; &nbsp;(2).如果不避免，当类的数据成员中如果含有指针，自赋值时会造成内存泄漏。</p>
<p>&nbsp;</p>
<pre><code><span style="font-family: 'Microsoft YaHei'; font-size: 15px; background-color: #ccffcc;">作者：KeepHopes
出处：<a href="https://www.cnblogs.com/yuwanxian/p/10924835.html">https://www.cnblogs.com/yuwanxian/p/10924835.html</a>
关于作者：专注C++，对大数据、人工智能领域颇感兴趣，请多多赐教！
本文为作者原创，版权归作者和博客园共有，转载或引用请注明出处，谢谢！</span></pre>
</div>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>