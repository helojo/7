<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修从“杨辉三角形”谈起' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>从“杨辉三角形”谈起</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11502792.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 杨辉三角是二项式系数在三角形中的一种几何排列，中国南宋数学家杨辉1261年所著的《详解九章算法》一书中出现。在欧洲，帕斯卡（1623~1662）在1654年发现这一规律，所以这个表又叫做帕斯卡三角形。帕斯卡的发现比杨辉要迟393年。</p>
<p>&nbsp; &nbsp; &nbsp; 如果将(a+b)<sup>n</sup>(n为非负整数)的每一项按字母a的次数由小到大排列，就可以得到下面的等式：</p>
<p>&nbsp; &nbsp; &nbsp; (a+b)<sup>0</sup>=1 ，&nbsp; &nbsp; 它只有一项，系数为1；<br />&nbsp; &nbsp; &nbsp; (a+b)<sup>1</sup>=a+b ，它有两项，系数分别是1，1；<br />&nbsp; &nbsp; &nbsp; (a+b)<sup>2</sup>=a<sup>2</sup>+2ab+b<sup>2</sup>，它有三项，系数分别是1，2，1；<br />&nbsp; &nbsp; &nbsp; (a+b)<sup>3</sup>=a<sup>3</sup>+3a<sup>2</sup>b+3ab<sup>2</sup>+b<sup>3</sup>，它有四项，系数分别是1，3，3，1；<br />&nbsp; &nbsp; &nbsp; &nbsp;&hellip;&hellip;</p>
<p>&nbsp; &nbsp; &nbsp; 由此，可得下面的图表，这个图表就是杨辉三角形。</p>
<p style="margin-left: 30px;"><img src="./images/从“杨辉三角形”谈起0.png" alt="" width="222" height="206" /></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;观察上图表，我们发现每一行的首末都是1，并且下一行的数比上一行多1个，中间各数都写在上一行两数中间，且等于它们的和，可以按照这个规律继续将这个表写下去。</p>
<p><strong><span style="font-size: 16px;">【例1】杨辉三角形。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 输入n（1&lt;=n&lt;=30)，输出杨辉三角形的前n行。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路1。</p>
<p>&nbsp; &nbsp; &nbsp; 用一个二维数组 y[31][31] 来保存杨辉三角形每一行的值。杨辉三角形第row行可以由第row－1行来生成。</p>
<p>例如：</p>
<table style="width: 476px; height: 10px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="96">
<p>数组元素</p>




</td>
<td valign="top" width="76">
<p>Y[row][1]</p>




</td>
<td valign="top" width="76">
<p>Y[row][2]</p>




</td>
<td valign="top" width="76">
<p>Y[row][3]</p>




</td>
<td valign="top" width="76">
<p>Y[row][4]</p>




</td>
<td valign="top" width="76">
<p>Y[row][5]</p>




</td>




</tr>
<tr>
<td valign="top" width="96">
<p>Row=4行</p>




</td>
<td valign="top" width="76">
<p>1</p>




</td>
<td valign="top" width="76">
<p>3</p>




</td>
<td valign="top" width="76">
<p>3</p>




</td>
<td valign="top" width="76">
<p>1</p>




</td>
<td valign="top" width="76">
<p>0</p>




</td>




</tr>
<tr>
<td valign="top" width="96">
<p>Row=5行</p>




</td>
<td valign="top" width="76">
<p>1</p>




</td>
<td valign="top" width="76">
<p>4</p>




</td>
<td valign="top" width="76">
<p>6</p>




</td>
<td valign="top" width="76">
<p>4</p>




</td>
<td valign="top" width="76">
<p>1</p>




</td>




</tr>




</tbody>




</table>
<p>&nbsp; &nbsp; &nbsp; 由上表知：当row＝5时，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[5][1] = 1，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[5][2] = y[4][1] + y[4][2]，&nbsp;&nbsp; y[5][3] = y[4][2] + y[4][3]，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[5][4] = y[4][3] + y[4][4] ，&nbsp; y[5][5] = y[4][4] + y[4][5]</p>
<p>&nbsp; &nbsp; &nbsp; 一般的，对于第row（1～30）行，该行有row＋1个元素，其中：</p>
<p>&nbsp; &nbsp; &nbsp; y[row][1]=1</p>
<p>&nbsp; &nbsp; &nbsp; 第col（2～row+1)个元素为：&nbsp; y[row][col] = y[row-1][col-1] + y[row-1][col]。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序1。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,j,y[31][31]={0};<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=30;i++)&nbsp; &nbsp; &nbsp; &nbsp; // 赋行首与行尾元素值为1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y[i][1]=y[i][i]=1;<br />&nbsp; &nbsp; &nbsp; for (i=3;i&lt;=30;i++)&nbsp; &nbsp; &nbsp; &nbsp; // 每行中间元素赋值<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=2;j&lt;i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y[i][j]=y[i-1][j-1]+y[i-1][j];<br />&nbsp; &nbsp; &nbsp; while (scanf("%d",&amp;n)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=1;j&lt;=i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (j!=1) printf(" ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d",y[i][j]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; （3）编程思路2。</p>
<p>&nbsp; &nbsp; &nbsp; 用一个一维数组 y[30] 来保存杨辉三角形某一行的值。杨辉三角形第row行可以由第row－1行来生成。</p>
<p>&nbsp; &nbsp; &nbsp; 例如：</p>
<table style="width: 476px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="97">
<p>数组元素</p>




</td>
<td valign="top" width="68">
<p align="center">Y[0]</p>




</td>
<td valign="top" width="75">
<p align="center">Y[1]</p>




</td>
<td valign="top" width="74">
<p align="center">y[2]</p>




</td>
<td valign="top" width="69">
<p align="center">Y[3]</p>




</td>
<td valign="top" width="92">
<p align="center">Y[4]</p>




</td>




</tr>
<tr>
<td valign="top" width="97">
<p>Row-1=3行</p>




</td>
<td valign="top" width="68">
<p align="center">1</p>




</td>
<td valign="top" width="75">
<p align="center">3</p>




</td>
<td valign="top" width="74">
<p align="center">3</p>




</td>
<td valign="top" width="69">
<p align="center">1</p>




</td>
<td valign="top" width="92">
<p align="center">0</p>




</td>




</tr>
<tr>
<td valign="top" width="97">
<p>Row=4行</p>




</td>
<td valign="top" width="68">
<p align="center">1</p>




</td>
<td valign="top" width="75">
<p align="center">4</p>




</td>
<td valign="top" width="74">
<p align="center">6</p>




</td>
<td valign="top" width="69">
<p align="center">4</p>




</td>
<td valign="top" width="92">
<p align="center">1</p>




</td>




</tr>




</tbody>




</table>
<p>&nbsp; &nbsp; &nbsp; 由上表知：当row＝4时，y[4] = y[4]+y[3]，&nbsp; &nbsp;&nbsp;y[3] = y[3]+y[2]，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[2] = y[2]+y[1] ， &nbsp;&nbsp;y[1] = y[1]+y[0]，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[0]=1</p>
<p>&nbsp; &nbsp; &nbsp; 一般的，对于第row（0～9）行，该行有row＋1个元素，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;第col（row～1)个元素为：&nbsp; y[col]=y[col]+y[col-1]，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y[0]=1</p>
<p>&nbsp; &nbsp; &nbsp; （4）源程序2。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />int main()<br />{    <br />&nbsp; &nbsp; &nbsp; int y[30],row,col,n;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d",&amp;n)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(y,0,sizeof(y));   // 数组元素初始化为0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[0]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",y[0]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (row=1;row&lt;n;row++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (col=row;col&gt;=1;col--)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[col]=y[col]+y[col -1];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (col=0;col&lt;=row;col++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (col!=0) printf(" ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d",y[col]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将上面的两个源程序提交给<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2032" target="_blank">HDU 2032&ldquo;杨辉三角&rdquo;</a>，均可以Accepted。</p>
<p>&nbsp; &nbsp; &nbsp; 下面我们进一步讨论一下杨辉三角形。</p>
<p>&nbsp; &nbsp; &nbsp; 我们根据杨辉三角形前16行中每个数的奇偶性决定是否输出一个特定字符。比如如果是奇数，输出一个&ldquo;*&rdquo;号；是偶数，输出一个空格。编写如下的程序：</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,j,y[17][17]={0};<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=16;i++)        // 赋行首与行尾元素值为1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[i][1]=y[i][i]=1;<br />&nbsp; &nbsp; &nbsp; for (i=3;i&lt;=16;i++)        // 每行中间元素赋值<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=2;j&lt;i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[i][j]=y[i-1][j-1]+y[i-1][j];<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=16;i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=1;j&lt;=i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (y[i][j]%2==1) printf("* ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else   printf("  ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; 运行上面的程序，可以得到如下的运行结果。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/从“杨辉三角形”谈起1.png" alt="" width="214" height="208" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 运行结果的图形是一个递归深度为4的三角形。 通过这个图形，我们感觉杨辉三角形中每个数字的奇偶应该满足一定的规律。</p>
<p>&nbsp; &nbsp; &nbsp;组合数C(n,m)是指从n个元素中选出m个元素的所有组合个数。其通用计算公式为：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C(n,m)=n!/[m!*(n-m)!]&nbsp; &nbsp; C(0,0)=1&nbsp; &nbsp;C(1,0)=1&nbsp; &nbsp;C(1,1)=1&nbsp;<br />&nbsp; &nbsp; &nbsp;从n个元素中取m个元素，考虑第n个元素，有两种情况：（1）不取。则必须在前n-1个元素中取m个元素，方案数为C(n-1,m)；（2）取。则只需在前n-1个元素中取m-1个元素，方案数为C(n-1,m-1)。因此，&nbsp; &nbsp;C(n,m)=C(n-1,m)+C(n-1,m-1)&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这正好符合杨辉三角形的递推公式。 即&nbsp;杨辉三角中第i行第j列的数字正是C（i,j）的结果。因此，下面对杨辉三角形中各行各列数字的讨论转化为对组合数C(n,m)的讨论。</p>
<p><strong><span style="font-size: 16px;">【例2】组合数的奇偶性。&nbsp;（POJ 3219）</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 二项式系数C(n, m)因它在组合数学中的重要性而被广泛地研究。二项式系数可以如下递归的定义：</p>
<p>&nbsp; &nbsp; &nbsp; C(1, 0) = C(1, 1) = 1；<br />&nbsp; &nbsp; &nbsp; C(n, 0) = 1&nbsp; &nbsp;对于所有n &gt; 0；<br />&nbsp; &nbsp; &nbsp; C(n, m) = C(n-1, m-1) + C(n-1, m)&nbsp; &nbsp;对于所有0 &lt; m &le; n。</p>
<p>&nbsp; &nbsp; &nbsp; 给出n和k，确定C(n, m)的奇偶性。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路1。<br />&nbsp; &nbsp; &nbsp; &nbsp;对于给定C(n,m)，检查n！中2因子的个数与m！和(n-m)！中2因子个数和的关系，假设n!中2因子个数为a，m!中2因子个数为b，(n-m)!中2因子个数为c，则显然有a&gt;=(b+c)；并且当a==b+c时，一定为奇，否则为偶。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（2）源程序1。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int getTwo(int x)&nbsp; &nbsp; &nbsp;// x!中2的因子的个数<br />{<br />&nbsp; &nbsp; &nbsp; int cnt=0;<br />&nbsp; &nbsp; &nbsp; while (x/2!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt += x/2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x=x/2;<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return cnt;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,k;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d%d", &amp;n,&amp;k)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (getTwo(n)-getTwo(k)-getTwo(n-k)&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("0\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("1\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;（3）编程思路2。</p>
<p>&nbsp; &nbsp; &nbsp; 前面通过杨辉三角形中数字的奇偶性输出&ldquo;*&rdquo;图时，我们感觉其数字的奇偶性与数字所在的行号和列号有一定的关系，即组合数C(n,m)的奇偶性与n和m有对应关系。</p>
<p>&nbsp; &nbsp; &nbsp; 根据网络上的资料，给出结论如下：</p>
<p>　　组合数的奇偶性判定方法为:<br />　　对于C(n,m)，若n&amp;m == m&nbsp; 则C(n,m)为奇数，否则为偶数。<br />　　证明：&nbsp; &nbsp; &nbsp; &nbsp; // 下面的证明采用数学归纳法，如果没兴趣，跳过即可，知道结论好了！</p>
<p>　　由C(n,m) = C(n-1,m) + C(n-1,m-1);<br />　　对应于杨辉三角：<br />　　1<br />　　1 2 1<br />　　1 3 3 1<br />　　1 4 6 4 1<br />　　&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;<br />　　可以验证前面几层及m = 0时满足结论，下面证明在C(n-1,m)和C(n-1,m-1) (m&gt;0) 满足结论的情况下，C(n,m)满足结论。<br />　　1）假设C(n-1,m)和C(n-1,m-1)为奇数：<br />　　则有：(n-1)&amp;m == m;<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(n-1)&amp;(m-1) == m-1;<br />　　由于m和m-1的最后一位（在这里的位指的是二进制的位，下同）必然是不同的，所以n-1的最后一位必然是1。<br />　　现假设 n&amp;m == m。<br />　　则同样因为n-1和n的最后一位不同推出m的最后一位是1。<br />　　因为n-1的最后一位是1，则n的最后一位是0，所以n&amp;m != m，与假设矛盾。<br />　　所以得&nbsp; n&amp;m != m。<br />　　2）假设C(n-1,m)和C(n-1,m-1)为偶数：<br />　　则有：(n-1)&amp;m != m;<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(n-1)&amp;(m-1) != m-1;<br />　　现假设n&amp;m == m.<br />　　则对于m最后一位为1的情况：<br />　　此时n最后一位也为1，所以有(n-1)&amp;(m-1) == m-1，与假设矛盾。<br />　　而对于m最后一位为0的情况：<br />　　则m的末尾必有一部分形如：10; 代表任意个0。<br />　　相应的，n对应的部分为： 1{*}*; *代表0或1。<br />　　而若n对应的{*}*中只要有一个为1，则(n-1)&amp;m == m成立，所以n对应部分也应该是10。<br />　　则相应的，m-1和n-1的末尾部分均为01,所以(n-1)&amp;(m-1) == m-1 成立，与假设矛盾。<br />　　所以得 n&amp;m != m。<br />　　由1)和2)得出当C(n,m)是偶数时，n&amp;m != m。<br />　　3）假设C(n-1,m)为奇数而C(n-1,m-1)为偶数：<br />　　则有：(n-1)&amp;m == m;<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(n-1)&amp;(m-1) != m-1;<br />　　显然，m的最后一位只能是0，否则由(n-1)&amp;m == m即可推出(n-1)&amp;(m-1) == m-1。<br />　　所以m的末尾必有一部分形如：10;<br />　　相应的，n-1的对应部分为： 1{*}*;<br />　　相应的，m-1的对应部分为： 01;<br />　　则若要使得(n-1)&amp;(m-1) != m-1 则要求n-1对应的{*}*中至少有一个是0.<br />　　所以n的对应部分也就为 ： 1{*}*; (不会因为进位变1为0)<br />　　所以 n&amp;m = m。<br />　　4).假设C(n-1,m)为偶数而C(n-1,m-1)为奇数：<br />　　则有：(n-1)&amp;m != m;<br />　　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(n-1)&amp;(m-1) == m-1;<br />　　分两种情况：<br />　　当m-1的最后一位为0时:<br />　　则m-1的末尾必有一部分形如: 10;<br />　　相应的，m的对应部分为 : 11;<br />　　相应的，n-1的对应部分为 : 1{*}0; (若为1{*}1,则(n-1)&amp;m == m)<br />　　相应的，n的对应部分为 : 1{*}1;<br />　　所以n&amp;m = m。<br />　　当m-1的最后一位为1时:<br />　　则m-1的末尾必有一部分形如: 01; (前面的0可以是附加上去的)<br />　　相应的，m的对应部分为 : 10;<br />　　相应的，n-1的对应部分为 : 01; (若为11，则(n-1)&amp;m == m)<br />　　相应的，n的对应部分为 : 10;<br />　　所以n&amp;m = m。<br />　　由3),4)得出当C(n,m)为奇数时，n&amp;m = m。<br />　　综上，结论得证!</p>
<p>&nbsp; &nbsp; &nbsp;（4）源程序2。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,k;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d%d", &amp;n,&amp;k)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((n&amp;k)==k)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("1\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("0\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;根据组合数的奇偶性判定方法:&nbsp; 对于C(n,m)，若n&amp;m == m&nbsp; 则C(n,m)为奇数，否则为偶数。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;可以写出如下一个程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,j;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d",&amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=0;i&lt;(2&lt;&lt;(n-1));i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=0;j&lt;=i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((i&amp;j)==j) printf("* ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else   printf("  ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp; 运行这个程序，输入4，可以得到前面所示的星号图形。有一次，我在网上随意浏览时，发现上面这个程序，当时觉得有些奇妙，有些小神奇。因为，要输出一个递归形式的星号图形，我习惯性地采取递归的方法。例如，为达到上面程序的功能，根据输入的n，输出相应的递归图形，我会编写如下的程序：</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#define N 64<br />void draw(char a[][N], int n, int row, int col)<br />{<br />&nbsp; &nbsp; &nbsp; if(n==1)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[row][col] = '*';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; int w = 1;<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for(i=1; i&lt;=n-2; i++) w *= 2;<br />&nbsp; &nbsp; &nbsp; draw(a, n-1, row, col);<br />&nbsp; &nbsp; &nbsp; draw(a, n-1, row+w, col+w);<br />&nbsp; &nbsp; &nbsp; draw(a, n-1, row+w,col);<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp;char a[N][N];<br />&nbsp; &nbsp; &nbsp;int n,w,i,j;<br />&nbsp; &nbsp; &nbsp;while (scanf("%d",&amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(i=0;i&lt;N;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=0;j&lt;N;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[i][j] = ' ';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(i=1; i&lt;=n-1; i++) w *= 2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; draw(a,n,0,0);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(i=0; i&lt;w; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=0; j&lt;w; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%c ",a[i][j]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 一个简单的二重循环即可完成递归图形的描绘，我当时还琢磨半天，怎么会这样？怎么想出来的？怎么会这样，我现在明白了，组合数的奇偶性判断规则。怎么想出来的，也只能归结于小神奇了，毕竟组合数的奇偶性恰好和一个递归图形完美结合起来，单靠想是难想出来的。当然，对大牛们可能也简单，我就呵呵了！</p>
<p>&nbsp; &nbsp; &nbsp; 关于递归图形的构造输出，有兴趣可看看我的另一篇随笔：<a href="https://www.cnblogs.com/cs-whut/p/11096348.html" target="_blank">递归（五）：递归图形</a>。下面采用二重循环的方法实现该随笔中例2的递归图形的输出。</p>
<p><strong><span style="font-size: 16px;">【例3】一个递归图形。</span></strong></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 小明在X星球的城堡中发现了如下图形：</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/从“杨辉三角形”谈起2.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;编写一个程序，实现该图形的打印。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;设row代表行号，col代表列号。用组合数的奇偶性判断规则，如果是奇数（row &amp; col ==col），输出&rdquo;*&ldquo;；如果是偶数，就输出空格。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;输入n（代表度，即递归深度，题干中给出的两个图形的都分别为4和6），输出的行数row=2<sup>n-1</sup>。由于最后一行抵左端，从下往上每行向后缩进一个位置（通过输出空格实现）。因此，第row行应先输出的空格数为&nbsp;2<sup>n-1</sup>-row-1。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,w,row,col;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d",&amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1; i&lt;=n-1; i++) w *= 2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (row=0; row&lt;w; row++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (col=1; col&lt;w-row; col++)&nbsp; &nbsp;// 完成缩进<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(" ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (col=0;col&lt;=row;col++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((row &amp; col)==col)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("* ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("  ");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 杨辉三角形作为二项式系数有着重要的应用价值。熟练地构造出杨辉三角形的各项（见例1的源程序），可以用来解决实际问题。</p>
<p><strong><span style="font-size: 16px;">【例4】新生晚会 （HDU 2519）。</span></strong></p>
<p>Problem Description<br />开学了，杭电又迎来了好多新生。ACMer想为新生准备一个节目。来报名要表演节目的人很多，多达N个，但是只需要从这N个人中选M个就够了，一共有多少种选择方法？<br />Input<br />数据的第一行包括一个正整数T，接下来有T组数据，每组数据占一行。<br />每组数据包含两个整数N（来报名的人数,1&lt;=N&lt;=30），M（节目需要的人数0&lt;=M&lt;=30）<br />Output<br />每组数据输出一个整数，每个输出占一行<br />Sample Input<br />5<br />3 2<br />5 3<br />4 4<br />3 6<br />8 0<br />Sample Output<br />3<br />10<br />1<br />0<br />1</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 本题实质求组合数C(n,m)的值。构造一个杨辉三角形即可。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,i,j,t,y[31][31]={0};<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=30;i++)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 赋行首与行尾元素值为1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;y[i][0]=y[i][i]=1;&nbsp; &nbsp; &nbsp; // 注意列标从0开始<br />&nbsp; &nbsp; &nbsp; for (i=2;i&lt;=30;i++)        // 每行中间元素赋值<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=1;j&lt;i;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y[i][j]=y[i-1][j-1]+y[i-1][j];<br />&nbsp; &nbsp; &nbsp; scanf("%d",&amp;t);<br />&nbsp; &nbsp; &nbsp; while (t--)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d%d",&amp;n,&amp;m);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",y[n][m]);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0; <br />}</p>
<p><span style="font-size: 16px;"><strong>【例5】Code （POJ 1850）。</strong></span></p>
<p>Description</p>
<p>Transmitting and memorizing information is a task that requires different coding systems for the best use of the available space. A well known system is that one where a number is associated to a character sequence. It is considered that the words are made only of small characters of the English alphabet a,b,c, ..., z (26 characters). From all these words we consider only those whose letters are in lexigraphical order (each character is smaller than the next character). </p>
<p>The coding system works like this: <br />&bull;	The words are arranged in the increasing order of their length. <br />&bull;	The words with the same length are arranged in lexicographical order (the order from the dictionary). <br />&bull;	We codify these words by their numbering, starting with a, as follows: <br />a - 1 <br />b - 2 <br />... <br />z - 26 <br />ab - 27 <br />... <br />az - 51 <br />bc - 52 <br />... <br />vwxyz - 83681 <br />... </p>
<p>Specify for a given word if it can be codified according to this coding system. For the affirmative case specify its code. <br />Input</p>
<p>The only line contains a word. There are some constraints: <br />&bull;	The word is maximum 10 letters length <br />&bull;	The English alphabet has 26 characters. <br />Output</p>
<p>The output will contain the code of the given word, or 0 if the word can not be codified.<br />Sample Input</p>
<p>bf<br />Sample Output</p>
<p>55</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 题目的意思是：已知26个英文字母的组合和数值的对应关系，如a~z表示第1~26列，ab~az表示第27~51，&hellip;。&nbsp;输入字母组成的字符串str，问它对应的整数为多少。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;首先判断输入的str是否是升序序列，如果不是升序序列，则输入不合法，直接输出 0。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;如果是升序序列，则先计算比str长度少的所有字符串个数。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;假设str为 vwxyz ，其长度为5。则</p>
<p>&nbsp; &nbsp; &nbsp; 长度为1的字符串 有 a,b,c,&hellip;，y,z&nbsp; 共 C(26,1)=26 个。</p>
<p>&nbsp; &nbsp; &nbsp; 长度为2的字符串</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以a开头的 有 ab,ac,ad,&hellip;,ay,az&nbsp; 共 C(25,1)=25个；</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以b开头的 有 bc,bd,&hellip;,by,bz&nbsp; &nbsp; &nbsp; &nbsp;共 C(24,1)=24个；</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 以x开头的 有 xy,xz&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;共 C(2,1)=2个；</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;以y开头的 有 yz&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;共 C(1,1)=1个。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由数学公式：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/从“杨辉三角形”谈起3.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; 知，长度为2的字符串共有 C(1,1)+C(2,1)+&hellip;+C(24,1)+C(25,1)=C(26,2) 个。</p>
<p>&nbsp; &nbsp; &nbsp; 同理，长度为3的字符串共有 C(26,3) 个。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 长度为4的字符串共有 C(26,4) 个。</p>
<p>&nbsp; &nbsp; &nbsp; 因此，长度比5小的字符串的总数为：&nbsp;C(26,1)+C(26,2)+C(26,3)+C(26,4)=26+325+2600+14950=17901。</p>
<p>&nbsp; &nbsp; &nbsp; 然后，从高位到低位处理长度为5，但比str小的字符串的个数。</p>
<p>&nbsp; &nbsp; &nbsp;首位为&rdquo;v&ldquo;，因此，首位为a,b,&hellip;,u的字符串均比str小。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首位为 a 的字符串有 abcde,abcdf,&nbsp; &hellip;，awxyz，共 C( 25,4)个，即后4个字母可以在b~z这25个字母中任取4个。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首位为 b 的字符串有 bcdef,bcdeg,&nbsp; &hellip;，bwxyz，共 C( 24,4)个，即后4个字母可以在c~z这24个字母中任取4个。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &hellip;&hellip;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首位为 u 的字符串有 uvwxy，uvwxz，uvwyz，uvxyz，uwxyz，共 C(5,4)个，即后4个字母可以在v~z这5个字母中任取4个。</p>
<p>&nbsp; &nbsp; &nbsp; 因此，考虑首位后，比str小的字符串个数有</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; C(25,4)+C(24,4)+&hellip;&hellip;+C(6,4)+C(5,4)=12650+10626+8855+7315+5985+4845+3876+3060+2380+1820+1365</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +1001+ 715+ 495+ 330+ 210+ 126+ 70+ 35+ 15+ 5=65779</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;次位为&rdquo;w&ldquo;，因为首位为v，次位为w，后3位的又都要比w大，否则不满足升序，因此只有xyz可选，考虑次位后，比str小的字符串个数为0。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;同理，考虑第3位、第4位及最后1位，比str小的字符串个数均为0。</p>
<p>&nbsp; &nbsp; &nbsp; 故 vwxyz 对应的数字为： 17901+65779+1（代表自身）=83681。&nbsp; 与题干一致。</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; char s[15],ch,t;<br />&nbsp; &nbsp; &nbsp; int c[27][27],len,ans=1,flag;<br />&nbsp; &nbsp; &nbsp; int i,j;<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;=26;++i)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[i][0]=1;  c[i][i]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j=1;j&lt;i;++j)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c[i][j]=c[i-1][j]+c[i-1][j-1];<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; scanf("%s",s); <br />&nbsp; &nbsp; &nbsp; len=strlen(s);<br />&nbsp; &nbsp; &nbsp; flag=1;<br />&nbsp; &nbsp; &nbsp; for (i=1;i&lt;len;i++)&nbsp; &nbsp; &nbsp; &nbsp; // 检查输入的字符串是否为升序，不是则输入不合法，输出0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (s[i]&lt;=s[i-1]) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; if (flag==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("0\n");<br />&nbsp; &nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;len;++i)&nbsp; &nbsp; &nbsp; &nbsp;// 长度比该串短的先加上<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans+=c[26][i]; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(i=0;i&lt;len;i++)&nbsp; &nbsp; &nbsp; &nbsp;// 从高位进行处理对于每一位处理到该位的前一个，比如该位为&lsquo;d'，就处理到c<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ch=(i==0? 'a':(s[i-1]+1));  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (t=ch;t&lt;s[i];t++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans+=c['z'-t][len-1-i];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",ans);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; POJ&nbsp; 1496 &rdquo;Word Index&ldquo;与本题类似，在理解了本题后，可以顺手通过POJ 1496。</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>