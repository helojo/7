<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修「中山纪中集训省选组D2T1」书堆 欧拉常数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>「中山纪中集训省选组D2T1」书堆 欧拉常数</center></div><div class='banquan'>原文出处:本文由博客园博主ModestStarlight提供。<br/>
原文连接:https://www.cnblogs.com/ModestStarlight/p/11289523.html</div><br>
    <h2 id="题目描述">题目描述</h2>
<p>蚂蚁是勤劳的动物，他们喜欢挑战极限。现在他们迎来了一个难题！蚂蚁居住在图书馆里，图书馆里有大量的书籍。书是形状大小质量都一样的矩形。蚂蚁要把这些书摆在水平桌子的边缘。蚂蚁喜欢整洁的布置，所以蚂蚁规定书本必须水平摆放，宽必须平行于桌缘（如图），而且不允许同一高度摆多本书。<br />
<img src="./images/「中山纪中集训省选组D2T1」书堆 欧拉常数0.png" alt="示例图片" /><br />
蚂蚁想要让书本伸出桌子边缘尽量远，同时不让书因为重力垮下来。它们已经用不知道什么方法测出了书的长度<span class="math inline">\(M\)</span>（如图）。如果总共有<span class="math inline">\(N\)</span>本书，请你帮忙计算如何摆放使得最多水平伸出桌缘多远。你不用考虑蚂蚁用什么方法搭建这堆书。<br />
如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。</p>
<p>注意：<br />
不考虑地球自转，重力系数也不因高度改变；<br />
书是质量均匀，质地坚硬的理想二维物体；<br />
在不会垮的前提下，每本书的位置坐标可以是任意实数。</p>
<h2 id="输入格式">输入格式</h2>
<p>输入文件仅含一行，两个正整数<span class="math inline">\(N\)</span>和<span class="math inline">\(M\)</span>，表示书本数和书本长度。</p>
<h2 id="输出格式">输出格式</h2>
<p>输出仅包含一行，整数<span class="math inline">\(L\)</span>，表示水平延伸最远的整数距离 (不大于答案的最大整数，详见样例)</p>
<h2 id="样例">样例</h2>
<h3 id="样例输入1">样例输入1</h3>
<pre><code>1 100</code></pre>
<h3 id="样例输出1">样例输出1</h3>
<pre><code>49</code></pre>
<h3 id="样例输出1-1">样例输出1</h3>
<pre><code>2 100</code></pre>
<h3 id="样例输出2">样例输出2</h3>
<pre><code>74</code></pre>
<h2 id="数据范围">数据范围</h2>
<p><span class="math inline">\(10\%\)</span>的数据中<span class="math inline">\(N\leq5\)</span>；<br />
<span class="math inline">\(20\%\)</span>的数据中<span class="math inline">\(N\leq10^3\)</span>；<br />
<span class="math inline">\(40\%\)</span>的数据中<span class="math inline">\(N\leq10^7\)</span>；<br />
<span class="math inline">\(100\%\)</span>的数据中<span class="math inline">\(N\leq10^{18}\)</span>；答案<span class="math inline">\(\leq10^6\)</span>。</p>
<h2 id="题解">题解</h2>
<p>设<span class="math inline">\(f_i\)</span>表示<span class="math inline">\(i\)</span>本书达到最大位置时最下方的书与最上方的书的中点的距离。显然，<span class="math inline">\(f_1=0\)</span>。<br />
那么先考虑怎么通过<span class="math inline">\(f\)</span>的前<span class="math inline">\(i\)</span>个值计算出<span class="math inline">\(f_{i+1}\)</span>。<br />
记<span class="math inline">\(f\)</span>的前缀和为<span class="math inline">\(g\)</span>，那么前<span class="math inline">\(i\)</span>本书的总重心与最上方的书的中点的距离是<span class="math inline">\(\frac{g_i}{i}\)</span>。而要保证伸出的距离最长，显然应该让上面<span class="math inline">\(i\)</span>本书的总重心落在第<span class="math inline">\(i+1\)</span>本书的边缘上。这样就会发现，<span class="math inline">\(f_{i+1}=\frac{g_i}{i}+\frac{M}{2}\)</span>。这样，我们就可以递推计算答案了。<br />
但是，<span class="math inline">\(N\)</span>是<span class="math inline">\(10^{18}\)</span>级别的，这样的递推公式没法满足我们，我们首先得将<span class="math inline">\(g\)</span>消去。<br />
考虑到<span class="math inline">\(g_i=g_{i-1}+f_i\)</span>，<span class="math inline">\(f_i=\frac{g_{i-1}}{i-1}+\frac{M}{2}\)</span>，将他们代入上式。<br />
<span class="math display">\[f_{i+1}=\frac{g_{i-1}+\frac{g_{i-1}}{i-1}+\frac{M}{2}}{i}+\frac{M}{2}=\frac{\frac{i\cdot g_{i-1}}{i-1}+\frac{M}{2}}{i}+\frac{M}{2}=\frac{g_{i-1}}{i-1}+\frac{M}{2}+\frac{M}{2i}=f_i+\frac{M}{2i}\]</span></p>
<p>这样，我们就有了用<span class="math inline">\(f_i\)</span>求<span class="math inline">\(f_{i+1}\)</span>的方法，也就知道了<span class="math inline">\(f_i=\sum_{k=1}^{i-1}\frac{M}{2k}\)</span>，而我们要求的<span class="math inline">\(N\)</span>本书的最长延伸距离恰好就等于<span class="math inline">\(f_{N+1}\)</span>，也就是<span class="math inline">\(M\cdot\sum_{i=1}^{N}\frac{1}{2i}\)</span>。我们只需要快速求出正整数的倒数和，就可以快速计算<span class="math inline">\(f\)</span>了。</p>
<p>至于如何求正整数的倒数和呢？当<span class="math inline">\(N\leq10^7\)</span>时，我们可以<span class="math inline">\(O(N)\)</span>暴力求解，然而<span class="math inline">\(N\)</span>更大的话就会超时。但同时我们可以注意到，答案不超过<span class="math inline">\(10^6\)</span>，相当于我们只要求出答案的前<span class="math inline">\(6\)</span>位有效数字即可，于是我们可以借助欧拉常数计算，如下：<br />
<span class="math display">\[\gamma=\lim_{n\to\infty}\sum_{i=1}^{n}\frac{1}{i}-\ln(n)\]</span></p>
<p>于是当<span class="math inline">\(N\)</span>很大时，我们可以用<span class="math inline">\(\ln(N)\)</span>和<span class="math inline">\(\gamma\)</span>相加求出正整数的倒数和的近似值。至于<span class="math inline">\(\gamma\)</span>具体是多少，可以通过暴力计算<span class="math inline">\(\sum_{i=1}^{10^9}\frac{1}{i}\)</span>与<span class="math inline">\(\ln(10^9)\)</span>的差得出近似值，大约是<span class="math inline">\(0.57721566\)</span>。</p>
<p>吐槽：这题不知道欧拉常数就做不了啊（虽然欧拉常数基本可以当成一个常识了）……不知道的人就算推出倒数和的形式也搞不出来啊……</p>
<p><span class="math inline">\(Code:\)</span></p>
<pre><code>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define ll long long
ll n;
int m;
int main()
{
    scanf(&quot;%lld%d&quot;, &amp;n, &amp;m);
    if (n &lt;= 10000000)
    {
        long double ans = 0;
        for (int i = 1; i &lt;= n; i++)
            ans += 1 / (long double)i;
        ans /= 2;
        printf(&quot;%d\n&quot;, int(ans * m - 1e-6));
    }
    else
    {
        long double ans = (log(n) + 0.57721566) / 2;
        printf(&quot;%d\n&quot;, int(ans * m - 1e-6));
    }
}</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>