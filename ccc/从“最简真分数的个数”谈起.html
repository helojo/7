<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修从“最简真分数的个数”谈起' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>从“最简真分数的个数”谈起</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11515994.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 所谓最简真分数是一个分数的分子小于分母，且分子分母无公因数。<br />&nbsp; &nbsp; &nbsp; 2010年湖北省小学奥林匹克数学竞赛（小学六年级组）有这样一道试题：以2010为分母的最简真分数有多少个？<br />&nbsp; &nbsp; &nbsp; 这道小学奥数试题考察的是学生对集合包含和容斥知识的掌握情况。<br />&nbsp; &nbsp; &nbsp; 由于2010=2*3*5*67（分解质因数），因此以2010为分母的最简真分数的分子必须小于2010且不能被2、3、5或67整除。<br />&nbsp; &nbsp; &nbsp; 小朋友解决这个问题的计算过程如下：<br />&nbsp; &nbsp; &nbsp; 在1~2010共2010个数中，<br />&nbsp; &nbsp; &nbsp; 能被2整除的数有  2010&divide;2=1005<br />&nbsp; &nbsp; &nbsp; 能被3整除的数有  2010&divide;3=670<br />&nbsp; &nbsp; &nbsp; 能被5整除的数有  2010&divide;5=402<br />&nbsp; &nbsp; &nbsp; 能被67整除的数有  2010&divide;67=30<br />&nbsp; &nbsp; &nbsp; 能同时被2和3整除的数有  2010&divide;（2&times;3）=335<br />&nbsp; &nbsp; &nbsp; 能同时被2和5整除的数有  2010&divide;（2&times;5）=201<br />&nbsp; &nbsp; &nbsp; 能同时被2和67整除的数有  2010&divide;（2&times;67）=15<br />&nbsp; &nbsp; &nbsp; 能同时被3和5整除的数有  2010&divide;（3&times;5）=134<br />&nbsp; &nbsp; &nbsp; 能同时被3和67整除的数有  2010&divide;（3&times;67）=10<br />&nbsp; &nbsp; &nbsp; 能同时被5和67整除的数有  2010&divide;（5&times;67）=6<br />&nbsp; &nbsp; &nbsp; 能同时被2、3和5整除的数有  2010&divide;（2&times;3&times;5）=67<br />&nbsp; &nbsp; &nbsp; 能同时被2、3和67整除的数有  2010&divide;（2&times;3&times;67）=5<br />&nbsp; &nbsp; &nbsp; 能同时被2、5和67整除的数有  2010&divide;（2&times;5&times;67）=3<br />&nbsp; &nbsp; &nbsp; 能同时被3、5和67整除的数有  2010&divide;（3&times;5&times;67）=2<br />&nbsp; &nbsp; &nbsp; 能同时被2、3、5和67整除的数有  2010&divide;（2&times;3&times;5&times;67）=1<br />&nbsp; &nbsp; &nbsp; 这样，1~2010中能被2或3或5或67整除的数有<br />&nbsp; &nbsp; &nbsp; &nbsp; （1005+670+402+30）-（335+201+15+134+10+6）+（67+5+3+2）-1<br />&nbsp; &nbsp; &nbsp; &nbsp;=2107-701+77-1&nbsp; &nbsp;=1482<br />&nbsp; &nbsp; &nbsp; 因此，1~2010中既不能被2整除，也不能被3整除，也不能被5整除，也不能被67整除的数有 2010-1482=528 个。<br />&nbsp; &nbsp; &nbsp; 即以2010为分母的最简真分数有528个。</p>
<p>&nbsp; &nbsp; &nbsp; 我们可以看出，上面的计算过程是比较繁琐的，需要认真仔细。<br />&nbsp; &nbsp; &nbsp; 学习过程序设计后，可以编写了一个简单的循环程序解决这个问题。<br />&nbsp; &nbsp; &nbsp; 用一个变量cnt来保存最简真分数的个数，初始值为0。<br />&nbsp; &nbsp; &nbsp; 对1~2010中的每一个数num，进行判断，这是一个循环，写成<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(num=1; num&lt;=2010;num++)<br />&nbsp; &nbsp; &nbsp; 循环体中的判断方法为：如果num既不能被2整除，也不能被3整除，也不能被5整除，也不能被67整除，则计数。写成<br />&nbsp; &nbsp; &nbsp; &nbsp;if(num%2!=0 &amp;&amp; num%3!=0  &amp;&amp; num%5!=0  &amp;&amp; num %67!=0) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br />&nbsp; &nbsp; &nbsp; 最后，输出结果cnt。&nbsp; &nbsp;一个简单的程序，就得到问题的答案。<br />&nbsp; &nbsp;编写的源程序如下：<br />&nbsp; &nbsp; &nbsp; &nbsp;#include &lt;stdio.h&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp;int main()<br />&nbsp; &nbsp; &nbsp; &nbsp;{   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int cnt,num;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (num=1; num&lt;=2010;num++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (num%2!=0 &amp;&amp; num%3!=0  &amp;&amp; num%5!=0  &amp;&amp; num %67!=0) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",cnt);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; 需要说明的是，当时竞赛的真题是：所有以2010为分母的最简真分数的和为多少？</p>
<p>&nbsp; &nbsp; &nbsp; 瞧瞧，作为大学生的你还能像小朋友一样做出来吗？</p>
<p>&nbsp; &nbsp; &nbsp; 当然，你学过程序设计，将上面的程序简单改写一下，可以很快得到答案的。何须像小朋友一样苦苦思考和运算呢。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />       int main()<br />       { <br />&nbsp; &nbsp; &nbsp;int num;<br />&nbsp; &nbsp; &nbsp;double sum;<br />&nbsp; &nbsp; &nbsp;sum=0;<br />&nbsp; &nbsp; &nbsp;for (num=1; num&lt;=2010;num++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (num%2!=0 &amp;&amp; num%3!=0 &amp;&amp; num%5!=0 &amp;&amp; num %67!=0) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum+=1.0*num/2010;<br />&nbsp; &nbsp; &nbsp;printf("%lf\n",sum);<br />&nbsp; &nbsp; &nbsp;return 0;<br />       }</p>
<p>&nbsp; &nbsp; &nbsp; 程序运行后，输出 264.000000。即所有以2010为分母的最简真分数的和是264。</p>
<p>&nbsp; &nbsp; &nbsp; 小朋友是没法像程序一样硬算的。1/2010+7/2010+11/2010+&hellip;+2099/2010=264。</p>
<p>&nbsp; &nbsp; &nbsp; 小朋友有小朋友的聪明，1/2010是最简真分数，那么2099/2010 也一定是最简真分数。</p>
<p>&nbsp; &nbsp; &nbsp; i/2010 是最简真分数，那么 （2010-i）/2010 也一定是最简真分数。</p>
<p>&nbsp; &nbsp; &nbsp; 1/2010 + 2099/2010=1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i/2010 +（2010-i）/2010=1。</p>
<p>&nbsp; &nbsp; &nbsp; 小朋友知道了以2010为分母的最简真分数有528个，因此它们的和为 528/2 = 264。</p>
<p>&nbsp; &nbsp; &nbsp; 因为2010分解质因数后，因数有2、3、5和67四个，用于考察集合的包含与容斥计算量略大但又可以完成，可以算是一道很好的竞赛试题。</p>
<p>&nbsp; &nbsp; &nbsp;在这道试题的基础上，我们看这样一个问题。</p>
<p><strong><span style="font-size: 16px;">【例1】最简真分数。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 任意输入一个正整数n，求以n为分母的最简真分数有多少个？</p>
<p>&nbsp; &nbsp; &nbsp;（1）编程思路1。</p>
<p>&nbsp; &nbsp; &nbsp; 将输入的n作为分母，穷举分子i （1&le;i&le;n-1）。因此，程序可先写成如下的循环：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1; i&lt;=n-1; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;对每一分数i/n，进行是否存在公因数的检测。根据检测的结果决定是否计数；<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; 在上面的循环体中需要对每一分数i/n，进行是否存在公因数的检测。如果分子i与分母n存在大于1的公因数k，说明i/n不是最简真分数，不予计数。怎样进行检测呢？<br />&nbsp; &nbsp; &nbsp; 因为公因数k的取值范围为[2，i]，因而设置u循环在[2，i]中穷举k，若满足条件<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i%k==0 &amp;&amp; n%k==0<br />&nbsp; &nbsp; &nbsp; 说明分子分母存在公因数k，标记t=1后退出。<br />&nbsp; &nbsp; &nbsp; 在对因子k进行循环穷举前，可设置标志t=0。退出因子穷举循环后，若t=1，说明分子和分母存在公因子；若保持原t=0，说明分子分母无公因数，统计个数。</p>
<p><em>&nbsp;</em> &nbsp; &nbsp; （2）源程序1。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{ <br />&nbsp; &nbsp; &nbsp; int n,i,k,t,cnt;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d",&amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1;i&lt;=n-1;i++)&nbsp; &nbsp; &nbsp; &nbsp;// 穷举分子  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (k=2;k&lt;=i;k++)&nbsp; // 穷举因数  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i%k==0 &amp;&amp; n%k==0) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 分子分母有公因数舍去  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (t==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cnt++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 统计最简真分数个数  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",cnt);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将上面的源程序提交给 <a href="http://poj.org/problem?id=2407" target="_blank">POJ 2407 &ldquo;Relatives&rdquo;</a>，判定为Time Limit Exceeded。&nbsp; POJ 2407的题意是：&nbsp;输入正整数N，求小于或等于N ([1,N])，且与N互质的正整数（包括1）的个数。这与求最简真分数的意思完全一致。</p>
<p>&nbsp; &nbsp; &nbsp; 上面源程序1的方法简单直接，但对于N值较大的话，会超时的。因此，我们应找到快速的求法。在数论中，欧拉函数就很好地解决了这样的问题。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;在数论，对于正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目。此函数以其首名研究者欧拉命名，一般简记为&phi;函数。 例如，&phi;(8)=4，因为1,3,5,7均和8互质。</p>
<p>&nbsp; &nbsp; &nbsp; 一般来说，设正整数N分解质因数后，N=P1^q1*P2^q2*...*Pn^qn.</p>
<p>&nbsp; &nbsp; &nbsp; 则&nbsp; &nbsp;&phi;(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn)。</p>
<p>&nbsp; &nbsp; &nbsp; 例如， 10= 2*5&nbsp; &nbsp; &nbsp;&phi;(10)=10&times;(1-1/2)&times;(1-1/5)=4;&nbsp; &nbsp; &nbsp;这4个数是1, 3, 7, 9 。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;30=2*3*5&nbsp; &nbsp;&phi;(30)=30&times;(1-1/2)&times;(1-1/3)&times;(1-1/5)=8;&nbsp; 这8个数是1,7,11,13, 17, 19, 23, 29。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;按欧拉函数的求法，可以编写如下的源程序。</p>
<p>&nbsp; &nbsp; &nbsp; （3）源程序2。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,ans,t;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t=n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=2;i*i&lt;=t;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t % i == 0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 找到一个质因数i<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans -= ans/i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (t % i == 0)&nbsp; &nbsp; // 将质因数i全去掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t /= i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t!=1)  ans -= ans/t;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",ans);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将源程序2提交给 POJ 2407， 可以Accepted。</p>
<p>&nbsp; &nbsp; &nbsp; 将此源程序的printf("%d\n",ans);改写为&nbsp;printf("%d\n",n-ans-1); 后，提交给<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1787" target="_blank"> HDU 1787 &ldquo;GCD Again&rdquo;</a>，也可以Accepted。</p>
<p><strong><span style="font-size: 16px;">【例2】还是最简真分数。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 输入一个正整数n，求分母在指定区间[2，n]的最简真分数共有多少个？</p>
<p>&nbsp; &nbsp; &nbsp; 例如，输入5，输出应为 9。这9个最简真分数是 {1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5} 。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 例1的源程序2可以求欧拉函数&phi;(n)的值。用一个循环求出 &phi;(2)+&phi;(3)+&hellip;+&phi;(n)的累加和，即得本题的输出。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,k,ans,t,sum;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (k=2;k&lt;=n;k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans = k;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t=k;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=2;i*i&lt;=t;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (t % i == 0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 找到一个质因数i<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans -= ans/i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (t % i == 0)&nbsp; &nbsp;// 将质因数i全去掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t /= i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (t!=1)  ans -= ans/t;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum+=ans;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",sum);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将此源程序提交给 <a href="http://poj.org/problem?id=2478" target="_blank">POJ 2478 &ldquo;Farey Sequence&rdquo;</a>，被判定为Time Limit Exceeded。POJ 2478的题意是：求1~n的欧拉函数的和。</p>
<p>&nbsp; &nbsp; &nbsp; 因为，例1中是在&nbsp;O(sqrt(n)) 的时间内求出一个数n的欧拉函数值。</p>
<p>&nbsp; &nbsp; &nbsp; 如果要求100000以内所有正整数的欧拉函数值，上面程序采用的方法的复杂度将高达O(N*sqrt(N))。因此，容易超时。</p>
<p>&nbsp; &nbsp; &nbsp; 下面我们寻求更快的求欧拉函数值的方法。</p>
<p>&nbsp; &nbsp; &nbsp; 我们知道，欧拉函数值&nbsp; &phi;(n)=n*(1-1/p1)*(1-1/p2)....*(1-1/pk)，其中p1、p2&hellip;pk为n的所有质因子。即欧拉函数的值与其质因子有关。用筛法可以方便地求出n以内的所有质数。关于筛法及应用可以参阅本博客中的随笔&nbsp;<a href="https://www.cnblogs.com/cs-whut/p/11001842.html" target="_blank">POJ中和质数相关的三个例题（POJ 2262、POJ 2739、POJ 3006）</a>。</p>
<p>&nbsp; &nbsp; &nbsp; 那么我们能不能在筛法求质数的同时求出所有数的欧拉函数呢？可以采用如下的方法：</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;用筛法一边筛出N以内的所有质数，一边以类似于筛法的思想用质数筛出每个数的欧拉函数&phi;值。</p>
<p>&nbsp; &nbsp; &nbsp; 这里，利用了欧拉函数的几个基本性质：</p>
<p>&nbsp; &nbsp; &nbsp; ① 若N是质数p的k次幂，&phi;(N)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了p的倍数外，其他数都跟N互质。&nbsp;<br />&nbsp; &nbsp; &nbsp; ② 当N是质数时，&phi;(N) = N-1。显然，因为N是质数，1~N-1均与N互质。&nbsp;<br />&nbsp; &nbsp; &nbsp; ③ 欧拉函数是积性函数&mdash;&mdash;若m,n互质，&phi;(m*n)=&phi;(m)*&phi;(n) 。</p>
<p>&nbsp; &nbsp; &nbsp; ④&nbsp;假设质数p能整除n，那么</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果p还能整除n / p ,&nbsp; &phi;(n)&nbsp; = &phi;(n / p) * p;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果p不能整除n / p,&nbsp; &nbsp;&phi;(n)&nbsp; = &phi;(n / p) * (p - 1)。</p>
<p>&nbsp; &nbsp; &nbsp; 定义数组phi[N]，元素phi[i]表示正整数i的欧拉函数值&phi;(i)。</p>
<p>&nbsp; &nbsp; &nbsp; 定义数组vis[N]，元素vis[i]=True表示i在筛子中，vis[i]=false表示i不在筛子中，已被筛掉。初始时，vis数组的元素全置为true，表示全部放在筛子中。</p>
<p>&nbsp; &nbsp; &nbsp;定义数组prime[N]，元素prime[i]的值为第i个质数。</p>
<p>&nbsp; &nbsp; &nbsp; 下面以求20以内所有质数及所有数的&phi;值为例，来描述筛法的使用。</p>
<p>&nbsp; &nbsp; &nbsp; 1） 从i=2开始循环， vis[2]==true，找到第一个质数2，prime[0]=2，质数个数PNum=1；同时，phi[2]=2-1=1。</p>
<p>&nbsp; &nbsp; &nbsp; 采用循环 for (j = 0; j &lt; pNum &amp;&amp; prime[j]*i &lt;MAXN; j++ ) 将筛子中2的各质数倍数筛掉，同时求得相应数的欧拉函数值。（注意这里与通常的筛法有改变，主要为了用质数筛出各数的欧拉函数值）。</p>
<p>&nbsp; &nbsp; &nbsp; 筛去 2*prime[0]=2*2=4，即 vis[4]=false； phi[4]=phi[2]*prime[0]=1*2=2；</p>
<p>&nbsp; &nbsp; &nbsp; 2）i++，进行下次循环， vis[3]==true，找到第2个质数，prime[1]=3，pNum=2，同时phi[3]=3-1=2。</p>
<p>&nbsp; &nbsp; &nbsp;筛去 3*prime[0]=3*2=6 ，即vis[6]=false;&nbsp; 置phi[6]=phi[3]*(prime[0]-1)=2*1=2；</p>
<p>&nbsp; &nbsp; &nbsp;筛去 3*prime[1]=3*3=9 ，即vis[9]=false;&nbsp; 置phi[9]=phi[3]*(prime[1])=2*3=6；</p>
<p>&nbsp; &nbsp; &nbsp;3）i++，进行下次循环， vis[4]==false，4不是质数。</p>
<p>&nbsp; &nbsp; &nbsp;筛去 4*prime[0]=4*2=8 ，即vis[8]=false;&nbsp; 置phi[8]=phi[4]*(prime[0])=2*2=4；</p>
<p>&nbsp; &nbsp; &nbsp;筛去 4*prime[1]=4*3=12 ，即vis[12]=false;&nbsp; 置phi[12]=phi[4]*(prime[1]-1)=2*2=4；&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 与&nbsp;&nbsp;&phi;(12)=12*(1-1/2)(1-1/3)=4&nbsp; &nbsp;比较下 更容易理解。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[12]=phi[4]*(prime[1]-1)=phi[2]*prime[0]*(prime[1]-1)=2*(1-1/2)*2*3*(1-1/3)。<br />&nbsp; &nbsp; &nbsp; 4）i++，进行下次循环， vis[5]==true，找到第3个质数，prime[2]=5，pNum=3，同时phi[5]=5-1=4。</p>
<p>&nbsp; &nbsp; &nbsp;筛去 5*prime[0]=5*2=10 ，即vis[10]=false;&nbsp; 置phi[10]=phi[5]*(prime[0]-1)=4*1=4；</p>
<p>&nbsp; &nbsp; &nbsp;筛去 5*prime[1]=5*3=15 ，即vis[15]=false;&nbsp; 置phi[15]=phi[5]*(prime[1]-1)=4*2=8；</p>
<p>&nbsp; &nbsp; &nbsp;筛去 5*prime[2]=5*5=25 ，即vis[25]=false;&nbsp; &nbsp;当然我们以20为例的话，25已超出，循环不会执行到。</p>
<p>&nbsp; &nbsp; &nbsp; 同理，6不是质数，筛去 6*2=12，置 phi[12]=phi[6]*(prime[0])= 2*2=4。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;筛去 6*3=18 ，置phi[18]=phi[6]*(prime[1])=2*3=6。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7是质数，置prime[3]=7,pNum=4, phi[7]=6。&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 筛去 7*2=14，置 phi[14]=phi[7]*(prime[0]-1)= 6*1=6。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &hellip;&hellip;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; （3）采用筛法思想的源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define  MAXN  1000005<br />int prime[MAXN], pNum, phi[MAXN];<br />__int64 num[MAXN]={0};<br />bool  vis[MAXN];<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,i,j;<br />&nbsp; &nbsp; &nbsp; memset(vis,true,sizeof(vis));<br />&nbsp; &nbsp; &nbsp; //  下面程序段既求MAXN以内的素数又求欧拉数。<br />&nbsp; &nbsp; &nbsp; pNum=0;<br />&nbsp; &nbsp; &nbsp; phi[1] = 1;<br />&nbsp; &nbsp; &nbsp; for (i = 2; i &lt; MAXN; i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (vis[i])&nbsp; &nbsp;//&nbsp; i是素数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&nbsp;&nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prime[pNum++] = i; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[i] = i-1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 0; j &lt; pNum &amp;&amp; prime[j]*i &lt;MAXN; j++ )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vis[prime[j]*i] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (i % prime[j] == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[i*prime[j]] = phi[i] * prime[j];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[i*prime[j]] = phi[i] *(prime[j] - 1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; for (i=2;i&lt;MAXN;i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num[i]=num[i-1]+phi[i];<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%I64d\n",num[n]);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; 将用筛法思想改写的源程序提交给 POJ 2478， 可以Accepted。</p>
<p>&nbsp; &nbsp; &nbsp; 将上面的程序略作改动，可以顺便通过 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2824" target="_blank">HDU 2824 &ldquo;The Euler function&rdquo;</a>。</p>
<p>&nbsp; &nbsp; （4）进一步讨论。</p>
<p>&nbsp; &nbsp; &nbsp;上面采用筛法求欧拉函数的值时，用了3个数组，用于表示数是否在筛子中的标记数组vis，用于保存质数的数组prime，用于保存欧拉函数值的数组phi。虽然看起来直观，好像体现了欧拉函数值与分解质因数相关的概念，但有点繁琐。能否只用一个数组phi，即保存欧拉函数的值，又表示筛子，当然在筛子中的最小数一定是质数，从而又表示了质数呢？</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;定义数组phi[N]，初始值全为0，Phi[i]=0表示i在筛子中，i是质数。</p>
<p>&nbsp; &nbsp; &nbsp; 前面介绍过欧拉函数值得标准求法。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 设正整数N分解质因数后，N=P1^q1*P2^q2*...*Pn^qn.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;则&nbsp; &nbsp;&phi;(N)=N*(1-1/P1)*(1-1/P2)*...*(1-1/Pn)。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;显然，若p1是n的质因数，phi[n]一定会作 n*(p1-1)/p1这样的运算。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;下面我以n=30为例介绍phi数组既保存欧拉函数值有当筛子用的方法。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由于筛法从i=2开始进行，所有phi[i]元素值初始全为0。 </p>
<p>&nbsp; &nbsp; &nbsp; 1）phi[2]=0，2在筛子中，2是质数，开始执行筛法过程，对指定范围内所有2的倍数进行处理。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[2]=0&nbsp; &nbsp;phi[2]=2&nbsp; &nbsp;（置初始值表示筛掉 ）&nbsp; &nbsp;phi[2]=phi[2]*(2-1)/2 =1&nbsp; &nbsp;（由于2是其质因数，按公式需 *（1-1/2）&nbsp; ）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[4]=0&nbsp; &nbsp;phi[4]=4&nbsp; &nbsp;（置初始值表示筛掉 ）&nbsp; &nbsp;phi[4]=phi[4]*(2-1)/2 = 2&nbsp; （ 由于2是其质因数，按公式需 *（1-1/2）&nbsp; ）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[6]=0&nbsp; &nbsp;phi[6]=6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;phi[6]=phi[6]*(2-1)/2 = 3</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &hellip;&hellip;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[30]=0&nbsp; &nbsp;phi[30]=30&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[30]=phi[30]*(2-1)/2 = 15</p>
<p>&nbsp; &nbsp; &nbsp; 2）i++进行下一次循环。i=3，phi[3]=0，3在筛子中，3是质数，开始执行筛法过程，对指定范围内所有3的倍数进行处理。&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[3]=0&nbsp; &nbsp;phi[3]=3&nbsp; &nbsp;（置初始值表示筛掉 ）&nbsp; &nbsp;phi[3]=phi[3]*(3-1)/3 =2&nbsp; &nbsp;（3是其质因数，按公式需 *（1-1/3） ）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[6]=3&nbsp; 不等于0，已筛过，不再置初始值，直接phi[6]=phi[6]*(3-1)/3 =2&nbsp; （3是其质因数，按公式需 *（1-1/3） ）&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[9]=0&nbsp; &nbsp;phi[9]=9&nbsp; &nbsp;（置初始值表示筛掉 ）&nbsp; &nbsp;phi[9]=phi[9]*(3-1)/3 =6&nbsp; &nbsp;（3是其质因数，按公式需 *（1-1/3） ）</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &hellip;&hellip;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[30]=15&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[30]=phi[30]*(3-1)/3 = 10</p>
<p>&nbsp; &nbsp; &nbsp; 3）i++进行下一次循环，i=4，phi[4]=2，4不在筛子中，4不是质数，不进行处理。</p>
<p>&nbsp; &nbsp; &nbsp; 4）i++进行下一次循环。i=5，phi[5]=0，5在筛子中，5是质数，开始执行筛法过程，对指定范围内所有5的倍数进行处理。&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[5]=0&nbsp; &nbsp;phi[5]=5&nbsp; &nbsp;（置初始值表示筛掉 ）&nbsp; &nbsp;phi[5]=phi[5]*(5-1)/5 =4&nbsp; &nbsp;（5是其质因数，按公式需 *（1-1/5） ）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[10]=5&nbsp; 不等于0，已筛过，直接&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[10]=phi[10]*(5-1)/5 =4&nbsp; （5是其质因数，按公式需 *（1-1/5） ）&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&hellip;&hellip;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[30]=10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;phi[30]=phi[30]*(5-1)/5 = 8</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;根据上面的描述，可以将这个筛法过程写成如下的二重循环。</p>
<p style="margin-left: 30px;"> for (i=2; i &lt;= n; i++)<br />	{<br />&nbsp; &nbsp; &nbsp; &nbsp; if (phi[i]==0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// i在筛子中，是质数<br />&nbsp; &nbsp; &nbsp; &nbsp; for (j = i; j &lt;= n; j+=i)&nbsp; &nbsp; &nbsp;// 处理i的倍数<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (phi[j]==0)     // 在筛子中，筛掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[j] = j;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[j] = phi[j]/i*(i-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />    }</p>
<p>&nbsp; &nbsp; &nbsp; 请自己采用这种只用一个数组的筛法过程改写上面的筛法程序。</p>
<p><strong><span style="font-size: 16px;">&nbsp;【例3】欧拉函数的应用。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;输入一个正整数N(1 &le; N &le; 1000000000)，求1~N-1中所有与N不互质的数的和。两个正整数a和b，如果a和b的最大公约数gcd(a,b)&gt;1，则a与b不互质。由于所求和值较大，输出其模1000000007的结果。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;先需明白一个简单的定理：若 gcd(n,i)=1，则 gcd(n,n-i)=1。 即如果n与i互质，则n与n-i一定互质。</p>
<p>&nbsp; &nbsp; &nbsp; 因此，本题我们可以先求所有与n互质的数的和sum。由于与n互质的数两两配对（i与n-i）的和为n。这样，</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum=n* phi(n)/2 。&nbsp; &nbsp;phi(n)是欧拉函数，其值为1~n中所有与n互质的数的个数。由于题目中N值较大，筛法用数组保存不恰当，因此直接采用例1中得源程序2的思路求欧拉函数的值。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;求得sum后，输出的答案应为 [(n-1)*n/2-sum] % 1000000007 。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#define MOD 1000000007<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; __int64 n,t,sum,ans;<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; while (scanf("%I64d", &amp;n) &amp;&amp; n!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum = n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t=n;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=2;i*i&lt;=t;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (t % i == 0)          // 找到一个质因数i<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum -= sum/i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (t % i == 0) // 将质因数i全去掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t /= i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (t!=1) sum -= sum/t;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=n*(n-1)/2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum=n*sum/2;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=(ans-sum)% MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",ans);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p style="margin-left: 30px;">将此源程序提交给 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=3501" target="_blank">HDU 3501 &ldquo;Calculation 2&rdquo;</a>，可以Accepted。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 上面我们介绍了三种求欧拉函数值的方法。一种是直接利用公式计算，另两种是利用筛法，这两种筛法实际上有两个名称的，一个称为欧拉筛求欧拉函数（采用3个数组的那个），一个称为 埃拉托斯特尼筛求欧拉函数（采用一个数组的那个）。由于欧拉函数在ACM、NOIP等竞赛中是一个基础知识，在POJ、HDU等在线OJ网站中也有较多相关的题目。因此，我们可以将这3种方法写成函数的形式，以后作为模板直接套用或直接应用即可。</p>
<p>&nbsp; &nbsp; &nbsp; 下面我们用POJ 1284为例，来展示抽象的3个函数及应用情况。</p>
<p><strong><span style="font-size: 16px;">【例4】Primitive Roots。（POJ 1284）</span></strong></p>
<p>We say that integer x, 0 &lt; x &lt; p, is a primitive root modulo odd prime p if and only if the set { (xi mod p) | 1 &lt;= i &lt;= p-1 } is equal to { 1, ..., p-1 }. For example, the consecutive powers of 3 modulo 7 are 3, 2, 6, 4, 5, 1, and thus 3 is a primitive root modulo 7. <br />Write a program which given any odd prime 3 &lt;= p &lt; 65536 outputs the number of primitive roots modulo p. <br />Input</p>
<p>Each line of the input contains an odd prime numbers p. Input is terminated by the end-of-file seperator.<br />Output</p>
<p>For each p, print a single number that gives the number of primitive roots in a single line.<br />Sample Input</p>
<p>23<br />31<br />79<br />Sample Output</p>
<p>10<br />8<br />24</p>
<p>&nbsp; &nbsp; &nbsp; 本题的意思是：若p是质数，则p有 phi(p-1)个原根。输入n，求欧拉函数phi(n-1)的值。</p>
<p>&nbsp; &nbsp; &nbsp; （1）采用公式直接计算欧拉函数。&nbsp;</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />int getPhiValue(int n)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 求n的欧拉函数值phi(n)<br />{<br />&nbsp; &nbsp; &nbsp; int i,sum,t;<br />&nbsp; &nbsp; &nbsp; sum = n;<br />&nbsp; &nbsp; &nbsp; t=n;<br />&nbsp; &nbsp; &nbsp; for (i=2;i*i&lt;=t;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (t % i == 0) // 找到一个质因数i<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum -= sum/i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (t % i == 0)&nbsp; &nbsp; &nbsp; &nbsp;// 将质因数i全去掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t /= i;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; if (t!=1) sum -= sum/t;<br />&nbsp; &nbsp; &nbsp; return sum;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int p;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;p) !=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",getPhiValue(p-1));<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; （2）采用埃拉托斯特尼筛求欧拉函数。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define  MAXN  65536<br />int phi[MAXN];<br />void getPhiTable(int n) // 求2~n的欧拉函数值phi[i] （1&lt;i&lt;=n)<br />{<br />&nbsp; &nbsp; &nbsp; int i,j;<br />&nbsp; &nbsp; &nbsp; memset(phi,0,sizeof(phi));<br />&nbsp; &nbsp; &nbsp; phi[1]=1;<br />&nbsp; &nbsp; &nbsp; for (i=2; i &lt;= n; i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (phi[i]==0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // i在筛子中，是质数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = i; j &lt;= n; j+=i)&nbsp; &nbsp; &nbsp; &nbsp;// 处理i的倍数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (phi[j]==0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 在筛子中，筛掉<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[j] = j;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[j] = phi[j]/i*(i-1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int p;<br />&nbsp; &nbsp; &nbsp; getPhiTable(MAXN);<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;p) !=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d\n",phi[p-1]);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; return 0;<br />}</p>
<p>&nbsp; &nbsp; &nbsp; （3）采用欧拉筛求欧拉函数。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define  MAXN  65536<br />int phi[MAXN];<br />int prime[MAXN], pNum;<br />bool vis[MAXN];<br />void getPhiTable(int n) // 求2~n的欧拉函数值phi[i] （1&lt;i&lt;=n)<br />{<br />&nbsp; &nbsp; &nbsp; int i,j;<br />&nbsp; &nbsp; &nbsp; memset(vis,true,sizeof(vis));<br />&nbsp; &nbsp; &nbsp; pNum=0;<br />&nbsp; &nbsp; &nbsp; phi[1] = 1;<br />&nbsp; &nbsp; &nbsp; for (i = 2; i &lt; MAXN; i++)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (vis[i])&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//  i是素数<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prime[pNum++] = i; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[i] = i-1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 0; j &lt; pNum &amp;&amp; prime[j]*i &lt;MAXN; j++ )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vis[prime[j]*i] = false;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i % prime[j] == 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[i*prime[j]] = phi[i] * prime[j];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phi[i*prime[j]] = phi[i] *(prime[j] - 1);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; }<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int p;<br />&nbsp; &nbsp; &nbsp; getPhiTable(MAXN);<br />&nbsp; &nbsp; &nbsp; while (scanf("%d", &amp;p) !=EOF)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n",phi[p-1]);<br />&nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp;return 0;<br />}</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>