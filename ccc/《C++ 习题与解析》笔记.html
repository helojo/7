<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修《C++ 习题与解析》笔记' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>《C++ 习题与解析》笔记</center></div><div class='banquan'>原文出处:本文由博客园博主slrn提供。<br/>
原文连接:https://www.cnblogs.com/simon-slrn/p/11751038.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#chapter-1-c语言概述错题">####Chapter-1 C++语言概述（错题）</a></li>
        <li><a href="#chapter-2-类和对象">####Chapter-2 类和对象</a></li>
        <li><a href="#chapter-3-引用">####Chapter-3 引用</a></li>
        <li><a href="#chapter-4-友元函数">####Chapter-4 友元函数</a></li>
        <li><a href="#chapter-5-运算符重载">#### Chapter-5 运算符重载</a></li>
        <li><a href="#chapter-6-继承与派生错题">#### Chapter-6 继承与派生（错题）</a></li>
        <li><a href="#chapter-7-多态性和虚函数">#### Chapter-7 多态性和虚函数</a></li>
        <li><a href="#chapter-8-异常处理">#### Chapter-8 异常处理</a></li>
        </ul>
    </div>
</div>
<p><strong>C++基础：</strong> 基础数据类型，简单输入输出，流程控制语句，函数与编译预处理，数组，结构体，指针与引用<br />
<strong>C++面向对象部分：</strong> 类与对象，构造和析构函数，继承与派生，友元，虚函数，静态成员，运算符重载</p>
<h4 id="chapter-1-c语言概述">Chapter-1 C++语言概述</h4>
<h5 id="位运算操作符">位运算操作符</h5>
<pre><code>单目：~（按位求反）
双目：&amp;（与）、 |（或）、 ^（按位异或）</code></pre>
<h5 id="移位运算符">移位运算符</h5>
<p><code>&lt;&lt;   (左移):   左移是将一个二进制数按指定的位数向左移位，移掉的位被丢弃，右边移出的空位一律补0</code><br />
<code>&gt;&gt;   (右移):   右移是将一个二进制数按指定的位数向右移位，移掉的位被丢弃，左边移出的空位一律补0，或补符号位</code></p>
<h5 id="逗号运算符">逗号运算符</h5>
<p><code>d1, d2, d3, d4: 计算一个逗号表达式的值时，从左至右依次计算各个表达式的值，最后计算的一个表达式的值和类型便是整个逗号表达式的值和类型</code></p>
<h5 id="二维数组指针表示">二维数组指针表示</h5>
<pre><code>    //输出对应的值的三种方法
    int b[2][3]; 
    a. *(*(b+i)+j)
    b. *(b[i]+j)
    c. *(&amp;b[0][0]+3*i+j)</code></pre>
<h5 id="const-位置与指向问题">const 位置与指向问题</h5>
<pre><code>    //都定义了a是一个常整数，不能修改a的值
    int const a = 1;
    const int a = 1;

    int b[] = {1,2,3}
    const int *a = b; // a为指向常整数的指针，a为数组b的首地址，a指向的整数不可修改，不能通过a来修改其指向的值，但可以通过b来修改数组值，而且a可以指向其他数组
    int * const a = b; // a为指向整数的常指针，a为数组b的首地址，a指向的整数可以修改，但是指针a不可修改，不能让a指向其他数组，也不能执行a++语句</code></pre>
<h5 id="指针传址操作">指针传址操作</h5>
<pre><code>void swap()
{
    int a = 1,b=2;
    int&amp; a1 = a;
    int&amp; b1 = b;
    swap1(a,b); //传变量的值（在方法内操作的只是temp，改变不了实际ab的值） 
    swap2(&amp;a,&amp;b); //传变量的地址（直接操作内存地址的值，最粗暴的方式 ） 
    swap3(a1,b1); //传变量的引用 （变量与变量的别名，它们的地址是同一个，直接操作ab的值 ） 
    cout&lt;&lt; a &lt;&lt; &quot;，&quot; &lt;&lt; b; 
}

void pointer2(){
    int  a=10;
    int&amp; b =a;
    int  *q;
    q = &amp;a;
    
    //修改a的值 
    *q = 2;
    printf(&quot;%d\n&quot;,*q);
    changeValue(q);//不行
    changeValue2(&amp;q);//（ok）传二级指针修改值 
    changeValue3(b);//（ok）直接传引用修改值 
    printf(&quot;%d\n&quot;,*q);
}
void changeValue(int *p){//传进来的p是a的地址，或者说p只是一个普通变量，这个变量存放了a的地址 
    int  b=100;
    p = &amp;b;//因为p是一个变量，所以，这边的p是个副本_p，对副本进行操作，并不会改变实际a的值 
}
void changeValue2(int **p){//传进来的是p的地址，不是a的地址！！ 
    int  b=100;
    *p = &amp;b;//这边虽然也有一个副本_p，但是没有影响，因为*p取到p地址的值，也就是a的地址，然后修改其值 
}
void changeValue3(int&amp; p){
    p = 100;//引用理解为是对指针进行了封装，使用起来简单 
}
</code></pre>
<h2 id="chapter-1-c语言概述错题">####Chapter-1 C++语言概述（错题）</h2>
<ul>
<li><strong>[例1.3]</strong></li>
</ul>
<pre class="cpp"><code>   int i=1；
   void max()
   { int i = i;} 
   //main()里的i是未定义值，是局部变量，当执行int i=i;时，先在内存中为局部变量i分配内存空间，其值是不确定的，然后执行i=i，由于值不确定，所以main()里的i是一个未定义值</code></pre>
<ul>
<li><p><strong>[例1.10]</strong><br />
在一定条件下，指针可以进行两种运算，即两个指针可以相减，一个指针可以与一个适当的<code>整数</code>相加减，但不能进行两个指针的相加运算</p></li>
<li><p><strong>[例1.16]</strong></p></li>
</ul>
<pre><code>    struct
    {
        float f; //4 byte
        char c;  //1 byte
        int adf[3]; //12byte;
    }x;
    cout &lt;&lt; sizeof(x) &lt;&lt; endl; // output: 20byte;
    //默认以4字节为对齐单位，f占4个字节，c占一个字节，adf占12个字节，总共17个字节。按4字节为对齐单位时，要选择4的倍数，即为20个字节。
    </code></pre>
<ul>
<li><strong>[例1.24]</strong><br />
<code>swicth(){     case _A_: 表达式。 }   //在A处：case之后只能用常量表达式，不能用实型表达式</code></li>
<li><strong>[例1.30]</strong></li>
</ul>
<pre><code> for(int i=0,j=10; i=j=10; i++,j--); //执行次数：无限次。 return i=j=10 -&gt; true</code></pre>
<ul>
<li><strong>[例1.36]</strong><br />
若要定义一个只允许本源文件所有函数使用的全局变量，应该使用的存储类别是：<strong>static</strong><br />
<code>c++规定，全局变量分为两种：extern和static型，前者的作用域为整个程序，后者的作用域为定义该变量的文件</code></li>
<li><strong>[例1.43]</strong></li>
</ul>
<pre><code>    void main()
    {
        int b = 3;
        int arr[] = {6,7,8,9,10};
        int *ptr = arr;
        *(ptr++) += 123;
        printf(&quot; %d, %d\n&quot;,*ptr,*(++ptr));  //output: 8 8 ;
    }</code></pre>
<p><code>对于printf语句，其参数从右向左运算，第一个是*(++ptr),第二个是*ptr</code></p>
<ul>
<li><strong>[例1.57]</strong><br />
<code>func(x)的功能是将x转化为2进制，求其中含有的</code>1<code>的个数</code></li>
</ul>
<pre><code>    int func(int x)
    {
        int countx = 0;
        while(x)
        {
            countx++;
            x = x &amp; (x-1);    //每一次计算对应2进制的一个1就会变成0 直到所有1都变为0循环结束
        }
        return countx;
    }</code></pre>
<hr />
<h2 id="chapter-2-类和对象">####Chapter-2 类和对象</h2>
<h5 id="定义类注意点">定义类注意点</h5>
<ol>
<li><code>类体中不允许对所定义的数据成员进行初始化</code></li>
<li><code>用new创建的类对象都是匿名对象，必须用一个指针指向它，通过该指针对这个对象进行操作 class A{..}; A *p =  new A;</code></li>
</ol>
<h5 id="拷贝构造函数">拷贝构造函数</h5>
<p><code>用一个已知对象来初始化一个被创建的同类对象</code></p>
<pre class="cpp"><code>class Sample{
    Sample(const Sample &amp;s){...}
}
void main(){
    Sample s1, s2(s1);
}</code></pre>
<p><code>使用情况如下：</code></p>
<ul>
<li>明确表示由一个对象初始化另一个对象时</li>
<li>当对象作为函数实参传递给函数形参时</li>
<li>当对象作为函数返回值时</li>
</ul>
<h5 id="调用析构函数">调用析构函数</h5>
<p><code>析构函数自动调用的情况</code></p>
<ul>
<li>对象被定义在一个函数体内，则当这个函数结束时，该对象的析构函数被自动调用</li>
<li>使用new运算符动态创建一个对象后，当使用delete运算符释放它时，delete将会自动调用析构函数</li>
</ul>
<p><code>析构函数的调用顺序与构造函数相反</code></p>
<pre><code>    void main(){
        Sample s1,s2(10); //析构函数调用时先释放s2,再释放s1
    }</code></pre>
<h5 id="深拷贝浅拷贝">深拷贝/浅拷贝</h5>
<p><code>浅拷贝：</code>当两个对象之间进行复制，复制完成后，还共享某些资源（内存空间），其中一个对象销毁会影响另一个对象，这种对象之间的复制称为对象浅复制</p>
<pre class="cpp"><code>class Sample{
private:    
    int no;
    char *pname;
public:
    Sample(const Sample &amp;s){
        no = s.no;
        pname = s.pname;
    }
}
void main(){
    Sample s1, s2(s1);
}</code></pre>
<p><code>深拷贝：</code>当两个对象之间进行复制，复制完成后，他们不会共享任何资源，其中一个对象的销毁不会影响另一个对象<br />
种对象之间的复制称为对象深复制</p>
<pre class="cpp"><code>class Sample{
private:    
    int no;
    char *pname;
public:
    Sample(const Sample &amp;s){
        no = s.no;
        // pname = s.pname;
        pname = new char[strlen(s.pname)+1];
        strcpy(pname,s.pname);
    }
}
void main(){
    Sample s1, s2(s1);
}</code></pre>
<h5 id="类成员函数指针">类成员函数指针</h5>
<pre><code>class Sample
{
    int m,n;
public: 
    void setm(int i){  m=i; }
    void setn(int i){  n=i; }
}
void main(){
    void(Sample::*pfun)(int);   //类成员函数指针
    Sample a;
    pfun=Sample::setm;          //指向Sample类成员函数setm;
    (a.*pfun)(10);
    pfun=Sample::setn;          //指向Sample类成员函数setn;
    (a.*pfun)(20);
}</code></pre>
<p><code>程序中类Sample的setm/setn成员函数必须具有相同的返回类型（这里均为void）,而且为public时才能这样使用</code></p>
<h5 id="子对象">子对象</h5>
<p><code>构造函数的执行次序是：（析构函数相反）</code></p>
<ol>
<li>以子对象在类中说明的顺序调用子对象初始化列表中列出的各构造函数<code>A(参数表)：obj(参数表2){  函数体; }</code></li>
<li>然后执行函数体</li>
</ol>
<pre class="cpp"><code>class B1{
public:
    B1(){cout &lt;&lt; &quot;B1:Constructor&quot; &lt;&lt; endl; }
    ~B1(){cout &lt;&lt; &quot;B1:Constructor&quot; &lt;&lt; endl; }
};
class B2{
public:
    B2(){cout &lt;&lt; &quot;B2:Constructor&quot; &lt;&lt; endl; }
    ~B2(){cout &lt;&lt; &quot;B2:Constructor&quot; &lt;&lt; endl; }
};
class B3{
public:
    B3(){cout &lt;&lt; &quot;B3:Constructor&quot; &lt;&lt; endl; }
    ~B3(){cout &lt;&lt; &quot;B3:Constructor&quot; &lt;&lt; endl; }
};

class A
{
    B1 b1;
    B2 b2;
    B3 b3;
pubilc:
    A():b3(),b2(),b1(){ cout&lt;&lt; &quot;A:Constructor&quot; &lt;&lt; endl; }
    ~A() { cout &lt;&lt; &quot;A:Destructor&quot; &lt;&lt; endl; }
};

void main()
{
    A a;
}

//Output
B1:Constructor
B2:Constructor
B3:Constructor
A:Constructor
B3:Destructor
B2:Destructor
B1:Destructor</code></pre>
<h5 id="常类型">常类型</h5>
<ol>
<li>常对象：</li>
</ol>
<pre><code>类名 const 对象名 / const 类名 对象名</code></pre>
<ul>
<li>声明为常对象的同时必须被初始化，并从此不能改写对象的数据成员。</li>
<li>常对象只能调用类的<strong>常成员函数</strong>或类的<strong>静态成员函数</strong></li>
</ul>
<p><code>const Sample a(10);</code></p>
<ol>
<li>常对象成员：
<ol>
<li>常成员函数<br />
<code>数据类型 函数名（参数表） const;</code></li>
</ol></li>
</ol>
<ul>
<li>常成员函数不更新对象的数据成员，也不能调用该类中没有用const修饰的成员函数</li>
<li>如果将一个对象声明为<strong>常对象</strong>，则通过该常对象<code>只能调用它的常成员函数</code>，而不能调用其他成员函数</li>
<li><code>const</code>关键字可以被用于参与对重载函数的区分：<br />
<code>void print();       void print() const; //正确的重载</code>
<ol>
<li>常对象成员：<br />
<code>只能通过初始化列表对该数据成员进行初始化</code></li>
</ol>
<pre class="cpp"><code>class Sample
{
    const int n;
public:
    Sample(int i):n(i){}
}</code></pre>
<h2 id="chapter-2-类和对象错题">####Chapter-2 类和对象（错题）</h2></li>
<li><strong>[例2.32]</strong><br />
已知<code>f1(int)</code>是类A的公有成员函数，p是指向成员函数f1的指针，为其赋值时正确的是：<code>p=A::f1</code></li>
<li><p><strong>[例2.35]</strong><br />
```<br />
class Test<br />
{<br />
public:<br />
Test(){}<br />
~Test(){cout &lt;&lt; '#'; }<br />
};</p>
<p>void main(){<br />
Test temp[2], <em>pTemp[2]; // 执行程序输出：2个'#'号<br />
}<br />
``<code></code>Test </em>pTemp[2]只建立了两个Test对象指针的数组，并没有创建Test对象，不会调用构造函数和析构函数`</p></li>
<li><p><strong>[例2.37]</strong><br />
```<br />
class point<br />
{<br />
public:<br />
point() { cout&lt;&lt;&quot;C&quot;; }<br />
~point() { cout&lt;&lt;&quot;D&quot;; }<br />
};</p>
<p>void main()<br />
{<br />
point <em>ptr;<br />
point A,B;<br />
point </em>ptr_point = new point[3];<br />
//output: CCCCCDD<br />
}<br />
``<code></code>没有delete ptr_point 因此没有调用对应的析构函数`</p></li>
<li><strong>[例2.55]</strong></li>
</ul>
<pre><code>class B
{
    int x,y;
public:
    B() {x=y=0; cout &lt;&lt; &quot;Constructor1&quot; &lt;&lt; endl; }
    B(int i) {x=i;y=0; cout &lt;&lt; &quot;Constructor2&quot; &lt;&lt; endl; }
    B(int i, int j) {x=i;y=j; cout &lt;&lt; &quot;Constructor3&quot; &lt;&lt; endl; }
    ~B(){ cout&lt;&lt;&quot;Destructor&quot; &lt;&lt; endl; }
    void print()
    { cout &lt;&lt; &quot;x=&quot; &lt;&lt; &quot;,y=&quot; &lt;&lt; y &lt;&lt; endl;}
}

void main()
{
    B *ptr;
    ptr = new B[3];
    ptr[0] = B();
    ptr[1] = B(5);
    ptr[2] = B(2,3);
    for(int i=0;i&lt;3;i++)
        ptr[i].print();
    delete[] ptr;
}

//output:
Constructor1
Constructor1
Constructor1
Constructor1
Destructor
Constructor2
Destructor
Constructor3
Destructor
x=0,y=0
x=5,y=0
x=2,y=3
Destructor
Destructor
Destructor</code></pre>
<h2 id="chapter-3-引用">####Chapter-3 引用</h2>
<h5 id="引用的概念">引用的概念</h5>
<ul>
<li>引用不是变量，引用必须初始化</li>
<li>引用不是值，不占存储空间，引用只有申明，没有定义</li>
<li>引用只在声明时带有<code>&amp;</code>，以后就像普通变量一样使用，不能再带<code>&amp;</code></li>
<li><p>指针变量也可引用<br />
<code>void main()   {       int n=10, *pn=&amp;n, *&amp;rn=pn;       (*pn)++;   //n=11       (*rn)++;   //n=12   }</code></p></li>
<li>对<code>void</code>的引用是不允许的</li>
<li>不能建立引用的数组</li>
<li>没有引用的引用</li>
<li><p>没有空引用</p></li>
</ul>
<h5 id="引用作为函数参数">引用作为函数参数</h5>
<pre class="cpp"><code>class Sample{...};
void fun(Sample s1,Sample &amp;s2)
{
    s1.setxy(12,18);   //不能对目标对象操作
    s2.setxy(23,15);   //能对目标对象操作
}</code></pre>
<h5 id="常引用">常引用</h5>
<p><code>常引用往往用作函数的形参，这样该函数中并不能更新该参数所引用的对象，从而保护实参不被修改</code></p>
<pre><code>    int x = 2;
    const int &amp;n = x;
    
    n++; //错误，不能通过常引用更新对象，但执行x++是正确的</code></pre>
<h5 id="引用和指针的区别">引用和指针的区别</h5>
<p><code>两者不同点：</code></p>
<ul>
<li>指针是个实体，而引用仅是个别名；引用不是变量，引用必须初始化，指针是变量，可以不用初始化。</li>
<li>指针是变量，可以不初始化。</li>
<li>引用不是值，不占存储空间，而指针变量会占用存储空间</li>
</ul>
<h2 id="chapter-4-友元函数">####Chapter-4 友元函数</h2>
<h5 id="友元函数概念">友元函数概念</h5>
<ul>
<li>友元函数是一种能够访问类中的<strong>私有成员</strong>的非成员函数，提高了程序的运行效率，破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员</li>
<li>友元函数可以是多个类的友元<code>friend double dist(Line l, Point p);</code></li>
<li>友元关系不能被继承</li>
<li><p>友元关系是单向的，不具有交换性。<code>若类B是类A的友元，类A不一定是类B的友元</code></p>
<h5 id="友元类">友元类</h5></li>
</ul>
<pre><code>class A
{
    ...
public:
    friend class B;
    ...
}</code></pre>
<p><code>当一个类作为另一个类的友元时，意味着这个类的所有成员函数（B）都是另一个类的友元函数(A),可以调用另一个类的私有变量（A）</code></p>
<h2 id="chapter-5-运算符重载">#### Chapter-5 运算符重载</h2>
<h5 id="重载为类的成员函数-类名-operator-运算符参数表">重载为类的成员函数 <code>类名 operator 运算符（参数表）</code></h5>
<pre><code>class Point
{
    int x,y;
public:
    Point(){}
    Point(int i, int j) {}
    Point operator+(Point &amp;p){ return Point(x+p.x,y+p.y); }
};</code></pre>
<h5 id="重载为类的友元函数">重载为类的友元函数</h5>
<pre><code>class Point
{
    int x,y;
public:
    Point(){}
    Point(int i, int j) {}
    friend Point operator+(Point &amp;p1, Point &amp;p2)
    { return Point(p1.x+p2.x,p1.y+p2.y); }
};</code></pre>
<ol>
<li><code>一般情况下，单目运算符最好重载为类的成员函数；双目运算符则最好重载为类的友元函数（=、()、[]、-&gt; 不能重载为类的友元函数</code></li>
<li><code>当需要重载运算符具有可交换性时，选择重载为友元函数</code></li>
</ol>
<h5 id="其他运算符重载">其他运算符重载</h5>
<ul>
<li><p>一元自加/自减运算符重载<br />
```<br />
class Number<br />
{<br />
int x;<br />
public:<br />
Number(){ x=0; }<br />
Number(int i){ x=i; }<br />
void disp(){ cout&lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl;}<br />
void operator++() {x++;} //前置运算符<br />
void operator++(int) {x+=2;}//后置运算符<br />
}</p>
<p>void main()<br />
{<br />
Number obj(5);<br />
obj.disp();<br />
++obj;<br />
obj.disp();<br />
obj++;<br />
obj.disp();<br />
}</p>
//output:<br />
x=5<br />
x=6<br />
x=8<br />
```</li>
<li>算术赋值运算符重载<br />
<code>cpp   class Vector   {       int x,y;   public:       void operator+=(Vector D) { x+=D.x; y+=D.y; }       void operator-=(Vector D) { x-=D.x; y-=D.y; }   }</code></li>
<li><p>关系运算符重载<br />
<code>cpp   class Rect   {       int length,width;   public:       friend int operator&gt;(Rect r1, Rect r2)       { return r1.length*r1.width &gt; r2.length*r2.width?1:0 }   }</code></p>
<h2 id="chapter-6-继承与派生">#### Chapter-6 继承与派生</h2>
<p><img src="./1572178272324.png" alt="Alt text" /></p>
<h5 id="单继承派生类的构造函数调用顺序">单继承派生类的构造函数调用顺序</h5>
<ol>
<li>基类的构造函数</li>
<li>子对象类的构造函数（如果有的话）</li>
<li>派生类构造函数</li>
</ol></li>
</ul>
<p><code>当基类的构造函数使用一个或多个参数时，则派生类必须定义构造函数，提供将参数传递给基类构造函数的途径。基类中有默认的构造函数或者根本没有定义构造函数时，派生类不必负责调用积累的构造函数</code></p>
<ul>
<li><code>基类指针引用一个派生类的对象。这种引用方式是安全的，但这种方法只能引用基类成员</code></li>
<li><p><code>派生类指针引用基类的对象，这种引用方式错误</code></p>
<h5 id="多继承派生类的构造函数调用顺序">多继承派生类的构造函数调用顺序</h5>
<ol>
<li>调用基类的构造函数，调用次序按照它们被继承时声明的次序（从左向右）</li>
<li>子对象类的构造函数，调用次序按照它们在类中声明的次序（与参数表顺序无关）</li>
<li><p>调用派生类构造函数<br />
```cpp</p>
<h1 id="include">include<iostream></h1>
<p>using namespace std;</p></li>
</ol></li>
</ul>
<p>class Base1<br />
{<br />
public:<br />
Base1(int x)<br />
{cout&lt;&lt;&quot;基类1构造函数&quot;&lt;&lt;&quot;X1= &quot;&lt;&lt;x&lt;&lt;endl;}<br />
~Base1()<br />
{cout&lt;&lt;&quot;基类1析构函数&quot;&lt;&lt;endl; }<br />
};<br />
class Base2<br />
{<br />
public:<br />
Base2(int x)<br />
{cout&lt;&lt;&quot;基类2构造函数&quot;&lt;&lt;&quot;X2= &quot;&lt;&lt;x&lt;&lt;endl;}<br />
~Base2()<br />
{cout&lt;&lt;&quot;基类2析构函数&quot;&lt;&lt;endl; }<br />
};<br />
class Base3<br />
{<br />
public:<br />
Base3()<br />
{cout&lt;&lt;&quot;基类3构造函数&quot;&lt;&lt;endl;}<br />
~Base3()<br />
{cout&lt;&lt;&quot;基类3析构函数&quot;&lt;&lt;endl; }<br />
};</p>
<p>class A:public Base2,public Base3,public Base1<br />
{<br />
public:<br />
A(int a,int b,int c,int d)<br />
:Base1(a),Base2(b),m1(c),m3(),m2(d)<br />
//此处如果基类构造函数没有参数，则可省略<br />
//基类和子函数的陈列，且顺序随意<br />
//or：Base1(a),Base2(b),m1(c),m2(d)<br />
{<br />
cout&lt;&lt;&quot;派生类构造函数&quot;&lt;&lt;endl;<br />
}<br />
~A()<br />
{<br />
cout&lt;&lt;&quot;派生类析构函数&quot;&lt;&lt;endl;<br />
}<br />
private:<br />
Base1 m1;<br />
Base2 m2;<br />
Base3 m3;<br />
};</p>
<p>int main()<br />
{<br />
A obj(1,2,3,4);<br />
return 0;<br />
}</p>
<p>//Output<br />
基类2构造函数X2=2<br />
基类3构造函数 //若基类无带参构造函数可以省略，因此参数表中无基类3<br />
基类1构造函数X1=1<br />
基类1构造函数X1=3 //我们需要按照他们在类中声明的顺序来分别构造基类1、基类2、基类3<br />
基类2构造函数X2=4<br />
基类3构造函数<br />
派生类构造函数<br />
派生类析构函数<br />
基类3析构函数<br />
基类2析构函数<br />
基类1析构函数<br />
基类1析构函数<br />
基类3析构函数<br />
基类2析构函数<br />
<code>##### 虚基类 - 虚基类的构造函数在非虚基类之前调用 - 若同一层次中包含多个虚基类，这些虚基类的构造函数按它们说明的顺序调用 - 若虚基类由非虚基类派生而来，则仍然遵循先调用基类构造函数，再调用派生类中构造函数的执行顺序</code>cpp<br />
class base1<br />
{<br />
public:<br />
base1() { cout &lt;&lt; &quot;class base1&quot; &lt;&lt; endl; }<br />
};</p>
<p>class base2<br />
{<br />
public:<br />
base2() {cout &lt;&lt; &quot;class base2&quot; &lt;&lt; endl; }<br />
}</p>
<p>class level1:public base2, virtual public base1<br />
{<br />
public:<br />
level1() {cout &lt;&lt;&quot;class level1&quot; &lt;&lt; endl;}<br />
}</p>
<p>class level2:public base2, virtual public base1<br />
{<br />
public:<br />
level2() {cout &lt;&lt;&quot;class level1&quot; &lt;&lt; endl;}<br />
}</p>
<p>class toplevel:public level1, virtual public level2<br />
{<br />
public:<br />
toplevel() {cout &lt;&lt;&quot;class toplevel&quot; &lt;&lt; endl;}<br />
}</p>
<p>void main() { toplevel obj; }</p>
<p>//output<br />
class base1<br />
class base2<br />
class level2<br />
class base2<br />
class level1<br />
class toplevel1<br />
``<code></code>toplevel1类中，level2为虚基类，因此，尽管level1在level2之前说明，但还是level2的执行在先。<code></code>level2中，base1类为虚基类，先执行。同一个虚基类只需要初始化一次，所以level1时不需要再初始化base1`<br />
<img src="./1572181099854.png" alt="Alt text" /></p>
<h2 id="chapter-6-继承与派生错题">#### Chapter-6 继承与派生（错题）</h2>
<ul>
<li><strong>[例7.31]</strong></li>
</ul>
<pre class="cpp"><code>class base
{
public:
    void who() { cout&lt;&lt;&quot;base class&quot;&lt;&lt;endl; }
}
class derive1:public base
{
public:
    void who() { cout&lt;&lt;&quot;derive1 class&quot;&lt;&lt;endl; }
}
class derive2:public base
{
public:
    void who() { cout&lt;&lt;&quot;derive2 class&quot;&lt;&lt;endl; }
}

void main()
{
    base obj1,*p;
    derive1 obj2;
    derivel obj3;
    p = &amp;obj1;
    p-&gt;who();
    p = &amp;obj2;
    p-&gt;who();
    p = &amp;obj3;
    p-&gt;who();
    obj2.who();
    obj3.who();
}

//output:
base class
base class
base class
derive1 class
derive2 class</code></pre>
<p><code>指针引起的普通成员函数的调用仅仅与指针类型有关，和此刻指针正指向的对象无关</code></p>
<h2 id="chapter-7-多态性和虚函数">#### Chapter-7 多态性和虚函数</h2>
<h5 id="静态联编动态联编">静态联编&amp;动态联编</h5>
<ul>
<li><strong>静态联编：</strong>编译时就解决了程序中的操作调用与执行该代码间的关系</li>
<li><strong>动态联编：</strong>只有在程序执行时才能确定将要调用的函数（虚函数支持下实现）
<ul>
<li><code>动态联编实现条件：</code>
<ul>
<li><ol>
<li>类之间为基类与派生类关系</li>
</ol></li>
<li><ol>
<li>要有虚函数</li>
</ol></li>
<li><ol>
<li>调用虚函数操作的是指向对象的指针或者对象引用，或者由成员函数调用虚函数</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
<h5 id="虚函数">虚函数</h5>
<ul>
<li>一个函数被声明为虚函数，即使重新定义类时没有声明虚函数，那么它从这点之后的继承层次结构中都是虚函数（若派生类声明为虚函数，基类没有声明为虚函数，应该以基类为准）</li>
<li>派生类的虚函数与基类中对应的虚函数的<strong>参数不同</strong>时，派生类的虚函数将丢失虚特性，变为重载函数</li>
</ul>
<h5 id="纯虚函数-抽象类">纯虚函数 &amp; 抽象类</h5>
<p><code>纯虚函数：基类中不能对虚函数给出有意义的定义</code><br />
<code>抽象类：带有纯虚函数的类称为抽象类，唯一用途是为其他类提供合适的基类</code></p>
<pre><code>class Class_Name
{
    virtual 类型 函数名(参数名) = 0；
}</code></pre>
<h5 id="虚析构函数">虚析构函数</h5>
<pre><code>class A
{
    virtual ~A() { cout&lt;&lt;&quot;调用A::~A()&quot; &lt;&lt; endl; }；
}

class B:public A
{
    virtual ~B() { cout&lt;&lt;&quot;调用B::~B()&quot; &lt;&lt; endl; }；
}

void main()
{
    A *a = new B();
}

//Output
调用B::~B()
调用A::~A()

//如果没有虚析构函数Output
调用A::~A()</code></pre>
<h2 id="chapter-8-异常处理">#### Chapter-8 异常处理</h2>
<h5 id="异常基础概念">异常基础概念</h5>
<p><code>catch处理程序的出现顺序很重要，在一个try块中，异常处理程序是按照它出现的顺序被检查的。只要找到一个匹配的异常类型，后面的异常处理都将被忽略</code></p>
<pre><code>void f(int code)
{
    try
    {
        if(code==0) throw code;     //引发int类型的yi&#39;chang
        if(code==1) throw &#39;x&#39;;      //引发字符型异常
        if(code==2) throw 12.345;   //引发double类型异常
    }
    catch(int n)
    { cout &lt;&lt; &quot;捕获整数类型: &quot;&lt;&lt; n &lt;&lt; endl;}
    catch(...)                      //可以捕获任何异常
    { cout &lt;&lt; &quot;默认捕获&quot;&lt;&lt; endl;}
    return；
}
void main()
{
    f(0);
    f(1);
    f(2);   
}

//Output
捕获整数类型: 0
默认捕获
默认捕获</code></pre>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>