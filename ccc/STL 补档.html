<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修STL 补档' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>STL 补档</center></div><div class='banquan'>原文出处:本文由博客园博主HATU提供。<br/>
原文连接:https://www.cnblogs.com/tushukai/p/11262250.html</div><br>
    <h1 id="stl-补档">STL 补档</h1>
<h4 id="vector"><strong>1.vector</strong></h4>
<p>作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。<br />
vector在C++标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的<a href="http://baike.baidu.com/view/1923683.htm">模板类</a>和函数库。<br />
它会动态申请空间，每新进来一个元素，就申请一个。申请着申请着你就MLE了（开玩笑的）。</p>
<pre><code>#include &lt;vector&gt;
using namespace std;
vector&lt;int&gt; vec;
vec.push_back(a);
cout&lt;&lt;vec[0]&lt;&lt;endl;
vector&lt;int&gt;::iterator it;//使用迭代器访问元素.
for(it=vec.begin();it!=vec.end();it++) cout&lt;&lt;*it&lt;&lt;endl;
vec.insert(vec.begin()+i,a);//在第i+1个元素前面插入a
 vec.erase(vec.begin()+2);//删除第3个元素</code></pre>
<p>部分参考https://www.cnblogs.com/msymm/p/9006022.html 感谢！！</p>
<h4 id="deque"><strong>2.deque</strong></h4>
<h3 id="容器属性"><strong>容器属性</strong></h3>
<p><strong>序列</strong> <strong>|</strong> <strong>动态数组</strong> <strong>|</strong> <strong>Allocator-aware</strong><br />
序列容器的元素按严格线性排列，可按顺序访问它们的位置；<br />
动态数组允许直接访问其任何元素，可快速在序列首尾相对快速进行元素添加 / 删除；<br />
容器通过 allocator 对象动态处理存储需求</p>
<p>除了写起来方便之外，时间复杂度很垃圾。。。</p>
<h3 id="迭代器相关函数"><strong>迭代器相关函数</strong>:</h3>
<p><strong>(public member function )</strong></p>
<p><strong>begin</strong><br />
将迭代器返回到开头（增长方向：begin -&gt; end）</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/end/"><strong>end</strong></a><br />
将迭代器返回到结尾</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/rbegin/"><strong>rbegin</strong></a><br />
返回反向迭代器以反向开始（增长方向：rbegin -&gt; rend）</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/rend/"><strong>rend</strong></a><br />
将反向迭代器返回到反向结束</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/cbegin/"><strong>cbegin</strong></a><strong>(C++11)</strong><br />
将const_iterator返回到开头（与begin类似，区别在于begin指向的值可以改变，cbegin指向的值不可改变）</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/cend/"><strong>cend</strong></a><strong>(C++11)</strong><br />
将const_iterator返回到开头末尾</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/crbegin/"><strong>crbegin</strong></a><strong>(C++11)</strong><br />
返回const_reverse_iterator以反向开始</p>
<p><a href="http://www.cplusplus.com/reference/deque/deque/crend/"><strong>crend</strong></a><strong>(C++11)</strong><br />
将const_reverse_iterator返回到反向结束</p>
<p>参考https://blog.csdn.net/Chnyac/article/details/82710050 感谢！！</p>
<h4 id="list"><strong>3.list</strong></h4>
<p>是一个双向链表</p>
<h2 id="关联容器">关联容器：</h2>
<h4 id="setmultiset">4.set/multiset</h4>
<p>multiset和set 可较快完成对一组数据的常规操作，包括：<br />
<a href="https://i.loli.net/2019/07/29/5d3e527f880fd96629.png" class="uri">https://i.loli.net/2019/07/29/5d3e527f880fd96629.png</a></p>
<p>multiset允许元素重复出现 set 保证元素唯一性，不允许元素重复</p>
<p>set操作：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;set&gt; //引入set库 
using namespace std;
int main() {
    set&lt;int&gt; s;  //定义包含整数的set 
    set&lt;int&gt;::iterator it;  //定义迭代器 
    s.insert(8);    //插入元素 
    s.insert(6);
    s.insert(6);
    s.insert(6);  
    //循环输出所有元素
    for(it=s.begin();it!=s.end();it++)   
        cout&lt;&lt;*it&lt;&lt;endl;
    return 0;
}
#include&lt;iostream&gt;
#include&lt;set&gt; //引入set库 
using namespace std;
int main() {
    set&lt;int&gt; s;  //定义包含整数的set 
    set&lt;int&gt;::iterator it;  //定义迭代器 
    s.insert(6);
    s.insert(6);    
    cout&lt;&lt;s.count(6)&lt;&lt;endl; //返回6的个数
    cout&lt;&lt;s.count(7)&lt;&lt;endl; 
    return 0;
}
#include&lt;iostream&gt;
#include&lt;set&gt; 
using namespace std;
int main() {
    set&lt;int&gt; s;  
    s.insert(1);    
    s.insert(2);    
    s.insert(3);    
    s.insert(3);
    cout&lt;&lt;s.size(); //求总数 
    return 0;
}
#include&lt;iostream&gt;
#include&lt;set&gt; //引入set库 
using namespace std;
int main() {
    set&lt;int&gt; s;  //定义包含整数的set 
    set&lt;int&gt;::iterator it;  //定义迭代器 
    s.insert(8);    //插入元素 
    s.insert(6);    
    s.erase(6);     //删除元素
    s.erase(6);   
    for(it=s.begin();it!=s.end();it++)   
        cout&lt;&lt;*it&lt;&lt;endl;
    return 0;
}
#include&lt;iostream&gt;
#include&lt;set&gt; //引入set库 
using namespace std;
int main() {
    set&lt;int&gt; s;  //定义包含整数的set 
    set&lt;int&gt;::iterator it;  //定义迭代器 
    s.insert(6);     
    if(s.find(6)!=s.end())cout&lt;&lt;&quot;Found!&quot;&lt;&lt;endl;
    else cout&lt;&lt;&quot;Not found!&quot;&lt;&lt;endl;
    if(s.find(7)!=s.end())cout&lt;&lt;&quot;Found!&quot;&lt;&lt;endl;
    else cout&lt;&lt;&quot;Not found!&quot;&lt;&lt;endl;
    return 0;
}
</code></pre>
<h4 id="mapmultimap">5.map/multimap</h4>
<p>一个映射</p>
<p>操作有：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main(){
    map&lt;char,int&gt; d;
    map&lt;char,int&gt;::iterator it;
    // insert some values:
    d[&#39;a&#39;]=10; d[&#39;b&#39;]=20;
    d[&#39;c&#39;]=30; d[&#39;d&#39;]=40;
    d[&#39;e&#39;]=50; d[&#39;f&#39;]=60;
    it=d.find(&#39;b&#39;);
    if(it!=d.end()) d.erase(it); // erasing by iterator
    d.erase(&#39;c&#39;);  // erasing by key
    d.erase(&#39;x&#39;);  // erasing by key
    // show content:
    for(it=d.begin(); it!=d.end(); ++it)
        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;
    return 0;
}


#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main (){
    map&lt;char,int&gt; d;
    map&lt;char,int&gt;::iterator it;
    d[&#39;a&#39;]=50;  d[&#39;b&#39;]=100;
    d[&#39;c&#39;]=150; d[&#39;d&#39;]=200;
    it=d.find(&#39;b&#39;);
    if(it!=d.end())
        d.erase(it);
    cout&lt;&lt;&quot;a =&gt; &quot;&lt;&lt;d.find(&#39;a&#39;)-&gt;second&lt;&lt;endl;
    cout&lt;&lt;&quot;c =&gt; &quot;&lt;&lt;d.find(&#39;c&#39;)-&gt;second&lt;&lt;endl;
    cout&lt;&lt;&quot;d =&gt; &quot;&lt;&lt;d.find(&#39;d&#39;)-&gt;second&lt;&lt;endl;
    return 0;
}

#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main(){
    map&lt;char,int&gt; d;
    d[&#39;a&#39;]=101;
    d[&#39;b&#39;]=202;
    d[&#39;c&#39;]=302;
    //cout&lt;&lt;d[&#39;x&#39;]&lt;&lt;endl;
    cout&lt;&lt;d.size()&lt;&lt;endl;
    return 0;
}

// accessing mapped values
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
int main(){
  std::map&lt;char,std::string&gt; mymap;
  mymap[&#39;a&#39;]=&quot;an element&quot;;
  mymap[&#39;b&#39;]=&quot;another element&quot;;
  mymap[&#39;c&#39;]=mymap[&#39;b&#39;];
  std::cout &lt;&lt; &quot;mymap[&#39;a&#39;] is &quot; &lt;&lt; mymap[&#39;a&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;b&#39;] is &quot; &lt;&lt; mymap[&#39;b&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;c&#39;] is &quot; &lt;&lt; mymap[&#39;c&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;d&#39;] is &quot; &lt;&lt; mymap[&#39;d&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap now contains &quot; &lt;&lt; mymap.size() &lt;&lt; &quot; elements.\n&quot;;
  return 0;
}
/*
Notice how the last access (to element &#39;d&#39;) 
inserts a new element in the map with that key 
and initialized to its default value (an empty string)
even though it is accessed only to retrieve its value. 
Member function map::find does not produce this effect.
*/
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;
int main(){
    map&lt;char,int&gt; d;
    map&lt;char,int&gt;::iterator it;
    d[&#39;b&#39;] = 100;
    d[&#39;a&#39;] = 200;
    d[&#39;c&#39;] = 300;
    // show content:
    for(it=d.begin();it!=d.end();++it)
        cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;
    for(it=d.begin();it!=d.end();++it)
        cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second&lt;&lt;endl;   
    return 0;
}
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
int main(){
    map&lt;char,string&gt; d;
    d[&#39;a&#39;]=&quot;wawawa&quot;;
    d[&#39;b&#39;]=&quot;hahaha&quot;;
    d[&#39;c&#39;]=d[&#39;a&#39;];
    d[&#39;b&#39;]=&quot;hohoho&quot;;
    cout&lt;&lt;d[&#39;a&#39;]&lt;&lt;endl;
    cout&lt;&lt;d[&#39;b&#39;]&lt;&lt;endl;
    cout&lt;&lt;d[&#39;c&#39;]&lt;&lt;endl;
    cout&lt;&lt;d[&#39;x&#39;]&lt;&lt;endl;
    return 0;
}

</code></pre>
<h5 id="共有的成员函数">共有的成员函数：</h5>
<p>empty size swap</p>
<h3 id="至于我前面讲的-stack-queue-都是-辣鸡-很慢千万别用-最好自己写">至于我前面讲的 stack queue 都是 辣鸡 很慢，千万别用。 最好自己写。</h3>
<p>感谢大家阅读。。！</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>