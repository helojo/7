<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修分享一个Linux C++消息通信框架TCPSHM' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>分享一个Linux C++消息通信框架TCPSHM</center></div><div class='banquan'>原文出处:本文由博客园博主it-hao提供。<br/>
原文连接:https://www.cnblogs.com/it-hao/p/11931331.html</div><br>
    <p>由于本人从事行业关系，Linux环境下的低延迟通信是我关注的技术之一。要达到极端的低延迟，当然同机器内IPC比网络通信快，而Linux IPC方式中无疑是共享内存延迟最低。不过相对于TCP这种通用的通信方式来说，共享内存缺少了一些控制层的协议，比如进程A和B通过一个基于共享内存的消息队列通信，A很难知道队列另一端的B是否存在，具体的说就是基于共享内存的简单消息队列缺少了连接建立和断开的控制。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>另一方面，相对于SHM(共享内存)来说，使用TCP也有些自己的痛点：除了延迟以外，重连恢复是个所有应用场景下都不可避免的问题。我们知道，由于网络问题或进程崩溃，TCP连接断开是很常见的事情，断开前发送方发出的数据可能没有被接收，也可能接收了还没被处理接收方就挂了，所以为了确保不丢失信息，发送方的应用程序需要保存已发送的信息，即使自己并不需要，等收到对方的确认消息才能丢弃。也就是说，一个真正可靠的TCP应用程序需要做很多无关业务的控制层的事情。而这个问题SHM并不存在，只要机器不掉电，程序的崩溃与重启对于SHM是透明的，也就是说崩溃前已写入且未读取的数据还会在那里，程序重启后不需做任何数据重传之类的事情。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p>于是我想，如果TCP和SHM分别弥补了上述各自的缺点，那么它们使用起来将会及其相似：就像一个带连接属性的持久化消息队列，用户可以像操作一个普通消息队列一样push和pop消息，对于发送方来说已经push的消息不需要自己保存副本，对于接受方来说没有pop的消息不会丢失，同时双方都能知道对方是否还活着。这样一个抽象的消息队列可以基于TCP，以支持远程通信，也可以基于SHM, 以提供超低延迟，这对于用户来说可以完全透明。</p>
<p class="ztext-empty-paragraph">&nbsp;</p>
<p><a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//github.com/MengRao/tcpshm" rel="nofollow noreferrer" target="_blank" data-za-detail-view-id="1043">TCPSHM</a>就是这样一个解决方案。TCPSHM是一个Linux下的轻量级高性能的C++模板类库开源项目，提供了客户端和服务端的框架，同时高度可配置和可定制。欢迎感兴趣的同学了解一下，并提出宝贵的意见，谢谢~</p>
<p><img src="./images/分享一个Linux C++消息通信框架TCPSHM0.png" alt="" /></p>
<p>链接：<a href="https://pan.baidu.com/s/1v5gm7n0L7TGyejCmQrMh2g" target="_blank">https://pan.baidu.com/s/1v5gm7n0L7TGyejCmQrMh2g</a>&nbsp;提取码：x2p5<br /><br />免费分享，但是X度限制严重，如若链接失效点击链接或搜索加群 群号<a href="https://jq.qq.com/?_wv=1027&amp;k=5Dg8XlT" target="_blank">744933466</a>。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>