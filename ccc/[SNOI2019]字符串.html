<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修[SNOI2019]字符串' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>[SNOI2019]字符串</center></div><div class='banquan'>原文出处:本文由博客园博主ANY_HOW提供。<br/>
原文连接:https://www.cnblogs.com/Alvin-Tree/p/11468582.html</div><br>
    <p>[TOC]</p>
<p>名称：字符串</p>
<p>来源：2019年陕西省选</p>
<h1 id="section">链接</h1>
<h2 id="section-1">博客链接</h2>
<ul>
<li><a href="https://blog.csdn.net/weixin_43890363/article/details/100547332">CSDN</a></li>
<li><a href="https://www.luogu.org/blog/131abc155-7341-6424/solution-p5329">洛谷博客</a></li>
<li><a href="https://www.luogu.org/problemnew/solution/P5329">洛谷题解</a></li>
</ul>
<h2 id="section-2">题目链接</h2>
<ul>
<li><a href="https://www.luogu.org/problem/P5329">洛谷(P5392)</a></li>
</ul>
<h1 id="section-3">题目内容</h1>
<h2 id="section-4">题目描述</h2>
<p>给出一个长度为$n$的由小写字母组成的字符串$a$，设其中第$i$个字符为$a_i(1≤i≤n)$。</p>
<p>设删掉第$i$个字符之后得到的字符串为$s_i$，请按照字典序对$s_1,s_2,……,s_n$从小到大排序。若两个字符串相等，则认为编号小的字符串字典序更小。</p>
<h2 id="section-5">格式</h2>
<h3 id="section-6">输入</h3>
<p>第一行一个整数$n$。
第二行一个长为$n$的由小写字母组成的字符串$a$。</p>
<h3 id="section-7">输出</h3>
<p>输出一行$n$个整数$k_1,k_2,……,k_n$，用空格隔开。表示$ s_&lt;s_&lt;……&lt;s_ $。</p>
<h1 id="section-8">数据</h1>
<h2 id="section-9">样例</h2>
<h3 id="section-10">输入</h3>
<pre><code>7
aabaaab
</code></pre>
<h3 id="section-11">输出</h3>
<pre><code>3 7 4 5 6 1 2
</code></pre>
<h2 id="section-12">数据范围</h2>
<p>对于所有数据， $1\leq n\leq10^6$ 。</p>
<p>对于10%的数据， $1\leq n\leq2000$ 。</p>
<p>对于另外20%的数据，$1\leq n\leq10^5$ 。且任意两个相邻字符$a_i,a_{i+1}$不相等；</p>
<p>对于另外30%的数据，$1\leq n\leq10^5$。
对于余下40%的数据，无特殊限制。</p>
<h1 id="section-13">提示</h1>
<p>本题不需要<strong>SA</strong>或者<strong>SAM</strong>等高级算法。</p>
<h1 id="section-14">题解</h1>
<h2 id="section-15">10分</h2>
<p>暴力构造出$s$，再用快速排序进行排序。时间复杂度为$O(n^2log(n))$，在$n\leq2000$的数据下跑得过。</p>
<h2 id="section-16">30分</h2>
<p>注意到：其中20%的数据没相邻两个字符不相等。</p>
<blockquote>
<p>引理
当其任意两个字符不相等时，$s_i$和$s_j(i&lt;j)$的大小关系实际上就是$a_{i+1}$与$a_i$的大小关系。
证明：由题意得。</p>
<div class="math">\[s_i[1……i-1]=a[1……i-1]=s_j[1……i-1]\\
s_i[j……n-1]=a[j+1……n]=s_j[j……n-1]
\]</div>
<p>重点在于比较$s_i[i……j-1]$和$s_j[i……j-1]$的大小关系。
$s_i[i……j-1]$正对应$a[i+1……j]$；
$s_j[i……j-1]$正对应$a[i……j-1]$；
而$a[i+1]!=a[i]$，故二者的大小关系可以确定。</p>
</blockquote>
<p>于是，我们可以开一个双端队列。逆序处理整个字符串。
当我们发现$a[i+1]&lt;a[i]$时，则说明$s_i$比后面的（即已经被处理过放进双端队列里的）都要小，就把数字$i$放在双端队列的前面；否则说明$s_i$比后面的都要大，就把它放在双端队列的后面。</p>
<div class="mermaid">graph TD
a(开始处理状态i)-->b{a_i+1&lt; a_i}
b-->|yes|c[将i插在双端队列前面]
b-->|no|d[将i插在双端队列后面]
c-->e(进入下一轮操作)
d-->e
</div>
<p>最后我们按顺序将双端队列每一个位置上的数字。</p>
<h2 id="section-17">100分</h2>
<p>那么，我们如何拿到100分呢？？？
实际上，我们只需要将原来30分的做法进行扩展，或者说将所有情况转换为两两相邻字符不相等的情况就行。</p>
<blockquote>
<p>引理
当$a[i]=a[i+1]$时，<span class="math">\(s[i]=s[i+1]\)</span>
证明略</p>
</blockquote>
<p>由此，我们就可以将字符串连续相同的一段进行压缩，其中每一个字母都代表着原字符串的一段区间。
例如$&quot;bbbcaa&quot;<span class="math">\(压缩成\)</span>&quot;bca&quot;$，并且处理出来如下数据：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">字母</th>
<th>开始位置</th>
<th>结束位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">b</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td style="text-align: left;">c</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td style="text-align: left;">a</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<blockquote>
<p>将压缩后的串排序得$3\quad1\quad2$。
将原来处理出来的数据带入得$(5\quad6)(1\quad2\quad3)(4)$。</p>
</blockquote>
<pre><code class="language-cpp">//C++
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string&gt;
#include&lt;deque&gt;
using namespace std;
const int nn=1000001;
inline void output(long long o);
int start[nn],final[nn];
inline long long input();
string a;
deque&lt;int&gt;k;
int main()
{
	int n=input(),size=0;
	cin&gt;&gt;a;
	for(int i=0,PREV=0;i&lt;n;i++)
	{
		PREV=i;
		while(a[i]==a[i+1]&amp;&amp;i&lt;n)i++;
		a[size]=a[i],start[size]=PREV+1,final[size++]=i+1;
	}
	for(int i=size-1;i&gt;=0;i--)
	if(a[i+1]&lt;a[i])k.push_front(i);
	else k.push_back(i);
	for(;k.front()!=k.back();k.pop_front())
	for(int i=start[k.front()],f=final[k.front()];i&lt;=f;i++)output(i),putchar(' ');
	for(int i=start[k.front()],f=final[k.front()];i&lt;f;i++)output(i),putchar(' ');
	output(final[k.front()]),putchar('\n');
	return 0;
}
inline void output(long long o)
{
	if(o&lt;0)putchar('-'),o=-o;
	if(o&gt;=10)output(o/10);
	putchar(o%10^'0');
}
inline long long input()
{
	bool positive=true;
	char now=getchar();
	long long i=0;
	for(;!isdigit(now);now=getchar())
	if(now=='-')positive=!positive;
	for(;isdigit(now);now=getchar())i=(i&lt;&lt;3)+(i&lt;&lt;1)+(now^'0');
	return positive?i:-i;
}
</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>