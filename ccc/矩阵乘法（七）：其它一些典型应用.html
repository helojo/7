<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修矩阵乘法（七）：其它一些典型应用' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>矩阵乘法（七）：其它一些典型应用</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11479080.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 前面几篇随笔中介绍了利用矩阵乘法（特别是应用快速幂运算）解决递推快速求值、置换和几何变换等问题的方法。实际上矩阵乘法的应用远不止这些，下面通过几个实例来介绍下矩阵乘法的其它一些典型的应用。</p>
<p><strong><span style="font-size: 16px;">【例1】多少条道。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 给定一个有向图，问从A点恰好走k步（允许重复经过边）到达B点的方案数mod p的值。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; 本题是矩阵乘法应用在图论中的一个典型方法。<br />&nbsp; &nbsp; &nbsp; 给定了有向图，可以得到该图的邻接矩阵A，在邻接矩阵A中，A(i,j)=1当且仅当存在一条边i-&gt;j。若i-&gt;j不存在直接相连接的边，则A(i,j)=0。</p>
<p>&nbsp; &nbsp; &nbsp; 令C=A*A，那么 C(i,j)= &Sigma;A(i,k)*A(k,j)，实际上就等于从点i到点j恰好经过2条边的路径数（k为中转点）。</p>
<p>&nbsp; &nbsp; &nbsp; 类似地，C*A =A*A*A的第i行第j列就表示从i到j经过3条边的路径数。同理，如果要求经过k步的路径数，只需要采用快速幂运算求出A^k即可。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MOD 1000<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; int mat[21][21];   // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n,int m)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % m;<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b,int m) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n,m); // c=c*a; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = matMul(a ,a ,n,m); // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,s,t,nCase,a,b,k,i;<br />&nbsp; &nbsp; &nbsp; Matrix p,ans;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m!=0)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=m;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scanf("%d%d",&amp;s,&amp;t);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[s+1][t+1]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d",&amp;nCase);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=nCase;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d%d%d",&amp;a,&amp;b,&amp;k);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans=quickMatPow(p,n,k,MOD);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("%d\n" ,ans.mat[a+1][b+1]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p style="margin-left: 30px;">将此源程序提交给 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2157" target="_blank">HDU 2157 &ldquo;How many ways??&rdquo;</a>，可以Accepted。</p>
<p>&nbsp; </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们知道，构造好平移、缩放或旋转的转换矩阵后，可以实现几何变换；构造好置换矩阵后，可以实现置换操作。这样，在一些问题中，我们也可以根据状态变化的情况，构造一个状态转移矩阵，来解决一些状态变换类问题。</p>
<p><strong><span style="font-size: 16px;">【例2】灯的状态。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;有n盏灯排成一排，开关状态已知，0代表灯熄灭，1代表点亮。每过一秒：第i（1&lt;=i&lt;=n）盏灯会根据刚才左边的那个灯的开关情况变化，如果左边的灯是亮的，它就会变化，如果左边的灯是熄灭的，它就保持原来状态。第1盏灯的左边是最后一盏灯。问m秒后全部n盏灯的状态。</p>
<p> &nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 设f[i]代表第i盏灯的状态，f[i]=1代表第i盏灯是点亮的，f[i]=0代表第i盏灯是熄灭的。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 对于第i（1&lt;i&lt;=n）盏灯，若第i-1盏灯点亮的：&nbsp;当前灯的动作: &nbsp; 1-&gt;0; &nbsp;0-&gt;1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;若第i-1盏灯熄灭的：&nbsp;当前灯的动作：&nbsp;1-&gt;1; 0-&gt;0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 由此，可推得 &nbsp;f[i]=(f[i]+f[i-1])%2 &nbsp;（1&lt;i&lt;=n）。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对于第1盏灯，它的状态变化与第n盏灯相关，即&nbsp;&nbsp;f[1]=(f[1]+f[n])%2 。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由此，我们可以构造一个n*n的状态转移矩阵P来完成灯的状态转换。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（七）：其它一些典型应用0.png" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="./images/矩阵乘法（七）：其它一些典型应用1.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 构造好状态转移矩阵P，P^m的结果就是m秒后的状态转移矩阵。再将状态转移矩阵除以n盏灯初始状态列向量F即可得到n盏灯的最终状态。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#define MOD 2<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; int mat[101][101];  // 存储矩阵中各元素<br />};<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp;Matrix c;<br />&nbsp; &nbsp; &nbsp;memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp;int i,j,k;<br />&nbsp; &nbsp; &nbsp;for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (a.mat[i][k]!=0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]) % MOD;<br />&nbsp; &nbsp; &nbsp;return c;<br />}<br />Matrix quickMatPow(Matrix a ,int n,int b) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while (b!=0)<br />&nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = matMul(c ,a ,n); // c=c*a; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = matMul(a ,a ,n); // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int m,n,i,j,s;<br />&nbsp; &nbsp; &nbsp; char f[101];<br />&nbsp; &nbsp; &nbsp; int temp[101],ans[101];<br />&nbsp; &nbsp; &nbsp; Matrix p;<br />&nbsp; &nbsp; &nbsp; while(scanf("%d" ,&amp;m)!=EOF)<br />&nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%s",f);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n=strlen(f);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[i]=f[i-1]-'0';<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(p.mat,0,sizeof(p.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.mat[1][1]=p.mat[1][n]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=2;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p.mat[i][i-1]=p.mat[i][i]=1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = quickMatPow(p,n,m);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s=0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (j=1;j&lt;=n;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s+=p.mat[i][j]*temp[j];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans[i]=s%MOD;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1;i&lt;=n;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%d" ,ans[i]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0; <br />}</p>
<p>&nbsp; &nbsp; &nbsp;将此源程序提交给<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2276" target="_blank"> HDU 2276 &ldquo;Kiki &amp; Little Kiki 2&rdquo;</a>，可以Accepted。</p>
<p>&nbsp;<strong><span style="font-size: 16px;">【例3】训练小猫。</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 用k个操作序列来训练n只小猫。 操作系列中： </p>
<p>&nbsp; &nbsp; &nbsp; g &nbsp;i：表示第i只猫得到一个花生，&nbsp;e &nbsp;i ：表示第i只猫吃掉所有花生，s i j ：表示第i只猫和第j只猫交换花生。<br />&nbsp; &nbsp; &nbsp; k个操作序列要被重复m次，问最后每只猫有多少花生。</p>
<p>&nbsp; &nbsp; &nbsp; （1）编程思路。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;构造一个（n+1）*（n+1）（下标从1开始）的转换矩阵P，该转换矩阵根据K个操作序列来构造，具体构造方法是：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;先将P初始化为单位矩阵。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对于g i操作，将当前矩阵P的第i行的第（n+1）列加1。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;例如，有3只小猫，某次操作前3只小猫的花生数分别为x,y和z。 执行 g 2 操作。矩阵的构造表示为</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="./images/矩阵乘法（七）：其它一些典型应用2.png" alt="" /></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp; 对于&nbsp;e &nbsp;i 操作：将当前矩阵P第i行全部清0即可。</p>
<p>&nbsp; &nbsp; &nbsp; 对于 s i j 操作 ：交换当前矩阵P的第i行和第j行即可。</p>
<p>&nbsp; &nbsp; &nbsp; 构造好了转换矩阵（注意该转换矩阵代表着一次k个操作序列），执行P^m，相当将k个操作序列重复m次。</p>
<p>&nbsp; &nbsp; &nbsp; 由于n只小猫的初始花生数均为0，因此最终P矩阵的第n+1列的第1~n行元素的值就是最后n只小猫的最后花生数。</p>
<p>&nbsp; &nbsp; &nbsp; （2）源程序。</p>
<p style="margin-left: 30px;">#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />struct Matrix<br />{<br />&nbsp; &nbsp; &nbsp; __int64 mat[105][105];<br />};<br />Matrix start;<br />Matrix matMul(Matrix a ,Matrix b,int n)<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat,0,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i,j,k;<br />&nbsp; &nbsp; &nbsp; for (k = 1; k&lt;=n ; k++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1 ;i&lt;=n ; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(a.mat[i][k])<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1 ;j&lt;=n ;j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] * b.mat[k][j]);<br />&nbsp; &nbsp; &nbsp;return c;<br />}<br />Matrix quickMatPow(Matrix a ,int b ,int n) // n阶矩阵a快速b次幂<br />{<br />&nbsp; &nbsp; &nbsp; Matrix c;<br />&nbsp; &nbsp; &nbsp; memset(c.mat ,0 ,sizeof(c.mat));<br />&nbsp; &nbsp; &nbsp; int i;<br />&nbsp; &nbsp; &nbsp; for (i = 1 ;i &lt;= n ;i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; while(b)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (b &amp; 1) <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c = matMul(c ,a ,n);   // c=c*a;   <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = matMul(a ,a ,n);      // a=a*a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b /= 2;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return c;<br />}<br />int main()<br />{<br />&nbsp; &nbsp; &nbsp; int n,m,k,i,j;<br />&nbsp; &nbsp; &nbsp; __int64 t;<br />&nbsp; &nbsp; &nbsp; while (scanf("%d%d%d",&amp;n,&amp;m,&amp;k)!=EOF)<br />&nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (n==0 &amp;&amp; m==0 &amp;&amp; k==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(start.mat, 0, sizeof(start.mat));<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i = 1; i&lt;=n; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start.mat[i][i] = 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i=1; i&lt;=k; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int a, b;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char ch[2];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%s", ch);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ch[0] == 'g')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d", &amp;a);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start.mat[a][n]++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else if (ch[0] == 'e')<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d", &amp;a);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1; j &lt;= n; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start.mat[a][j] = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf("%d%d", &amp;a, &amp;b);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (j = 1; j&lt;=n; j++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;t=start.mat[a][j];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start.mat[a][j]=start.mat[b][j];<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start.mat[b][j]=t;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start= quickMatPow(start,m,n);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (i = 1; i &lt;n; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("%I64d ", start.mat[i][n]);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf("\n");<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; return 0;	<br />}</p>
<p style="margin-left: 30px;">将此源程序提交给 <a href="http://poj.org/problem?id=3735" target="_blank">POJ 3735&ldquo;Training little cats&rdquo;</a>，可以Accepted。</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>