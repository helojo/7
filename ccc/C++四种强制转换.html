<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修C++四种强制转换' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>C++四种强制转换</center></div><div class='banquan'>原文出处:本文由博客园博主快牵着我的袜子提供。<br/>
原文连接:https://www.cnblogs.com/socks/p/11446839.html</div><br>
    <p>C语言的强制转换为在数据面前之间加数据类型进行转换，即（目标数据类型）原数据类型。<span style="color: #ff0000;">c++</span>为了更好的<span style="color: #ff0000;"><strong>区分强制转换的类型</strong></span>，达到<span style="color: #ff0000;">见其名知其意</span>的效果，共将强制转换分为四种，即</p>
<p>1、static_cast&lt;目标数据类型&gt;原数据类型</p>
<p>2、const_cast&lt;目标数据类型&gt;原数据类型</p>
<p>3、reinterpret_cast&lt;目标数据类型&gt;原数据类型</p>
<p>4、dynamic_cast&lt;目标数据类型&gt;原数据类型</p>
<p><img src="./images/C++四种强制转换0.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>解析</h2>
<h3>static_cast&lt;&gt;()</h3>
<p><span style="font-size: 14px;">1）用于类层次结构中基类和派生类之间指针或引用的转换<br />&nbsp; &nbsp;&nbsp;&nbsp; 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的<br />&nbsp; &nbsp;&nbsp;&nbsp; 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的</span></p>
<p><span style="font-size: 14px;"><br />&nbsp;2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全由开发人员来保证</span></p>
<p><span style="font-size: 14px;"><br />&nbsp;3）把空指针转换成目标类型的空指针</span></p>
<p><span style="font-size: 14px;"><br />&nbsp;4）把任何类型的表达式转换为void类型</span></p>
<p><span style="font-size: 14px;"><br />&nbsp; &nbsp; 注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。</span></p>
<p>&nbsp;</p>
<p><strong>　static_cast:可以实现C++中内置基本数据类型之间的相互转换。</strong></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 如果涉及到类的话，static_cast只能在<strong>有相互联系的类型中进行相互转换,</strong>不一定包含虚函数。</p>
<p>&nbsp;</p>
<h3>const_cast&lt;&gt;()</h3>
<p>&nbsp;</p>
<p>cost_cast即用于强制转换<span style="color: #ff0000;">指针或者引用</span>的<span style="color: #ff0000;">const</span>或<span style="color: #ff0000;">volatile</span>限制，特别注意的是，const_cast<span style="color: #ff0000;">不是</span>用于<span style="color: #ff0000;">去除变量的常量性</span>，而是<span style="color: #ff0000;">去除</span>指向常数对象的<span style="color: #ff0000;">指针或引用</span>的常量性，其去除常量性的对象必须为指针或引用。</p>
<p>　　&nbsp; &nbsp; 常量指针被转化成非常量指针，并且仍然指向原来的对象；<br />&nbsp;&nbsp;&nbsp;　　&nbsp;常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</p>
<p>1、变量为<span style="color: #ff0000;">常量</span>，指针也为<span style="color: #ff0000;">常量</span></p>
<p><img src="./images/C++四种强制转换1.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;结果：</p>
<p><img src="./images/C++四种强制转换2.png" alt="" /></p>
<p>&nbsp;</p>
<p>2、变量为<span style="color: #ff0000;">普通变量</span>，指针为<span style="color: #ff0000;">常量</span></p>
<p>&nbsp;<img src="./images/C++四种强制转换3.png" alt="" /></p>
<p>&nbsp;</p>
<p>结果：</p>
<p>&nbsp;<img src="./images/C++四种强制转换4.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>reinterpret_cast&lt;&gt;()</h3>
<p>reinterpret_cast运算符用于处理无关类型之间的转换，他会产生一个新的值，这个值会有与原始参数（原数据类型）有完全相同的比特位</p>
<ul>
<li title="A pointer to any integral type large enough to hold it">从指针类型到一个足够大的整数类型</li>
<li title="A value of integral or enumeration type to a pointer">从整数类型或者枚举类型到指针类型</li>
<li title="A pointer to a function to a pointer to a function of a different type">从一个指向函数的指针到另一个不同类型的指向函数的指针</li>
<li title="A pointer to an object to a pointer to an object of a different type">从一个指向对象的指针到另一个不同类型的指向对象的指针</li>
<li title="A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types">从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针</li>
<li title="A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types">从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针</li>



</ul>
<p>&nbsp;</p>
<h3>dynamic_cast&lt;&gt;()</h3>
<p>&nbsp;</p>
<p><strong>（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</strong></p>
<p><strong>（2）不能用于内置的基本数据类型的强制转换。</strong></p>
<p><strong>（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</strong></p>
<p><strong>（4）使用dynamic_cast进行转换的，<span style="color: #ff0000;">基类中一定要有虚函数</span>，否则编译不通过。</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</strong></p>
<div class="spctrl"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></div>
<div class="spctrl"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于<a href="http://baike.baidu.com/view/3750123.htm" target="_blank">虚函数表</a>的概念，详细可见&lt;Inside c++ object model&gt;）中，</strong></div>
<p><strong>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;只有定义了虚函数的类才有虚函数表。</strong></p>
<p>&nbsp;</p>
<p><strong>&nbsp;（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和<a href="http://baike.baidu.com/view/1745207.htm" target="_blank">static_cast</a>的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</strong></p>
<p><strong>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。</strong></p>
<p><strong><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em><span style="color: #ff0000;">向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</span></strong></p>
<p><strong>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考：https://www.cnblogs.com/Allen-rg/p/6999360.html</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>