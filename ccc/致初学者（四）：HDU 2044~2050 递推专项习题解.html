<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修致初学者（四）：HDU 2044~2050 递推专项习题解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>致初学者（四）：HDU 2044~2050 递推专项习题解</center></div><div class='banquan'>原文出处:本文由博客园博主aTeacher提供。<br/>
原文连接:https://www.cnblogs.com/cs-whut/p/11552580.html</div><br>
    <p>&nbsp; &nbsp; &nbsp; 所谓递推，是指从已知的初始条件出发，依据某种递推关系，逐次推出所要求的各中间结果及最后结果。其中初始条件或是问题本身已经给定，或是通过对问题的分析与化简后确定。关于递推的知识可以参阅本博客中随笔&ldquo;<a href="https://www.cnblogs.com/cs-whut/p/11022438.html" target="_blank">递推（一）：递推法的基本思想</a>&rdquo;。</p>
<p>&nbsp; &nbsp; &nbsp; HDU 2044~2050这7道题是针对初学者进行递推学习的专项练习，下面给出它们的AC程序供参考。</p>
<p><strong><span style="font-size: 15px;">HDU 2044：一只小蜜蜂</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 不妨将图示的蜂箱结构看成从1--&mdash;2&mdash;&mdash;-3&mdash;&mdash;&hellip;的一个&ldquo;W&rdquo;型楼梯。蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。可以等效地看成蜜蜂每次上楼梯可以走一级，也可以走两级。</p>
<p>&nbsp; &nbsp; &nbsp; 易得递推公式 ： f[n]=f[n-1]+f[n-2] (n&gt;2)&nbsp; f[1]=1 f[2]=2。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('84dcc725-83d6-4edd-94df-c29e2c72ccb0')"><img id="code_img_closed_84dcc725-83d6-4edd-94df-c29e2c72ccb0" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_84dcc725-83d6-4edd-94df-c29e2c72ccb0" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('84dcc725-83d6-4edd-94df-c29e2c72ccb0',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_84dcc725-83d6-4edd-94df-c29e2c72ccb0" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,a,b,i;
    __int64 f[</span><span style="color: #800080;">51</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">3</span>;i&lt;=<span style="color: #800080;">50</span>;i++<span style="color: #000000;">)
        f[i]</span>=f[i-<span style="color: #800080;">1</span>]+f[i-<span style="color: #800080;">2</span><span style="color: #000000;">];
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
    </span><span style="color: #0000ff;">while</span> (n--<span style="color: #000000;">)
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>,&amp;a,&amp;<span style="color: #000000;">b);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span>,f[b-<span style="color: #000000;">a]);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2045 不容易系列之(3)&mdash;&mdash; LELE的RPG难题</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;设满足要求的n个方格的涂色方法数为F(n)。</p>
<p>&nbsp; &nbsp; &nbsp; 因为RPG有三种颜色，可以先枚举出当方格数为1、2、3时的涂法种数。</p>
<p>&nbsp; &nbsp; &nbsp; 显然，F(1)=3 &nbsp;&nbsp;（即R、P、G三种）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;F(2)=6&nbsp; &nbsp;（即RP、RG、PR、PG、GR、GP六种）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;F(3)=6&nbsp;&nbsp; （即RPG、RGP、PRG、PGR、GRP、GPR六种）</p>
<p>&nbsp; &nbsp; &nbsp; 当方格的个数大于3时，n个方格的涂色方案可以由n-1方格的涂色方案追加最后一个方格的涂色方案得出，分两种情况：</p>
<p>&nbsp; &nbsp; &nbsp; （1）对于已按要求涂好颜色的n-1个方格，在F(n-1)种合法的涂色方案后追加一个方格（第n个方格），由于合法方案的首尾颜色不同（即第n-1个方格的颜色不与第1个方格的相同），这样，第n个方格的颜色也是确定的，它必定是原n-1个方格的首尾两种颜色之外的一种，因此，在这种情况下的涂色方法数为F(n-1)。</p>
<p>&nbsp; &nbsp; &nbsp; （2）对于已按要求涂好颜色的n-2个方格，可以在第n-1个方格中涂与第1个方格相同的颜色，此时由于首尾颜色相同，这是不合法的涂色方案，但可以在第n个方格中涂上一个合法的颜色，使其成为方格长度为n的合法涂色方案（注意：当n等于3时，由于第1(3-2)个方格与第2(3-1)个方格颜色相同，第3个方格不论怎样涂都不会合法，因此递推的前提是n大于3），在第n个方格中可以涂上两种颜色（即首格外的两种颜色，因为与它相连的第n-1个方格和第1个方格的颜色是一样的），因此，在这种情况下的涂色方法数为2*F(n-2)。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由此，可得递推公式：F(n)= F(n-1) + 2*F(n-2)&nbsp; (n&gt;=4)</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('04f7b3d5-ebd5-445f-a6d1-e1da6675c4bf')"><img id="code_img_closed_04f7b3d5-ebd5-445f-a6d1-e1da6675c4bf" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_04f7b3d5-ebd5-445f-a6d1-e1da6675c4bf" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('04f7b3d5-ebd5-445f-a6d1-e1da6675c4bf',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_04f7b3d5-ebd5-445f-a6d1-e1da6675c4bf" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
   </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,n;
   __int64 f[</span><span style="color: #800080;">51</span><span style="color: #000000;">]; 
   f[</span><span style="color: #800080;">0</span>]=<span style="color: #800080;">0</span><span style="color: #000000;">;    
   f[</span><span style="color: #800080;">1</span>]=<span style="color: #800080;">3</span><span style="color: #000000;">;     
   f[</span><span style="color: #800080;">2</span>]=<span style="color: #800080;">6</span><span style="color: #000000;">;    
   f[</span><span style="color: #800080;">3</span>]=<span style="color: #800080;">6</span><span style="color: #000000;">;     
   </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">4</span>;i&lt;<span style="color: #800080;">51</span>;i++<span style="color: #000000;">)         
       f[i]</span>=f[i-<span style="color: #800080;">1</span>]+<span style="color: #800080;">2</span>*f[i-<span style="color: #800080;">2</span><span style="color: #000000;">];     
   </span><span style="color: #0000ff;">while</span> (scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;n)!=<span style="color: #000000;">EOF)
   {
       printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,f[n]);
   }
   </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2046 骨牌铺方格</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 设f[n]表示在2&times;n的一个长方形方格中用一个1&times; 2的骨牌铺满方格的方案数。显然</p>
<p>&nbsp; &nbsp; &nbsp; 2&times;n的长方形方格可以看成由2&times;(n-1)的长方形（方案数为f[n-1]）加1块竖放的骨牌构成，也可以看成由2&times;(n-2)的长方形（方案数为f[n-2]）加2块横放的骨牌构成。</p>
<p>&nbsp; &nbsp; &nbsp; 易得 递推式为： f[n]=f[n-1]+f[n-2] （n&gt;2）。f[1]=1，f[2]=2。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f50f7cc5-c50c-446a-a793-582c43722356')"><img id="code_img_closed_f50f7cc5-c50c-446a-a793-582c43722356" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_f50f7cc5-c50c-446a-a793-582c43722356" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f50f7cc5-c50c-446a-a793-582c43722356',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_f50f7cc5-c50c-446a-a793-582c43722356" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,i;
    __int64 f[</span><span style="color: #800080;">51</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">3</span>;i&lt;=<span style="color: #800080;">50</span>;i++<span style="color: #000000;">)
        f[i]</span>=f[i-<span style="color: #800080;">1</span>]+f[i-<span style="color: #800080;">2</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">while</span> (scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;n)!=<span style="color: #000000;">EOF)
    {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,f[n]);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2047 阿牛的EOF牛肉串</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 定义二维数组f[40][3]，其中f[i][0]表示长度为i,最后字符为'E'的串的数目；</p>
<p>&nbsp; &nbsp; &nbsp; f[i][1]表示长度为i,最后字符为'O'的串的数目；f[i][2]表示长度为i,最后字符为'F'的串的数目。</p>
<p>&nbsp; &nbsp; &nbsp; 显然，对于长度为i+1的字符串，若最后字符取'E'或'F',则其前面的一个字符任意，</p>
<p>&nbsp; &nbsp; &nbsp; 即&nbsp; f[i+1][0]=f[i][0]+f[i][1]+f[i][2]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f[i+1][2]=f[i][0]+f[i][1]+f[i][2]</p>
<p>&nbsp; &nbsp; &nbsp;若最后字符取'O'，则其前面的字符只能为'E'或'F'，所以</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[i+1][1]=f[i][0]+f[i][2]</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('2bbac22b-bd0e-480c-9a6d-40d82a4fa5ad')"><img id="code_img_closed_2bbac22b-bd0e-480c-9a6d-40d82a4fa5ad" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_2bbac22b-bd0e-480c-9a6d-40d82a4fa5ad" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2bbac22b-bd0e-480c-9a6d-40d82a4fa5ad',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_2bbac22b-bd0e-480c-9a6d-40d82a4fa5ad" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n,i;
    __int64 f[</span><span style="color: #800080;">41</span>][<span style="color: #800080;">3</span><span style="color: #000000;">];
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    f[</span><span style="color: #800080;">1</span>][<span style="color: #800080;">2</span>]=<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">2</span>;i&lt;<span style="color: #800080;">40</span>;i++<span style="color: #000000;">)
    {
        f[i][</span><span style="color: #800080;">0</span>]=f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>]+f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>]+f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
        f[i][</span><span style="color: #800080;">2</span>]=f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>]+f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>]+f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
        f[i][</span><span style="color: #800080;">1</span>]=f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>]+f[i-<span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">while</span> (scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;n)!=<span style="color: #000000;">EOF)
    {
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span>,f[n][<span style="color: #800080;">0</span>]+f[n][<span style="color: #800080;">1</span>]+f[n][<span style="color: #800080;">2</span><span style="color: #000000;">]);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2048 神、上帝以及老天爷</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 用递推的方法推导错排公式。</p>
<p>&nbsp; &nbsp; &nbsp; 设n个人抽n张纸条，纸条上的名字与自己的名字全不对应的方法数用F(n)表示，那么F(n-1)就表示n-1个人抽n-1张纸条，纸条上的名字与自己的名字全不对应的方法。</p>
<p>&nbsp; &nbsp; &nbsp; n张全部不对应的纸条可以看成前n - 1张纸条再加1张纸条后，将最后1张纸条弄错，弄错的方式自然是与之前的纸条进行交换，交换的方式有两种：</p>
<p>&nbsp; &nbsp; &nbsp;（1）在前n-1个全部不对应的纸条中取任意一张进行交换。n-1张纸条全部不对应的方法数为F(n-1)，在n-1张纸条中任取一张的方法数为n-1，因此，这种情况下，方法数共有F(n-1)* (n-1)种。</p>
<p>&nbsp; &nbsp; &nbsp; （2）在前n-1张纸条中，有n-2个全不对应，有1张正确，取正确的一张进行交换。n-1张纸条中只有一张对应正确的方法数有n-1，其余n-2张纸条全不对应的方法数有F(n-2)， 因此，这种情况下，方法数共有F(n-1)* (n-1)种。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;由此，可得错排的递推公式： F(n)=[F(n-2)+F(n-1)]*(n-1) 。</p>
<p>&nbsp; &nbsp; &nbsp; 初始情况为：F(1)=0 &nbsp;（只有1张纸条不可抽错）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;F(2)=1&nbsp; （两张纸条全不对应只有1种情况，即正确的两张交换）</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('083906ec-6692-4d0d-894e-af7e7bacf97f')"><img id="code_img_closed_083906ec-6692-4d0d-894e-af7e7bacf97f" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_083906ec-6692-4d0d-894e-af7e7bacf97f" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('083906ec-6692-4d0d-894e-af7e7bacf97f',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_083906ec-6692-4d0d-894e-af7e7bacf97f" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
   </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i,c,n;
   __int64 f[</span><span style="color: #800080;">21</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span><span style="color: #000000;">}; 
   </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> ans;
   </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">3</span>;i&lt;=<span style="color: #800080;">20</span>;i++<span style="color: #000000;">)
   {
        f[i]</span>=(f[i-<span style="color: #800080;">1</span>]+f[i-<span style="color: #800080;">2</span>])*(i-<span style="color: #800080;">1</span><span style="color: #000000;">);
    }
   scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">c);
   </span><span style="color: #0000ff;">while</span> (c--<span style="color: #000000;">)
   {
       scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
       ans</span>=<span style="color: #800080;">1.0</span>*<span style="color: #000000;">f[n];
       </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">2</span>;i&lt;=n;i++<span style="color: #000000;">)
           ans</span>/=<span style="color: #000000;">i;
       printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%.2lf%%\n</span><span style="color: #800000;">"</span>,<span style="color: #800080;">100</span>*<span style="color: #000000;">ans);
   }
   </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2049 不容易系列之(4)&mdash;&mdash;考新郎</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 先求出m（1&lt;=m&lt;=20）个元素的错排数，用一维数组a来保存，其中a[i]保存i个元素的错排数。</p>
<p>&nbsp; &nbsp; &nbsp; 再求在n个元素中挑选出m个元素的组合数c（n,m）。</p>
<p>&nbsp; &nbsp; &nbsp; 这样，n对新婚夫妇中m个新郎找错了新娘的情况一共有c(n,m)*a[m]种。</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('5278ab5d-24fc-416a-920e-4e3cc0332ce6')"><img id="code_img_closed_5278ab5d-24fc-416a-920e-4e3cc0332ce6" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_5278ab5d-24fc-416a-920e-4e3cc0332ce6" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('5278ab5d-24fc-416a-920e-4e3cc0332ce6',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_5278ab5d-24fc-416a-920e-4e3cc0332ce6" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> t,n,m,p,i;
    __int64  c,sum,a[</span><span style="color: #800080;">21</span>]={<span style="color: #800080;">0</span>,<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">3</span>;i&lt;<span style="color: #800080;">21</span>;i++<span style="color: #000000;">)
    {
        a[i]</span>=(a[i-<span style="color: #800080;">1</span>]+a[i-<span style="color: #800080;">2</span>])*(i-<span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">t);
    </span><span style="color: #0000ff;">while</span> (t--<span style="color: #000000;">)
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>,&amp;n,&amp;<span style="color: #000000;">m);
        c</span>=<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n-m&gt;m)  p=n-<span style="color: #000000;">m;
        </span><span style="color: #0000ff;">else</span>   p=<span style="color: #000000;">m;
        </span><span style="color: #0000ff;">for</span> (i=n; i&gt;p;i--<span style="color: #000000;">)
           c</span>=c*<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">for</span> (i=<span style="color: #800080;">1</span>;i&lt;=n-p;i++<span style="color: #000000;">)
           c</span>=c/<span style="color: #000000;">i;
        sum</span>=c*<span style="color: #000000;">a[m];
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,sum);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p><strong><span style="font-size: 15px;">HDU 2050 折线分割平面</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 设n-1条折线把空间划分的区域数为f(n-1)。</p>
<p>&nbsp; &nbsp; &nbsp; 现有n条折线，为了让增加的区域更多，新增的折线要和之前的n-1条折线的2*(n-1)条边都相交，产生4*(n-1)条新的线段和2条射线，每条线段或射线产生一个新区域，但是折线相交的头部的两线段一共只能产生一个区域，所以新增区域的数量为4*(n-1) -1+2， 即&nbsp;4*(n-1) +1。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 所以有递推公式：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;f(n)=f(n-1)+4(n-1) + 1;</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; =f(n-2)+4(n-2)+4(n-1)+2;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; .......</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;=f(n-(n-1)) +4(n-(n-1))+4(n-(n-2))+......+4(n-1) + n-1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;=f(1) +4(1+2+3+4+....+n-1)+n-1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;=2+4((n-1)(n-1+1)/2)+n-1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;=2n^2-n+1;</p>
<div class="cnblogs_code" onclick="cnblogs_code_show('f5e1ab19-dc49-48ea-99c7-5b3969130d00')"><img id="code_img_closed_f5e1ab19-dc49-48ea-99c7-5b3969130d00" class="code_img_closed" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解0.png" alt="" /><img id="code_img_opened_f5e1ab19-dc49-48ea-99c7-5b3969130d00" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('f5e1ab19-dc49-48ea-99c7-5b3969130d00',event)" src="./images/致初学者（四）：HDU 2044~2050 递推专项习题解1.png" alt="" />
<div id="cnblogs_code_open_f5e1ab19-dc49-48ea-99c7-5b3969130d00" class="cnblogs_code_hide">
<pre>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> c;
    __int64 n;
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">c);
    </span><span style="color: #0000ff;">while</span> (c--<span style="color: #000000;">)
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%I64d\n</span><span style="color: #800000;">"</span>,<span style="color: #800080;">2</span>*n*n-n+<span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>